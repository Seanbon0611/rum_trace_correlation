import { display } from '../tools/display';
import { computeBytesCount, jsonStringify, objectValues } from '../tools/utils';
import { monitor } from '../tools/monitor';
import { Observable } from '../tools/observable';
var Batch = /** @class */ (function () {
    function Batch(request, batchMessagesLimit, batchBytesLimit, messageBytesLimit, flushTimeout, pageExitObservable) {
        var _this = this;
        this.request = request;
        this.batchMessagesLimit = batchMessagesLimit;
        this.batchBytesLimit = batchBytesLimit;
        this.messageBytesLimit = messageBytesLimit;
        this.flushTimeout = flushTimeout;
        this.pageExitObservable = pageExitObservable;
        this.flushObservable = new Observable();
        this.pushOnlyBuffer = [];
        this.upsertBuffer = {};
        this.bufferBytesCount = 0;
        this.bufferMessagesCount = 0;
        pageExitObservable.subscribe(function () { return _this.flush(_this.request.sendOnExit); });
        this.flushPeriodically();
    }
    Batch.prototype.add = function (message) {
        this.addOrUpdate(message);
    };
    Batch.prototype.upsert = function (message, key) {
        this.addOrUpdate(message, key);
    };
    Batch.prototype.flush = function (sendFn) {
        if (sendFn === void 0) { sendFn = this.request.send; }
        if (this.bufferMessagesCount !== 0) {
            var messages = this.pushOnlyBuffer.concat(objectValues(this.upsertBuffer));
            var bytesCount = this.bufferBytesCount;
            this.flushObservable.notify({
                bufferBytesCount: this.bufferBytesCount,
                bufferMessagesCount: this.bufferMessagesCount,
            });
            this.pushOnlyBuffer = [];
            this.upsertBuffer = {};
            this.bufferBytesCount = 0;
            this.bufferMessagesCount = 0;
            sendFn({ data: messages.join('\n'), bytesCount: bytesCount });
        }
    };
    Batch.prototype.addOrUpdate = function (message, key) {
        var _a = this.process(message), processedMessage = _a.processedMessage, messageBytesCount = _a.messageBytesCount;
        if (messageBytesCount >= this.messageBytesLimit) {
            display.warn("Discarded a message whose size was bigger than the maximum allowed size ".concat(this.messageBytesLimit, "KB."));
            return;
        }
        if (this.hasMessageFor(key)) {
            this.remove(key);
        }
        if (this.willReachedBytesLimitWith(messageBytesCount)) {
            this.flush();
        }
        this.push(processedMessage, messageBytesCount, key);
        if (this.isFull()) {
            this.flush();
        }
    };
    Batch.prototype.process = function (message) {
        var processedMessage = jsonStringify(message);
        var messageBytesCount = computeBytesCount(processedMessage);
        return { processedMessage: processedMessage, messageBytesCount: messageBytesCount };
    };
    Batch.prototype.push = function (processedMessage, messageBytesCount, key) {
        if (this.bufferMessagesCount > 0) {
            // \n separator at serialization
            this.bufferBytesCount += 1;
        }
        if (key !== undefined) {
            this.upsertBuffer[key] = processedMessage;
        }
        else {
            this.pushOnlyBuffer.push(processedMessage);
        }
        this.bufferBytesCount += messageBytesCount;
        this.bufferMessagesCount += 1;
    };
    Batch.prototype.remove = function (key) {
        var removedMessage = this.upsertBuffer[key];
        delete this.upsertBuffer[key];
        var messageBytesCount = computeBytesCount(removedMessage);
        this.bufferBytesCount -= messageBytesCount;
        this.bufferMessagesCount -= 1;
        if (this.bufferMessagesCount > 0) {
            this.bufferBytesCount -= 1;
        }
    };
    Batch.prototype.hasMessageFor = function (key) {
        return key !== undefined && this.upsertBuffer[key] !== undefined;
    };
    Batch.prototype.willReachedBytesLimitWith = function (messageBytesCount) {
        // byte of the separator at the end of the message
        return this.bufferBytesCount + messageBytesCount + 1 >= this.batchBytesLimit;
    };
    Batch.prototype.isFull = function () {
        return this.bufferMessagesCount === this.batchMessagesLimit || this.bufferBytesCount >= this.batchBytesLimit;
    };
    Batch.prototype.flushPeriodically = function () {
        var _this = this;
        setTimeout(monitor(function () {
            _this.flush();
            _this.flushPeriodically();
        }), this.flushTimeout);
    };
    return Batch;
}());
export { Batch };
//# sourceMappingURL=batch.js.map