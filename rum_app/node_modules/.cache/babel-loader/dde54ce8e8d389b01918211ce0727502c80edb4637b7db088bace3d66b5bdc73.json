{"ast":null,"code":"import { addTelemetryDebug, assign, monitor, sendToExtension } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nimport * as replayStats from '../replayStats';\nvar nextId = 0;\nvar Segment = /** @class */function () {\n  function Segment(worker, context, creationReason, initialRecord, onWrote, onFlushed) {\n    var _this = this;\n    this.worker = worker;\n    this.id = nextId++;\n    var viewId = context.view.id;\n    this.metadata = assign({\n      start: initialRecord.timestamp,\n      end: initialRecord.timestamp,\n      creation_reason: creationReason,\n      records_count: 1,\n      has_full_snapshot: initialRecord.type === RecordType.FullSnapshot,\n      index_in_view: replayStats.getSegmentsCount(viewId),\n      source: 'browser'\n    }, context);\n    replayStats.addSegment(viewId);\n    replayStats.addRecord(viewId);\n    var listener = monitor(function (_a) {\n      var data = _a.data;\n      if (data.type === 'errored' || data.type === 'initialized') {\n        return;\n      }\n      if (data.id === _this.id) {\n        replayStats.addWroteData(viewId, data.additionalBytesCount);\n        if (data.type === 'flushed') {\n          onFlushed(data.result, data.rawBytesCount);\n          worker.removeEventListener('message', listener);\n        } else {\n          onWrote(data.compressedBytesCount);\n        }\n      } else if (data.id > _this.id) {\n        // Messages should be received in the same order as they are sent, so if we receive a\n        // message with an id superior to this Segment instance id, we know that another, more\n        // recent Segment instance is being used.\n        //\n        // In theory, a \"flush\" response should have been received at this point, so the listener\n        // should already have been removed. But if something goes wrong and we didn't receive a\n        // \"flush\" response, remove the listener to avoid any leak, and send a monitor message to\n        // help investigate the issue.\n        worker.removeEventListener('message', listener);\n        addTelemetryDebug(\"Segment did not receive a 'flush' response before being replaced.\");\n      }\n    });\n    worker.addEventListener('message', listener);\n    sendToExtension('record', {\n      record: initialRecord,\n      segment: this.metadata\n    });\n    this.worker.postMessage({\n      data: \"{\\\"records\\\":[\".concat(JSON.stringify(initialRecord)),\n      id: this.id,\n      action: 'write'\n    });\n  }\n  Segment.prototype.addRecord = function (record) {\n    var _a;\n    this.metadata.start = Math.min(this.metadata.start, record.timestamp);\n    this.metadata.end = Math.max(this.metadata.end, record.timestamp);\n    this.metadata.records_count += 1;\n    replayStats.addRecord(this.metadata.view.id);\n    (_a = this.metadata).has_full_snapshot || (_a.has_full_snapshot = record.type === RecordType.FullSnapshot);\n    sendToExtension('record', {\n      record: record,\n      segment: this.metadata\n    });\n    this.worker.postMessage({\n      data: \",\".concat(JSON.stringify(record)),\n      id: this.id,\n      action: 'write'\n    });\n  };\n  Segment.prototype.flush = function (reason) {\n    this.worker.postMessage({\n      data: \"],\".concat(JSON.stringify(this.metadata).slice(1), \"\\n\"),\n      id: this.id,\n      action: 'flush'\n    });\n    this.flushReason = reason;\n  };\n  return Segment;\n}();\nexport { Segment };","map":{"version":3,"names":["addTelemetryDebug","assign","monitor","sendToExtension","RecordType","replayStats","nextId","Segment","worker","context","creationReason","initialRecord","onWrote","onFlushed","_this","id","viewId","view","metadata","start","timestamp","end","creation_reason","records_count","has_full_snapshot","type","FullSnapshot","index_in_view","getSegmentsCount","source","addSegment","addRecord","listener","_a","data","addWroteData","additionalBytesCount","result","rawBytesCount","removeEventListener","compressedBytesCount","addEventListener","record","segment","postMessage","concat","JSON","stringify","action","prototype","Math","min","max","flush","reason","slice","flushReason"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/apm-enablement-sessions/rum_and_trace_correlation/react-app/node_modules/@datadog/browser-rum/src/domain/segmentCollection/segment.ts"],"sourcesContent":["import { addTelemetryDebug, assign, monitor, sendToExtension } from '@datadog/browser-core'\nimport type { BrowserRecord, BrowserSegmentMetadata, CreationReason, SegmentContext } from '../../types'\nimport { RecordType } from '../../types'\nimport * as replayStats from '../replayStats'\nimport type { DeflateWorker, DeflateWorkerListener } from './deflateWorker'\n\nlet nextId = 0\n\nexport type FlushReason = Exclude<CreationReason, 'init'> | 'stop'\n\nexport class Segment {\n  public flushReason: FlushReason | undefined\n\n  public readonly metadata: BrowserSegmentMetadata\n\n  private id = nextId++\n\n  constructor(\n    private worker: DeflateWorker,\n    context: SegmentContext,\n    creationReason: CreationReason,\n    initialRecord: BrowserRecord,\n    onWrote: (compressedBytesCount: number) => void,\n    onFlushed: (data: Uint8Array, rawBytesCount: number) => void\n  ) {\n    const viewId = context.view.id\n\n    this.metadata = assign(\n      {\n        start: initialRecord.timestamp,\n        end: initialRecord.timestamp,\n        creation_reason: creationReason,\n        records_count: 1,\n        has_full_snapshot: initialRecord.type === RecordType.FullSnapshot,\n        index_in_view: replayStats.getSegmentsCount(viewId),\n        source: 'browser' as const,\n      },\n      context\n    )\n\n    replayStats.addSegment(viewId)\n    replayStats.addRecord(viewId)\n\n    const listener: DeflateWorkerListener = monitor(({ data }) => {\n      if (data.type === 'errored' || data.type === 'initialized') {\n        return\n      }\n\n      if (data.id === this.id) {\n        replayStats.addWroteData(viewId, data.additionalBytesCount)\n        if (data.type === 'flushed') {\n          onFlushed(data.result, data.rawBytesCount)\n          worker.removeEventListener('message', listener)\n        } else {\n          onWrote(data.compressedBytesCount)\n        }\n      } else if (data.id > this.id) {\n        // Messages should be received in the same order as they are sent, so if we receive a\n        // message with an id superior to this Segment instance id, we know that another, more\n        // recent Segment instance is being used.\n        //\n        // In theory, a \"flush\" response should have been received at this point, so the listener\n        // should already have been removed. But if something goes wrong and we didn't receive a\n        // \"flush\" response, remove the listener to avoid any leak, and send a monitor message to\n        // help investigate the issue.\n        worker.removeEventListener('message', listener)\n        addTelemetryDebug(\"Segment did not receive a 'flush' response before being replaced.\")\n      }\n    })\n    worker.addEventListener('message', listener)\n    sendToExtension('record', { record: initialRecord, segment: this.metadata })\n    this.worker.postMessage({ data: `{\"records\":[${JSON.stringify(initialRecord)}`, id: this.id, action: 'write' })\n  }\n\n  addRecord(record: BrowserRecord): void {\n    this.metadata.start = Math.min(this.metadata.start, record.timestamp)\n    this.metadata.end = Math.max(this.metadata.end, record.timestamp)\n    this.metadata.records_count += 1\n    replayStats.addRecord(this.metadata.view.id)\n    this.metadata.has_full_snapshot ||= record.type === RecordType.FullSnapshot\n    sendToExtension('record', { record, segment: this.metadata })\n    this.worker.postMessage({ data: `,${JSON.stringify(record)}`, id: this.id, action: 'write' })\n  }\n\n  flush(reason: FlushReason) {\n    this.worker.postMessage({\n      data: `],${JSON.stringify(this.metadata).slice(1)}\\n`,\n      id: this.id,\n      action: 'flush',\n    })\n    this.flushReason = reason\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}