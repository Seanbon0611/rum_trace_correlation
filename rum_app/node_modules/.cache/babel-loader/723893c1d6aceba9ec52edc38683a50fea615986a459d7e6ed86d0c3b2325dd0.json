{"ast":null,"code":"import { getCookie, setCookie } from '../../browser/cookie';\nimport { isChromium } from '../../tools/browserDetection';\nimport { monitor } from '../../tools/monitor';\nimport { dateNow } from '../../tools/timeUtils';\nimport * as utils from '../../tools/utils';\nimport { SESSION_EXPIRATION_DELAY } from './sessionConstants';\nvar SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/;\nvar SESSION_ENTRY_SEPARATOR = '&';\nexport var SESSION_COOKIE_NAME = '_dd_s';\n// arbitrary values\nexport var LOCK_RETRY_DELAY = 10;\nexport var MAX_NUMBER_OF_LOCK_RETRIES = 100;\nvar bufferedOperations = [];\nvar ongoingOperations;\nexport function withCookieLockAccess(operations, numberOfRetries) {\n  var _a;\n  if (numberOfRetries === void 0) {\n    numberOfRetries = 0;\n  }\n  if (!ongoingOperations) {\n    ongoingOperations = operations;\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations);\n    return;\n  }\n  if (numberOfRetries >= MAX_NUMBER_OF_LOCK_RETRIES) {\n    next();\n    return;\n  }\n  var currentLock;\n  var currentSession = retrieveSession();\n  if (isCookieLockEnabled()) {\n    // if someone has lock, retry later\n    if (currentSession.lock) {\n      retryLater(operations, numberOfRetries);\n      return;\n    }\n    // acquire lock\n    currentLock = utils.generateUUID();\n    currentSession.lock = currentLock;\n    setSession(currentSession, operations.options);\n    // if lock is not acquired, retry later\n    currentSession = retrieveSession();\n    if (currentSession.lock !== currentLock) {\n      retryLater(operations, numberOfRetries);\n      return;\n    }\n  }\n  var processedSession = operations.process(currentSession);\n  if (isCookieLockEnabled()) {\n    // if lock corrupted after process, retry later\n    currentSession = retrieveSession();\n    if (currentSession.lock !== currentLock) {\n      retryLater(operations, numberOfRetries);\n      return;\n    }\n  }\n  if (processedSession) {\n    persistSession(processedSession, operations.options);\n  }\n  if (isCookieLockEnabled()) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentSession = retrieveSession();\n      if (currentSession.lock !== currentLock) {\n        retryLater(operations, numberOfRetries);\n        return;\n      }\n      delete currentSession.lock;\n      setSession(currentSession, operations.options);\n      processedSession = currentSession;\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date cookie value, the value could have been modified by another tab\n  (_a = operations.after) === null || _a === void 0 ? void 0 : _a.call(operations, processedSession || currentSession);\n  next();\n}\n/**\n * Cookie lock strategy allows mitigating issues due to concurrent access to cookie.\n * This issue concerns only chromium browsers and enabling this on firefox increase cookie write failures.\n */\nfunction isCookieLockEnabled() {\n  return isChromium();\n}\nfunction retryLater(operations, currentNumberOfRetries) {\n  setTimeout(monitor(function () {\n    withCookieLockAccess(operations, currentNumberOfRetries + 1);\n  }), LOCK_RETRY_DELAY);\n}\nfunction next() {\n  ongoingOperations = undefined;\n  var nextOperations = bufferedOperations.shift();\n  if (nextOperations) {\n    withCookieLockAccess(nextOperations);\n  }\n}\nexport function persistSession(session, options) {\n  if (isExpiredState(session)) {\n    clearSession(options);\n    return;\n  }\n  session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY);\n  setSession(session, options);\n}\nfunction setSession(session, options) {\n  setCookie(SESSION_COOKIE_NAME, toSessionString(session), SESSION_EXPIRATION_DELAY, options);\n}\nexport function toSessionString(session) {\n  return utils.objectEntries(session).map(function (_a) {\n    var key = _a[0],\n      value = _a[1];\n    return \"\".concat(key, \"=\").concat(value);\n  }).join(SESSION_ENTRY_SEPARATOR);\n}\nexport function retrieveSession() {\n  var sessionString = getCookie(SESSION_COOKIE_NAME);\n  var session = {};\n  if (isValidSessionString(sessionString)) {\n    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach(function (entry) {\n      var matches = SESSION_ENTRY_REGEXP.exec(entry);\n      if (matches !== null) {\n        var key = matches[1],\n          value = matches[2];\n        session[key] = value;\n      }\n    });\n  }\n  return session;\n}\nfunction isValidSessionString(sessionString) {\n  return sessionString !== undefined && (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString));\n}\nfunction isExpiredState(session) {\n  return utils.isEmptyObject(session);\n}\nfunction clearSession(options) {\n  setCookie(SESSION_COOKIE_NAME, '', 0, options);\n}","map":{"version":3,"names":["getCookie","setCookie","isChromium","monitor","dateNow","utils","SESSION_EXPIRATION_DELAY","SESSION_ENTRY_REGEXP","SESSION_ENTRY_SEPARATOR","SESSION_COOKIE_NAME","LOCK_RETRY_DELAY","MAX_NUMBER_OF_LOCK_RETRIES","bufferedOperations","ongoingOperations","withCookieLockAccess","operations","numberOfRetries","push","next","currentLock","currentSession","retrieveSession","isCookieLockEnabled","lock","retryLater","generateUUID","setSession","options","processedSession","process","persistSession","isExpiredState","_a","after","call","currentNumberOfRetries","setTimeout","undefined","nextOperations","shift","session","clearSession","expire","String","toSessionString","objectEntries","map","key","value","concat","join","sessionString","isValidSessionString","split","forEach","entry","matches","exec","indexOf","test","isEmptyObject"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/apm-enablement-sessions/rum_and_trace_correlation/rum_app/node_modules/@datadog/browser-core/src/domain/session/sessionCookieStore.ts"],"sourcesContent":["import type { CookieOptions } from '../../browser/cookie'\nimport { getCookie, setCookie } from '../../browser/cookie'\nimport { isChromium } from '../../tools/browserDetection'\nimport { monitor } from '../../tools/monitor'\nimport { dateNow } from '../../tools/timeUtils'\nimport * as utils from '../../tools/utils'\nimport { SESSION_EXPIRATION_DELAY } from './sessionConstants'\nimport type { SessionState } from './sessionStore'\n\nconst SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/\nconst SESSION_ENTRY_SEPARATOR = '&'\n\nexport const SESSION_COOKIE_NAME = '_dd_s'\n\n// arbitrary values\nexport const LOCK_RETRY_DELAY = 10\nexport const MAX_NUMBER_OF_LOCK_RETRIES = 100\n\ntype Operations = {\n  options: CookieOptions\n  process: (cookieSession: SessionState) => SessionState | undefined\n  after?: (cookieSession: SessionState) => void\n}\n\nconst bufferedOperations: Operations[] = []\nlet ongoingOperations: Operations | undefined\n\nexport function withCookieLockAccess(operations: Operations, numberOfRetries = 0) {\n  if (!ongoingOperations) {\n    ongoingOperations = operations\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations)\n    return\n  }\n  if (numberOfRetries >= MAX_NUMBER_OF_LOCK_RETRIES) {\n    next()\n    return\n  }\n  let currentLock: string\n  let currentSession = retrieveSession()\n  if (isCookieLockEnabled()) {\n    // if someone has lock, retry later\n    if (currentSession.lock) {\n      retryLater(operations, numberOfRetries)\n      return\n    }\n    // acquire lock\n    currentLock = utils.generateUUID()\n    currentSession.lock = currentLock\n    setSession(currentSession, operations.options)\n    // if lock is not acquired, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock) {\n      retryLater(operations, numberOfRetries)\n      return\n    }\n  }\n  let processedSession = operations.process(currentSession)\n  if (isCookieLockEnabled()) {\n    // if lock corrupted after process, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock!) {\n      retryLater(operations, numberOfRetries)\n      return\n    }\n  }\n  if (processedSession) {\n    persistSession(processedSession, operations.options)\n  }\n  if (isCookieLockEnabled()) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentSession = retrieveSession()\n      if (currentSession.lock !== currentLock!) {\n        retryLater(operations, numberOfRetries)\n        return\n      }\n      delete currentSession.lock\n      setSession(currentSession, operations.options)\n      processedSession = currentSession\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date cookie value, the value could have been modified by another tab\n  operations.after?.(processedSession || currentSession)\n  next()\n}\n\n/**\n * Cookie lock strategy allows mitigating issues due to concurrent access to cookie.\n * This issue concerns only chromium browsers and enabling this on firefox increase cookie write failures.\n */\nfunction isCookieLockEnabled() {\n  return isChromium()\n}\n\nfunction retryLater(operations: Operations, currentNumberOfRetries: number) {\n  setTimeout(\n    monitor(() => {\n      withCookieLockAccess(operations, currentNumberOfRetries + 1)\n    }),\n    LOCK_RETRY_DELAY\n  )\n}\n\nfunction next() {\n  ongoingOperations = undefined\n  const nextOperations = bufferedOperations.shift()\n  if (nextOperations) {\n    withCookieLockAccess(nextOperations)\n  }\n}\n\nexport function persistSession(session: SessionState, options: CookieOptions) {\n  if (isExpiredState(session)) {\n    clearSession(options)\n    return\n  }\n  session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY)\n  setSession(session, options)\n}\n\nfunction setSession(session: SessionState, options: CookieOptions) {\n  setCookie(SESSION_COOKIE_NAME, toSessionString(session), SESSION_EXPIRATION_DELAY, options)\n}\n\nexport function toSessionString(session: SessionState) {\n  return utils\n    .objectEntries(session)\n    .map(([key, value]) => `${key}=${value as string}`)\n    .join(SESSION_ENTRY_SEPARATOR)\n}\n\nexport function retrieveSession(): SessionState {\n  const sessionString = getCookie(SESSION_COOKIE_NAME)\n  const session: SessionState = {}\n  if (isValidSessionString(sessionString)) {\n    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach((entry) => {\n      const matches = SESSION_ENTRY_REGEXP.exec(entry)\n      if (matches !== null) {\n        const [, key, value] = matches\n        session[key] = value\n      }\n    })\n  }\n  return session\n}\n\nfunction isValidSessionString(sessionString: string | undefined): sessionString is string {\n  return (\n    sessionString !== undefined &&\n    (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString))\n  )\n}\n\nfunction isExpiredState(session: SessionState) {\n  return utils.isEmptyObject(session)\n}\n\nfunction clearSession(options: CookieOptions) {\n  setCookie(SESSION_COOKIE_NAME, '', 0, options)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}