{"ast":null,"code":"import { initFetchObservable, initXhrObservable, readBytesFromStream, elapsed, timeStampNow, tryToClone } from '@datadog/browser-core';\nimport { isAllowedRequestUrl } from './rumEventsCollection/resource/resourceUtils';\nimport { startTracer } from './tracing/tracer';\nvar nextRequestIndex = 1;\nexport function startRequestCollection(lifeCycle, configuration, sessionManager) {\n  var tracer = startTracer(configuration, sessionManager);\n  trackXhr(lifeCycle, configuration, tracer);\n  trackFetch(lifeCycle, configuration, tracer);\n}\nexport function trackXhr(lifeCycle, configuration, tracer) {\n  var subscription = initXhrObservable().subscribe(function (rawContext) {\n    var context = rawContext;\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return;\n    }\n    switch (context.state) {\n      case 'start':\n        tracer.traceXhr(context, context.xhr);\n        context.requestIndex = getNextRequestIndex();\n        lifeCycle.notify(5 /* REQUEST_STARTED */, {\n          requestIndex: context.requestIndex,\n          url: context.url\n        });\n        break;\n      case 'complete':\n        tracer.clearTracingIfNeeded(context);\n        lifeCycle.notify(6 /* REQUEST_COMPLETED */, {\n          duration: context.duration,\n          method: context.method,\n          requestIndex: context.requestIndex,\n          spanId: context.spanId,\n          startClocks: context.startClocks,\n          status: context.status,\n          traceId: context.traceId,\n          traceSampled: context.traceSampled,\n          type: \"xhr\" /* XHR */,\n          url: context.url,\n          xhr: context.xhr\n        });\n        break;\n    }\n  });\n  return {\n    stop: function () {\n      return subscription.unsubscribe();\n    }\n  };\n}\nexport function trackFetch(lifeCycle, configuration, tracer) {\n  var subscription = initFetchObservable().subscribe(function (rawContext) {\n    var context = rawContext;\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return;\n    }\n    switch (context.state) {\n      case 'start':\n        tracer.traceFetch(context);\n        context.requestIndex = getNextRequestIndex();\n        lifeCycle.notify(5 /* REQUEST_STARTED */, {\n          requestIndex: context.requestIndex,\n          url: context.url\n        });\n        break;\n      case 'resolve':\n        waitForResponseToComplete(context, function (duration) {\n          tracer.clearTracingIfNeeded(context);\n          lifeCycle.notify(6 /* REQUEST_COMPLETED */, {\n            duration: duration,\n            method: context.method,\n            requestIndex: context.requestIndex,\n            responseType: context.responseType,\n            spanId: context.spanId,\n            startClocks: context.startClocks,\n            status: context.status,\n            traceId: context.traceId,\n            traceSampled: context.traceSampled,\n            type: \"fetch\" /* FETCH */,\n            url: context.url,\n            response: context.response,\n            init: context.init,\n            input: context.input\n          });\n        });\n        break;\n    }\n  });\n  return {\n    stop: function () {\n      return subscription.unsubscribe();\n    }\n  };\n}\nfunction getNextRequestIndex() {\n  var result = nextRequestIndex;\n  nextRequestIndex += 1;\n  return result;\n}\nfunction waitForResponseToComplete(context, callback) {\n  var clonedResponse = context.response && tryToClone(context.response);\n  if (!clonedResponse || !clonedResponse.body) {\n    // do not try to wait for the response if the clone failed, fetch error or null body\n    callback(elapsed(context.startClocks.timeStamp, timeStampNow()));\n  } else {\n    readBytesFromStream(clonedResponse.body, function () {\n      callback(elapsed(context.startClocks.timeStamp, timeStampNow()));\n    }, {\n      bytesLimit: Number.POSITIVE_INFINITY,\n      collectStreamBody: false\n    });\n  }\n}","map":{"version":3,"names":["initFetchObservable","initXhrObservable","readBytesFromStream","elapsed","timeStampNow","tryToClone","isAllowedRequestUrl","startTracer","nextRequestIndex","startRequestCollection","lifeCycle","configuration","sessionManager","tracer","trackXhr","trackFetch","subscription","subscribe","rawContext","context","url","state","traceXhr","xhr","requestIndex","getNextRequestIndex","notify","clearTracingIfNeeded","duration","method","spanId","startClocks","status","traceId","traceSampled","type","stop","unsubscribe","traceFetch","waitForResponseToComplete","responseType","response","init","input","result","callback","clonedResponse","body","timeStamp","bytesLimit","Number","POSITIVE_INFINITY","collectStreamBody"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/apm-enablement-sessions/rum_and_trace_correlation/react-app/node_modules/@datadog/browser-rum-core/src/domain/requestCollection.ts"],"sourcesContent":["import type {\n  Duration,\n  XhrCompleteContext,\n  XhrStartContext,\n  ClocksState,\n  FetchStartContext,\n  FetchResolveContext,\n} from '@datadog/browser-core'\nimport {\n  RequestType,\n  initFetchObservable,\n  initXhrObservable,\n  readBytesFromStream,\n  elapsed,\n  timeStampNow,\n  tryToClone,\n} from '@datadog/browser-core'\nimport type { RumSessionManager } from '..'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport { isAllowedRequestUrl } from './rumEventsCollection/resource/resourceUtils'\nimport type { TraceIdentifier, Tracer } from './tracing/tracer'\nimport { startTracer } from './tracing/tracer'\n\nexport interface CustomContext {\n  requestIndex: number\n  spanId?: TraceIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n}\nexport interface RumFetchStartContext extends FetchStartContext, CustomContext {}\nexport interface RumFetchResolveContext extends FetchResolveContext, CustomContext {}\nexport interface RumXhrStartContext extends XhrStartContext, CustomContext {}\nexport interface RumXhrCompleteContext extends XhrCompleteContext, CustomContext {}\n\nexport interface RequestStartEvent {\n  requestIndex: number\n  url: string\n}\nexport interface RequestCompleteEvent {\n  requestIndex: number\n  type: RequestType\n  method: string\n  url: string\n  status: number\n  responseType?: string\n  startClocks: ClocksState\n  duration: Duration\n  spanId?: TraceIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n  xhr?: XMLHttpRequest\n  response?: Response\n  input?: RequestInfo\n  init?: RequestInit\n  error?: Error\n}\n\nlet nextRequestIndex = 1\n\nexport function startRequestCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager\n) {\n  const tracer = startTracer(configuration, sessionManager)\n  trackXhr(lifeCycle, configuration, tracer)\n  trackFetch(lifeCycle, configuration, tracer)\n}\n\nexport function trackXhr(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initXhrObservable().subscribe((rawContext) => {\n    const context = rawContext as RumXhrStartContext | RumXhrCompleteContext\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceXhr(context, context.xhr)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'complete':\n        tracer.clearTracingIfNeeded(context)\n        lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n          duration: context.duration,\n          method: context.method,\n          requestIndex: context.requestIndex,\n          spanId: context.spanId,\n          startClocks: context.startClocks,\n          status: context.status,\n          traceId: context.traceId,\n          traceSampled: context.traceSampled,\n          type: RequestType.XHR,\n          url: context.url,\n          xhr: context.xhr,\n        })\n        break\n    }\n  })\n\n  return { stop: () => subscription.unsubscribe() }\n}\n\nexport function trackFetch(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initFetchObservable().subscribe((rawContext) => {\n    const context = rawContext as RumFetchResolveContext | RumFetchStartContext\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceFetch(context)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'resolve':\n        waitForResponseToComplete(context, (duration: Duration) => {\n          tracer.clearTracingIfNeeded(context)\n          lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n            duration,\n            method: context.method,\n            requestIndex: context.requestIndex,\n            responseType: context.responseType,\n            spanId: context.spanId,\n            startClocks: context.startClocks,\n            status: context.status,\n            traceId: context.traceId,\n            traceSampled: context.traceSampled,\n            type: RequestType.FETCH,\n            url: context.url,\n            response: context.response,\n            init: context.init,\n            input: context.input,\n          })\n        })\n        break\n    }\n  })\n  return { stop: () => subscription.unsubscribe() }\n}\n\nfunction getNextRequestIndex() {\n  const result = nextRequestIndex\n  nextRequestIndex += 1\n  return result\n}\n\nfunction waitForResponseToComplete(context: RumFetchResolveContext, callback: (duration: Duration) => void) {\n  const clonedResponse = context.response && tryToClone(context.response)\n  if (!clonedResponse || !clonedResponse.body) {\n    // do not try to wait for the response if the clone failed, fetch error or null body\n    callback(elapsed(context.startClocks.timeStamp, timeStampNow()))\n  } else {\n    readBytesFromStream(\n      clonedResponse.body,\n      () => {\n        callback(elapsed(context.startClocks.timeStamp, timeStampNow()))\n      },\n      {\n        bytesLimit: Number.POSITIVE_INFINITY,\n        collectStreamBody: false,\n      }\n    )\n  }\n}\n"],"mappings":"AAQA,SAEEA,mBAAmB,EACnBC,iBAAiB,EACjBC,mBAAmB,EACnBC,OAAO,EACPC,YAAY,EACZC,UAAU,QACL,uBAAuB;AAK9B,SAASC,mBAAmB,QAAQ,8CAA8C;AAElF,SAASC,WAAW,QAAQ,kBAAkB;AAoC9C,IAAIC,gBAAgB,GAAG,CAAC;AAExB,OAAM,SAAUC,sBAAsBA,CACpCC,SAAoB,EACpBC,aAA+B,EAC/BC,cAAiC;EAEjC,IAAMC,MAAM,GAAGN,WAAW,CAACI,aAAa,EAAEC,cAAc,CAAC;EACzDE,QAAQ,CAACJ,SAAS,EAAEC,aAAa,EAAEE,MAAM,CAAC;EAC1CE,UAAU,CAACL,SAAS,EAAEC,aAAa,EAAEE,MAAM,CAAC;AAC9C;AAEA,OAAM,SAAUC,QAAQA,CAACJ,SAAoB,EAAEC,aAA+B,EAAEE,MAAc;EAC5F,IAAMG,YAAY,GAAGf,iBAAiB,EAAE,CAACgB,SAAS,CAAC,UAACC,UAAU;IAC5D,IAAMC,OAAO,GAAGD,UAAwD;IACxE,IAAI,CAACZ,mBAAmB,CAACK,aAAa,EAAEQ,OAAO,CAACC,GAAG,CAAC,EAAE;MACpD;;IAGF,QAAQD,OAAO,CAACE,KAAK;MACnB,KAAK,OAAO;QACVR,MAAM,CAACS,QAAQ,CAACH,OAAO,EAAEA,OAAO,CAACI,GAAG,CAAC;QACrCJ,OAAO,CAACK,YAAY,GAAGC,mBAAmB,EAAE;QAE5Cf,SAAS,CAACgB,MAAM,0BAAqC;UACnDF,YAAY,EAAEL,OAAO,CAACK,YAAY;UAClCJ,GAAG,EAAED,OAAO,CAACC;SACd,CAAC;QACF;MACF,KAAK,UAAU;QACbP,MAAM,CAACc,oBAAoB,CAACR,OAAO,CAAC;QACpCT,SAAS,CAACgB,MAAM,4BAAuC;UACrDE,QAAQ,EAAET,OAAO,CAACS,QAAQ;UAC1BC,MAAM,EAAEV,OAAO,CAACU,MAAM;UACtBL,YAAY,EAAEL,OAAO,CAACK,YAAY;UAClCM,MAAM,EAAEX,OAAO,CAACW,MAAM;UACtBC,WAAW,EAAEZ,OAAO,CAACY,WAAW;UAChCC,MAAM,EAAEb,OAAO,CAACa,MAAM;UACtBC,OAAO,EAAEd,OAAO,CAACc,OAAO;UACxBC,YAAY,EAAEf,OAAO,CAACe,YAAY;UAClCC,IAAI;UACJf,GAAG,EAAED,OAAO,CAACC,GAAG;UAChBG,GAAG,EAAEJ,OAAO,CAACI;SACd,CAAC;QACF;IAAK;EAEX,CAAC,CAAC;EAEF,OAAO;IAAEa,IAAI,EAAE,SAAAA,CAAA;MAAM,OAAApB,YAAY,CAACqB,WAAW,EAAE;IAA1B;EAA0B,CAAE;AACnD;AAEA,OAAM,SAAUtB,UAAUA,CAACL,SAAoB,EAAEC,aAA+B,EAAEE,MAAc;EAC9F,IAAMG,YAAY,GAAGhB,mBAAmB,EAAE,CAACiB,SAAS,CAAC,UAACC,UAAU;IAC9D,IAAMC,OAAO,GAAGD,UAA2D;IAC3E,IAAI,CAACZ,mBAAmB,CAACK,aAAa,EAAEQ,OAAO,CAACC,GAAG,CAAC,EAAE;MACpD;;IAGF,QAAQD,OAAO,CAACE,KAAK;MACnB,KAAK,OAAO;QACVR,MAAM,CAACyB,UAAU,CAACnB,OAAO,CAAC;QAC1BA,OAAO,CAACK,YAAY,GAAGC,mBAAmB,EAAE;QAE5Cf,SAAS,CAACgB,MAAM,0BAAqC;UACnDF,YAAY,EAAEL,OAAO,CAACK,YAAY;UAClCJ,GAAG,EAAED,OAAO,CAACC;SACd,CAAC;QACF;MACF,KAAK,SAAS;QACZmB,yBAAyB,CAACpB,OAAO,EAAE,UAACS,QAAkB;UACpDf,MAAM,CAACc,oBAAoB,CAACR,OAAO,CAAC;UACpCT,SAAS,CAACgB,MAAM,4BAAuC;YACrDE,QAAQ,EAAAA,QAAA;YACRC,MAAM,EAAEV,OAAO,CAACU,MAAM;YACtBL,YAAY,EAAEL,OAAO,CAACK,YAAY;YAClCgB,YAAY,EAAErB,OAAO,CAACqB,YAAY;YAClCV,MAAM,EAAEX,OAAO,CAACW,MAAM;YACtBC,WAAW,EAAEZ,OAAO,CAACY,WAAW;YAChCC,MAAM,EAAEb,OAAO,CAACa,MAAM;YACtBC,OAAO,EAAEd,OAAO,CAACc,OAAO;YACxBC,YAAY,EAAEf,OAAO,CAACe,YAAY;YAClCC,IAAI;YACJf,GAAG,EAAED,OAAO,CAACC,GAAG;YAChBqB,QAAQ,EAAEtB,OAAO,CAACsB,QAAQ;YAC1BC,IAAI,EAAEvB,OAAO,CAACuB,IAAI;YAClBC,KAAK,EAAExB,OAAO,CAACwB;WAChB,CAAC;QACJ,CAAC,CAAC;QACF;IAAK;EAEX,CAAC,CAAC;EACF,OAAO;IAAEP,IAAI,EAAE,SAAAA,CAAA;MAAM,OAAApB,YAAY,CAACqB,WAAW,EAAE;IAA1B;EAA0B,CAAE;AACnD;AAEA,SAASZ,mBAAmBA,CAAA;EAC1B,IAAMmB,MAAM,GAAGpC,gBAAgB;EAC/BA,gBAAgB,IAAI,CAAC;EACrB,OAAOoC,MAAM;AACf;AAEA,SAASL,yBAAyBA,CAACpB,OAA+B,EAAE0B,QAAsC;EACxG,IAAMC,cAAc,GAAG3B,OAAO,CAACsB,QAAQ,IAAIpC,UAAU,CAACc,OAAO,CAACsB,QAAQ,CAAC;EACvE,IAAI,CAACK,cAAc,IAAI,CAACA,cAAc,CAACC,IAAI,EAAE;IAC3C;IACAF,QAAQ,CAAC1C,OAAO,CAACgB,OAAO,CAACY,WAAW,CAACiB,SAAS,EAAE5C,YAAY,EAAE,CAAC,CAAC;GACjE,MAAM;IACLF,mBAAmB,CACjB4C,cAAc,CAACC,IAAI,EACnB;MACEF,QAAQ,CAAC1C,OAAO,CAACgB,OAAO,CAACY,WAAW,CAACiB,SAAS,EAAE5C,YAAY,EAAE,CAAC,CAAC;IAClE,CAAC,EACD;MACE6C,UAAU,EAAEC,MAAM,CAACC,iBAAiB;MACpCC,iBAAiB,EAAE;KACpB,CACF;;AAEL"},"metadata":{},"sourceType":"module","externalDependencies":[]}