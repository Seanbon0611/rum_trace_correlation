{"ast":null,"code":"import { instrumentMethodAndCallOriginal, matchList, monitor, Observable, timeStampNow } from '@datadog/browser-core';\n// Delay to wait for a page activity to validate the tracking process\nexport var PAGE_ACTIVITY_VALIDATION_DELAY = 100;\n// Delay to wait after a page activity to end the tracking process\nexport var PAGE_ACTIVITY_END_DELAY = 100;\n/**\n * Wait for the page activity end\n *\n * Detection lifecycle:\n * ```\n *                        Wait page activity end\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, pageActivityEndCallback, maxDuration) {\n  var pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, configuration);\n  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration);\n}\nexport function doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration) {\n  var pageActivityEndTimeoutId;\n  var hasCompleted = false;\n  var validationTimeoutId = setTimeout(monitor(function () {\n    return complete({\n      hadActivity: false\n    });\n  }), PAGE_ACTIVITY_VALIDATION_DELAY);\n  var maxDurationTimeoutId = maxDuration && setTimeout(monitor(function () {\n    return complete({\n      hadActivity: true,\n      end: timeStampNow()\n    });\n  }), maxDuration);\n  var pageActivitySubscription = pageActivityObservable.subscribe(function (_a) {\n    var isBusy = _a.isBusy;\n    clearTimeout(validationTimeoutId);\n    clearTimeout(pageActivityEndTimeoutId);\n    var lastChangeTime = timeStampNow();\n    if (!isBusy) {\n      pageActivityEndTimeoutId = setTimeout(monitor(function () {\n        return complete({\n          hadActivity: true,\n          end: lastChangeTime\n        });\n      }), PAGE_ACTIVITY_END_DELAY);\n    }\n  });\n  var stop = function () {\n    hasCompleted = true;\n    clearTimeout(validationTimeoutId);\n    clearTimeout(pageActivityEndTimeoutId);\n    clearTimeout(maxDurationTimeoutId);\n    pageActivitySubscription.unsubscribe();\n  };\n  function complete(event) {\n    if (hasCompleted) {\n      return;\n    }\n    stop();\n    pageActivityEndCallback(event);\n  }\n  return {\n    stop: stop\n  };\n}\nexport function createPageActivityObservable(lifeCycle, domMutationObservable, configuration) {\n  var observable = new Observable(function () {\n    var subscriptions = [];\n    var firstRequestIndex;\n    var pendingRequestsCount = 0;\n    subscriptions.push(domMutationObservable.subscribe(notifyPageActivity), lifeCycle.subscribe(0 /* PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {\n      if (entries.some(function (entry) {\n        return entry.entryType === 'resource' && !isExcludedUrl(configuration, entry.name);\n      })) {\n        notifyPageActivity();\n      }\n    }), lifeCycle.subscribe(5 /* REQUEST_STARTED */, function (startEvent) {\n      if (isExcludedUrl(configuration, startEvent.url)) {\n        return;\n      }\n      if (firstRequestIndex === undefined) {\n        firstRequestIndex = startEvent.requestIndex;\n      }\n      pendingRequestsCount += 1;\n      notifyPageActivity();\n    }), lifeCycle.subscribe(6 /* REQUEST_COMPLETED */, function (request) {\n      if (isExcludedUrl(configuration, request.url) || firstRequestIndex === undefined ||\n      // If the request started before the tracking start, ignore it\n      request.requestIndex < firstRequestIndex) {\n        return;\n      }\n      pendingRequestsCount -= 1;\n      notifyPageActivity();\n    }));\n    var stopTrackingWindowOpen = trackWindowOpen(notifyPageActivity).stop;\n    return function () {\n      stopTrackingWindowOpen();\n      subscriptions.forEach(function (s) {\n        return s.unsubscribe();\n      });\n    };\n    function notifyPageActivity() {\n      observable.notify({\n        isBusy: pendingRequestsCount > 0\n      });\n    }\n  });\n  return observable;\n}\nfunction isExcludedUrl(configuration, requestUrl) {\n  return matchList(configuration.excludedActivityUrls, requestUrl);\n}\nfunction trackWindowOpen(callback) {\n  return instrumentMethodAndCallOriginal(window, 'open', {\n    before: callback\n  });\n}","map":{"version":3,"names":["instrumentMethodAndCallOriginal","matchList","monitor","Observable","timeStampNow","PAGE_ACTIVITY_VALIDATION_DELAY","PAGE_ACTIVITY_END_DELAY","waitPageActivityEnd","lifeCycle","domMutationObservable","configuration","pageActivityEndCallback","maxDuration","pageActivityObservable","createPageActivityObservable","doWaitPageActivityEnd","pageActivityEndTimeoutId","hasCompleted","validationTimeoutId","setTimeout","complete","hadActivity","maxDurationTimeoutId","end","pageActivitySubscription","subscribe","_a","isBusy","clearTimeout","lastChangeTime","stop","unsubscribe","event","observable","subscriptions","firstRequestIndex","pendingRequestsCount","push","notifyPageActivity","entries","some","entry","entryType","isExcludedUrl","name","startEvent","url","undefined","requestIndex","request","stopTrackingWindowOpen","trackWindowOpen","forEach","s","notify","requestUrl","excludedActivityUrls","callback","window","before"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/apm-enablement-sessions/rum_and_trace_correlation/react-app/node_modules/@datadog/browser-rum-core/src/domain/waitPageActivityEnd.ts"],"sourcesContent":["import type { Subscription, TimeoutId, TimeStamp } from '@datadog/browser-core'\nimport { instrumentMethodAndCallOriginal, matchList, monitor, Observable, timeStampNow } from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\n// Delay to wait for a page activity to validate the tracking process\nexport const PAGE_ACTIVITY_VALIDATION_DELAY = 100\n// Delay to wait after a page activity to end the tracking process\nexport const PAGE_ACTIVITY_END_DELAY = 100\n\nexport interface PageActivityEvent {\n  isBusy: boolean\n}\n\nexport type PageActivityEndEvent = { hadActivity: true; end: TimeStamp } | { hadActivity: false }\n\n/**\n * Wait for the page activity end\n *\n * Detection lifecycle:\n * ```\n *                        Wait page activity end\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitPageActivityEnd(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  const pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, configuration)\n  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration)\n}\n\nexport function doWaitPageActivityEnd(\n  pageActivityObservable: Observable<PageActivityEvent>,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  let pageActivityEndTimeoutId: TimeoutId\n  let hasCompleted = false\n\n  const validationTimeoutId = setTimeout(\n    monitor(() => complete({ hadActivity: false })),\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n  const maxDurationTimeoutId =\n    maxDuration &&\n    setTimeout(\n      monitor(() => complete({ hadActivity: true, end: timeStampNow() })),\n      maxDuration\n    )\n\n  const pageActivitySubscription = pageActivityObservable.subscribe(({ isBusy }) => {\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    const lastChangeTime = timeStampNow()\n    if (!isBusy) {\n      pageActivityEndTimeoutId = setTimeout(\n        monitor(() => complete({ hadActivity: true, end: lastChangeTime })),\n        PAGE_ACTIVITY_END_DELAY\n      )\n    }\n  })\n\n  const stop = () => {\n    hasCompleted = true\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    clearTimeout(maxDurationTimeoutId)\n    pageActivitySubscription.unsubscribe()\n  }\n\n  function complete(event: PageActivityEndEvent) {\n    if (hasCompleted) {\n      return\n    }\n    stop()\n    pageActivityEndCallback(event)\n  }\n  return { stop }\n}\n\nexport function createPageActivityObservable(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n): Observable<PageActivityEvent> {\n  const observable = new Observable<PageActivityEvent>(() => {\n    const subscriptions: Subscription[] = []\n    let firstRequestIndex: undefined | number\n    let pendingRequestsCount = 0\n\n    subscriptions.push(\n      domMutationObservable.subscribe(notifyPageActivity),\n      lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n        if (entries.some((entry) => entry.entryType === 'resource' && !isExcludedUrl(configuration, entry.name))) {\n          notifyPageActivity()\n        }\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_STARTED, (startEvent) => {\n        if (isExcludedUrl(configuration, startEvent.url)) {\n          return\n        }\n        if (firstRequestIndex === undefined) {\n          firstRequestIndex = startEvent.requestIndex\n        }\n        pendingRequestsCount += 1\n        notifyPageActivity()\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request) => {\n        if (\n          isExcludedUrl(configuration, request.url) ||\n          firstRequestIndex === undefined ||\n          // If the request started before the tracking start, ignore it\n          request.requestIndex < firstRequestIndex\n        ) {\n          return\n        }\n        pendingRequestsCount -= 1\n        notifyPageActivity()\n      })\n    )\n\n    const { stop: stopTrackingWindowOpen } = trackWindowOpen(notifyPageActivity)\n\n    return () => {\n      stopTrackingWindowOpen()\n      subscriptions.forEach((s) => s.unsubscribe())\n    }\n\n    function notifyPageActivity() {\n      observable.notify({ isBusy: pendingRequestsCount > 0 })\n    }\n  })\n\n  return observable\n}\n\nfunction isExcludedUrl(configuration: RumConfiguration, requestUrl: string): boolean {\n  return matchList(configuration.excludedActivityUrls, requestUrl)\n}\n\nfunction trackWindowOpen(callback: () => void) {\n  return instrumentMethodAndCallOriginal(window, 'open', { before: callback })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}