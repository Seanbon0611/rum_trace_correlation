{"ast":null,"code":"import { includes, timeStampNow, isExperimentalFeatureEnabled, Observable, assign, getRelativeTime, ONE_MINUTE, ContextHistory, generateUUID, clocksNow, ONE_SECOND, elapsed } from '@datadog/browser-core';\nimport { trackEventCounts } from '../../trackEventCounts';\nimport { PAGE_ACTIVITY_VALIDATION_DELAY, waitPageActivityEnd } from '../../waitPageActivityEnd';\nimport { createClickChain } from './clickChain';\nimport { getActionNameFromElement } from './getActionNameFromElement';\nimport { getSelectorFromElement } from './getSelectorFromElement';\nimport { listenActionEvents } from './listenActionEvents';\nimport { computeFrustration } from './computeFrustration';\n// Maximum duration for click actions\nexport var CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND;\nexport var ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE; // arbitrary\nexport function trackClickActions(lifeCycle, domMutationObservable, configuration) {\n  var history = new ContextHistory(ACTION_CONTEXT_TIME_OUT_DELAY);\n  var stopObservable = new Observable();\n  var currentClickChain;\n  lifeCycle.subscribe(8 /* SESSION_RENEWED */, function () {\n    history.reset();\n  });\n  lifeCycle.subscribe(4 /* VIEW_ENDED */, stopClickChain);\n  var stopActionEventsListener = listenActionEvents({\n    onPointerDown: function (pointerDownEvent) {\n      return processPointerDown(configuration, lifeCycle, domMutationObservable, history, pointerDownEvent);\n    },\n    onPointerUp: function (_a, startEvent, getUserActivity) {\n      var clickActionBase = _a.clickActionBase,\n        hadActivityOnPointerDown = _a.hadActivityOnPointerDown;\n      return startClickAction(configuration, lifeCycle, domMutationObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown);\n    }\n  }).stop;\n  var actionContexts = {\n    findActionId: function (startTime) {\n      return configuration.trackFrustrations ? history.findAll(startTime) : history.find(startTime);\n    }\n  };\n  return {\n    stop: function () {\n      stopClickChain();\n      stopObservable.notify();\n      stopActionEventsListener();\n    },\n    actionContexts: actionContexts\n  };\n  function appendClickToClickChain(click) {\n    if (!currentClickChain || !currentClickChain.tryAppend(click)) {\n      var rageClick_1 = click.clone();\n      currentClickChain = createClickChain(click, function (clicks) {\n        finalizeClicks(clicks, rageClick_1);\n      });\n    }\n  }\n  function stopClickChain() {\n    if (currentClickChain) {\n      currentClickChain.stop();\n    }\n  }\n}\nfunction processPointerDown(configuration, lifeCycle, domMutationObservable, history, pointerDownEvent) {\n  if (!configuration.trackFrustrations && history.find()) {\n    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any new\n    // action if another one is already occurring.\n    return;\n  }\n  var clickActionBase = computeClickActionBase(pointerDownEvent, configuration.actionNameAttribute);\n  if (!configuration.trackFrustrations && !clickActionBase.name) {\n    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any action\n    // with a blank name\n    return;\n  }\n  var hadActivityOnPointerDown = false;\n  waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, function (pageActivityEndEvent) {\n    hadActivityOnPointerDown = pageActivityEndEvent.hadActivity;\n  },\n  // We don't care about the activity duration, we just want to know whether an activity did happen\n  // within the \"validation delay\" or not. Limit the duration so the callback is called sooner.\n  PAGE_ACTIVITY_VALIDATION_DELAY);\n  return {\n    clickActionBase: clickActionBase,\n    hadActivityOnPointerDown: function () {\n      return hadActivityOnPointerDown;\n    }\n  };\n}\nfunction startClickAction(configuration, lifeCycle, domMutationObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown) {\n  var click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent);\n  if (configuration.trackFrustrations) {\n    appendClickToClickChain(click);\n  }\n  var stopWaitPageActivityEnd = waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, function (pageActivityEndEvent) {\n    if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {\n      // If the clock is looking weird, just discard the click\n      click.discard();\n    } else {\n      if (pageActivityEndEvent.hadActivity) {\n        click.stop(pageActivityEndEvent.end);\n      } else if (hadActivityOnPointerDown()) {\n        click.stop(\n        // using the click start as activity end, so the click will have some activity but its\n        // duration will be 0 (as the activity started before the click start)\n        click.startClocks.timeStamp);\n      } else {\n        click.stop();\n      }\n      // Validate or discard the click only if we don't track frustrations. It'll be done when\n      // the click chain is finalized.\n      if (!configuration.trackFrustrations) {\n        if (!pageActivityEndEvent.hadActivity) {\n          // If we are not tracking frustrations, we should discard the click to keep backward\n          // compatibility.\n          click.discard();\n        } else {\n          click.validate();\n        }\n      }\n    }\n  }, CLICK_ACTION_MAX_DURATION).stop;\n  var viewEndedSubscription = lifeCycle.subscribe(4 /* VIEW_ENDED */, function (_a) {\n    var endClocks = _a.endClocks;\n    click.stop(endClocks.timeStamp);\n  });\n  var stopSubscription = stopObservable.subscribe(function () {\n    click.stop();\n  });\n  click.stopObservable.subscribe(function () {\n    viewEndedSubscription.unsubscribe();\n    stopWaitPageActivityEnd();\n    stopSubscription.unsubscribe();\n  });\n}\nfunction computeClickActionBase(event, actionNameAttribute) {\n  var target;\n  var position;\n  if (isExperimentalFeatureEnabled('clickmap')) {\n    var rect = event.target.getBoundingClientRect();\n    target = {\n      width: Math.round(rect.width),\n      height: Math.round(rect.height),\n      selector: getSelectorFromElement(event.target, actionNameAttribute)\n    };\n    position = {\n      // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element\n      x: Math.round(event.clientX - rect.left),\n      y: Math.round(event.clientY - rect.top)\n    };\n  }\n  return {\n    type: \"click\" /* CLICK */,\n    target: target,\n    position: position,\n    name: getActionNameFromElement(event.target, actionNameAttribute)\n  };\n}\nfunction newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent) {\n  var id = generateUUID();\n  var startClocks = clocksNow();\n  var historyEntry = history.add(id, startClocks.relative);\n  var eventCountsSubscription = trackEventCounts({\n    lifeCycle: lifeCycle,\n    isChildEvent: function (event) {\n      return event.action !== undefined && (Array.isArray(event.action.id) ? includes(event.action.id, id) : event.action.id === id);\n    }\n  });\n  var status = 0 /* ONGOING */;\n  var activityEndTime;\n  var frustrationTypes = [];\n  var stopObservable = new Observable();\n  function stop(newActivityEndTime) {\n    if (status !== 0 /* ONGOING */) {\n      return;\n    }\n    activityEndTime = newActivityEndTime;\n    status = 1 /* STOPPED */;\n    if (activityEndTime) {\n      historyEntry.close(getRelativeTime(activityEndTime));\n    } else {\n      historyEntry.remove();\n    }\n    eventCountsSubscription.stop();\n    stopObservable.notify();\n  }\n  return {\n    event: startEvent,\n    stop: stop,\n    stopObservable: stopObservable,\n    get hasError() {\n      return eventCountsSubscription.eventCounts.errorCount > 0;\n    },\n    get hasPageActivity() {\n      return activityEndTime !== undefined;\n    },\n    getUserActivity: getUserActivity,\n    addFrustration: function (frustrationType) {\n      frustrationTypes.push(frustrationType);\n    },\n    startClocks: startClocks,\n    isStopped: function () {\n      return status === 1 /* STOPPED */ || status === 2 /* FINALIZED */;\n    },\n    clone: function () {\n      return newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent);\n    },\n    validate: function (domEvents) {\n      stop();\n      if (status !== 1 /* STOPPED */) {\n        return;\n      }\n      var _a = eventCountsSubscription.eventCounts,\n        resourceCount = _a.resourceCount,\n        errorCount = _a.errorCount,\n        longTaskCount = _a.longTaskCount;\n      var clickAction = assign({\n        type: \"click\" /* CLICK */,\n        duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),\n        startClocks: startClocks,\n        id: id,\n        frustrationTypes: frustrationTypes,\n        counts: {\n          resourceCount: resourceCount,\n          errorCount: errorCount,\n          longTaskCount: longTaskCount\n        },\n        events: domEvents !== null && domEvents !== void 0 ? domEvents : [startEvent],\n        event: startEvent\n      }, clickActionBase);\n      lifeCycle.notify(1 /* AUTO_ACTION_COMPLETED */, clickAction);\n      status = 2 /* FINALIZED */;\n    },\n\n    discard: function () {\n      stop();\n      status = 2 /* FINALIZED */;\n    }\n  };\n}\n\nexport function finalizeClicks(clicks, rageClick) {\n  var isRage = computeFrustration(clicks, rageClick).isRage;\n  if (isRage) {\n    clicks.forEach(function (click) {\n      return click.discard();\n    });\n    rageClick.stop(timeStampNow());\n    rageClick.validate(clicks.map(function (click) {\n      return click.event;\n    }));\n  } else {\n    rageClick.discard();\n    clicks.forEach(function (click) {\n      return click.validate();\n    });\n  }\n}","map":{"version":3,"names":["includes","timeStampNow","isExperimentalFeatureEnabled","Observable","assign","getRelativeTime","ONE_MINUTE","ContextHistory","generateUUID","clocksNow","ONE_SECOND","elapsed","trackEventCounts","PAGE_ACTIVITY_VALIDATION_DELAY","waitPageActivityEnd","createClickChain","getActionNameFromElement","getSelectorFromElement","listenActionEvents","computeFrustration","CLICK_ACTION_MAX_DURATION","ACTION_CONTEXT_TIME_OUT_DELAY","trackClickActions","lifeCycle","domMutationObservable","configuration","history","stopObservable","currentClickChain","subscribe","reset","stopClickChain","stopActionEventsListener","onPointerDown","pointerDownEvent","processPointerDown","onPointerUp","_a","startEvent","getUserActivity","clickActionBase","hadActivityOnPointerDown","startClickAction","appendClickToClickChain","stop","actionContexts","findActionId","startTime","trackFrustrations","findAll","find","notify","click","tryAppend","rageClick_1","clone","clicks","finalizeClicks","computeClickActionBase","actionNameAttribute","name","pageActivityEndEvent","hadActivity","newClick","stopWaitPageActivityEnd","end","startClocks","timeStamp","discard","validate","viewEndedSubscription","endClocks","stopSubscription","unsubscribe","event","target","position","rect","getBoundingClientRect","width","Math","round","height","selector","x","clientX","left","y","clientY","top","type","id","historyEntry","add","relative","eventCountsSubscription","isChildEvent","action","undefined","Array","isArray","status","activityEndTime","frustrationTypes","newActivityEndTime","close","remove","hasError","eventCounts","errorCount","hasPageActivity","addFrustration","frustrationType","push","isStopped","domEvents","resourceCount","longTaskCount","clickAction","duration","counts","events","rageClick","isRage","forEach","map"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/react-app/node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/action/trackClickActions.ts"],"sourcesContent":["import type { Duration, ClocksState, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  includes,\n  timeStampNow,\n  isExperimentalFeatureEnabled,\n  Observable,\n  assign,\n  getRelativeTime,\n  ONE_MINUTE,\n  ContextHistory,\n  generateUUID,\n  clocksNow,\n  ONE_SECOND,\n  elapsed,\n} from '@datadog/browser-core'\nimport type { FrustrationType } from '../../../rawRumEvent.types'\nimport { ActionType } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { trackEventCounts } from '../../trackEventCounts'\nimport { PAGE_ACTIVITY_VALIDATION_DELAY, waitPageActivityEnd } from '../../waitPageActivityEnd'\nimport type { ClickChain } from './clickChain'\nimport { createClickChain } from './clickChain'\nimport { getActionNameFromElement } from './getActionNameFromElement'\nimport { getSelectorFromElement } from './getSelectorFromElement'\nimport type { MouseEventOnElement, UserActivity } from './listenActionEvents'\nimport { listenActionEvents } from './listenActionEvents'\nimport { computeFrustration } from './computeFrustration'\n\ninterface ActionCounts {\n  errorCount: number\n  longTaskCount: number\n  resourceCount: number\n}\n\nexport interface ClickAction {\n  type: ActionType.CLICK\n  id: string\n  name: string\n  target?: {\n    selector: string\n    selector_with_stable_attributes?: string\n    width: number\n    height: number\n  }\n  position?: { x: number; y: number }\n  startClocks: ClocksState\n  duration?: Duration\n  counts: ActionCounts\n  event: MouseEventOnElement\n  frustrationTypes: FrustrationType[]\n  events: Event[]\n}\n\nexport interface ActionContexts {\n  findActionId: (startTime?: RelativeTime) => string | string[] | undefined\n}\n\ntype ClickActionIdHistory = ContextHistory<ClickAction['id']>\n\n// Maximum duration for click actions\nexport const CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND\nexport const ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE // arbitrary\n\nexport function trackClickActions(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n) {\n  const history: ClickActionIdHistory = new ContextHistory(ACTION_CONTEXT_TIME_OUT_DELAY)\n  const stopObservable = new Observable<void>()\n  let currentClickChain: ClickChain | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    history.reset()\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, stopClickChain)\n\n  const { stop: stopActionEventsListener } = listenActionEvents<{\n    clickActionBase: ClickActionBase\n    hadActivityOnPointerDown: () => boolean\n  }>({\n    onPointerDown: (pointerDownEvent) =>\n      processPointerDown(configuration, lifeCycle, domMutationObservable, history, pointerDownEvent),\n    onPointerUp: ({ clickActionBase, hadActivityOnPointerDown }, startEvent, getUserActivity) =>\n      startClickAction(\n        configuration,\n        lifeCycle,\n        domMutationObservable,\n        history,\n        stopObservable,\n        appendClickToClickChain,\n        clickActionBase,\n        startEvent,\n        getUserActivity,\n        hadActivityOnPointerDown\n      ),\n  })\n\n  const actionContexts: ActionContexts = {\n    findActionId: (startTime?: RelativeTime) =>\n      configuration.trackFrustrations ? history.findAll(startTime) : history.find(startTime),\n  }\n\n  return {\n    stop: () => {\n      stopClickChain()\n      stopObservable.notify()\n      stopActionEventsListener()\n    },\n    actionContexts,\n  }\n\n  function appendClickToClickChain(click: Click) {\n    if (!currentClickChain || !currentClickChain.tryAppend(click)) {\n      const rageClick = click.clone()\n      currentClickChain = createClickChain(click, (clicks) => {\n        finalizeClicks(clicks, rageClick)\n      })\n    }\n  }\n\n  function stopClickChain() {\n    if (currentClickChain) {\n      currentClickChain.stop()\n    }\n  }\n}\n\nfunction processPointerDown(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  history: ClickActionIdHistory,\n  pointerDownEvent: MouseEventOnElement\n) {\n  if (!configuration.trackFrustrations && history.find()) {\n    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any new\n    // action if another one is already occurring.\n    return\n  }\n\n  const clickActionBase = computeClickActionBase(pointerDownEvent, configuration.actionNameAttribute)\n  if (!configuration.trackFrustrations && !clickActionBase.name) {\n    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any action\n    // with a blank name\n    return\n  }\n\n  let hadActivityOnPointerDown = false\n\n  waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      hadActivityOnPointerDown = pageActivityEndEvent.hadActivity\n    },\n    // We don't care about the activity duration, we just want to know whether an activity did happen\n    // within the \"validation delay\" or not. Limit the duration so the callback is called sooner.\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n\n  return { clickActionBase, hadActivityOnPointerDown: () => hadActivityOnPointerDown }\n}\n\nfunction startClickAction(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  history: ClickActionIdHistory,\n  stopObservable: Observable<void>,\n  appendClickToClickChain: (click: Click) => void,\n  clickActionBase: ClickActionBase,\n  startEvent: MouseEventOnElement,\n  getUserActivity: () => UserActivity,\n  hadActivityOnPointerDown: () => boolean\n) {\n  const click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent)\n\n  if (configuration.trackFrustrations) {\n    appendClickToClickChain(click)\n  }\n\n  const { stop: stopWaitPageActivityEnd } = waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {\n        // If the clock is looking weird, just discard the click\n        click.discard()\n      } else {\n        if (pageActivityEndEvent.hadActivity) {\n          click.stop(pageActivityEndEvent.end)\n        } else if (hadActivityOnPointerDown()) {\n          click.stop(\n            // using the click start as activity end, so the click will have some activity but its\n            // duration will be 0 (as the activity started before the click start)\n            click.startClocks.timeStamp\n          )\n        } else {\n          click.stop()\n        }\n\n        // Validate or discard the click only if we don't track frustrations. It'll be done when\n        // the click chain is finalized.\n        if (!configuration.trackFrustrations) {\n          if (!pageActivityEndEvent.hadActivity) {\n            // If we are not tracking frustrations, we should discard the click to keep backward\n            // compatibility.\n            click.discard()\n          } else {\n            click.validate()\n          }\n        }\n      }\n    },\n    CLICK_ACTION_MAX_DURATION\n  )\n\n  const viewEndedSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    click.stop(endClocks.timeStamp)\n  })\n\n  const stopSubscription = stopObservable.subscribe(() => {\n    click.stop()\n  })\n\n  click.stopObservable.subscribe(() => {\n    viewEndedSubscription.unsubscribe()\n    stopWaitPageActivityEnd()\n    stopSubscription.unsubscribe()\n  })\n}\n\ntype ClickActionBase = Pick<ClickAction, 'type' | 'name' | 'target' | 'position'>\n\nfunction computeClickActionBase(event: MouseEventOnElement, actionNameAttribute?: string): ClickActionBase {\n  let target: ClickAction['target']\n  let position: ClickAction['position']\n\n  if (isExperimentalFeatureEnabled('clickmap')) {\n    const rect = event.target.getBoundingClientRect()\n    target = {\n      width: Math.round(rect.width),\n      height: Math.round(rect.height),\n      selector: getSelectorFromElement(event.target, actionNameAttribute),\n    }\n    position = {\n      // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element\n      x: Math.round(event.clientX - rect.left),\n      y: Math.round(event.clientY - rect.top),\n    }\n  }\n\n  return {\n    type: ActionType.CLICK,\n    target,\n    position,\n    name: getActionNameFromElement(event.target, actionNameAttribute),\n  }\n}\n\nconst enum ClickStatus {\n  // Initial state, the click is still ongoing.\n  ONGOING,\n  // The click is no more ongoing but still needs to be validated or discarded.\n  STOPPED,\n  // Final state, the click has been stopped and validated or discarded.\n  FINALIZED,\n}\n\nexport type Click = ReturnType<typeof newClick>\n\nfunction newClick(\n  lifeCycle: LifeCycle,\n  history: ClickActionIdHistory,\n  getUserActivity: () => UserActivity,\n  clickActionBase: ClickActionBase,\n  startEvent: MouseEventOnElement\n) {\n  const id = generateUUID()\n  const startClocks = clocksNow()\n  const historyEntry = history.add(id, startClocks.relative)\n  const eventCountsSubscription = trackEventCounts({\n    lifeCycle,\n    isChildEvent: (event) =>\n      event.action !== undefined &&\n      (Array.isArray(event.action.id) ? includes(event.action.id, id) : event.action.id === id),\n  })\n  let status = ClickStatus.ONGOING\n  let activityEndTime: undefined | TimeStamp\n  const frustrationTypes: FrustrationType[] = []\n  const stopObservable = new Observable<void>()\n\n  function stop(newActivityEndTime?: TimeStamp) {\n    if (status !== ClickStatus.ONGOING) {\n      return\n    }\n    activityEndTime = newActivityEndTime\n    status = ClickStatus.STOPPED\n    if (activityEndTime) {\n      historyEntry.close(getRelativeTime(activityEndTime))\n    } else {\n      historyEntry.remove()\n    }\n    eventCountsSubscription.stop()\n    stopObservable.notify()\n  }\n\n  return {\n    event: startEvent,\n    stop,\n    stopObservable,\n\n    get hasError() {\n      return eventCountsSubscription.eventCounts.errorCount > 0\n    },\n    get hasPageActivity() {\n      return activityEndTime !== undefined\n    },\n    getUserActivity,\n    addFrustration: (frustrationType: FrustrationType) => {\n      frustrationTypes.push(frustrationType)\n    },\n    startClocks,\n\n    isStopped: () => status === ClickStatus.STOPPED || status === ClickStatus.FINALIZED,\n\n    clone: () => newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent),\n\n    validate: (domEvents?: Event[]) => {\n      stop()\n      if (status !== ClickStatus.STOPPED) {\n        return\n      }\n\n      const { resourceCount, errorCount, longTaskCount } = eventCountsSubscription.eventCounts\n      const clickAction: ClickAction = assign(\n        {\n          type: ActionType.CLICK as const,\n          duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),\n          startClocks,\n          id,\n          frustrationTypes,\n          counts: {\n            resourceCount,\n            errorCount,\n            longTaskCount,\n          },\n          events: domEvents ?? [startEvent],\n          event: startEvent,\n        },\n        clickActionBase\n      )\n      lifeCycle.notify(LifeCycleEventType.AUTO_ACTION_COMPLETED, clickAction)\n      status = ClickStatus.FINALIZED\n    },\n\n    discard: () => {\n      stop()\n      status = ClickStatus.FINALIZED\n    },\n  }\n}\n\nexport function finalizeClicks(clicks: Click[], rageClick: Click) {\n  const { isRage } = computeFrustration(clicks, rageClick)\n  if (isRage) {\n    clicks.forEach((click) => click.discard())\n    rageClick.stop(timeStampNow())\n    rageClick.validate(clicks.map((click) => click.event))\n  } else {\n    rageClick.discard()\n    clicks.forEach((click) => click.validate())\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}