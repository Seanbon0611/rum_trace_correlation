{"ast":null,"code":"import { relativeNow } from './timeUtils';\nimport { ONE_MINUTE } from './utils';\nvar END_OF_TIMES = Infinity;\nexport var CLEAR_OLD_CONTEXTS_INTERVAL = ONE_MINUTE;\n/**\n * Store and keep track of contexts spans. This whole class assumes that contexts are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nvar ContextHistory = /** @class */function () {\n  function ContextHistory(expireDelay) {\n    var _this = this;\n    this.expireDelay = expireDelay;\n    this.entries = [];\n    this.clearOldContextsInterval = setInterval(function () {\n      return _this.clearOldContexts();\n    }, CLEAR_OLD_CONTEXTS_INTERVAL);\n  }\n  /**\n   * Add a context to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  ContextHistory.prototype.add = function (context, startTime) {\n    var _this = this;\n    var entry = {\n      context: context,\n      startTime: startTime,\n      endTime: END_OF_TIMES,\n      remove: function () {\n        var index = _this.entries.indexOf(entry);\n        if (index >= 0) {\n          _this.entries.splice(index, 1);\n        }\n      },\n      close: function (endTime) {\n        entry.endTime = endTime;\n      }\n    };\n    this.entries.unshift(entry);\n    return entry;\n  };\n  /**\n   * Return the latest context that was active during `startTime`, or the currently active context\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   */\n  ContextHistory.prototype.find = function (startTime) {\n    if (startTime === void 0) {\n      startTime = END_OF_TIMES;\n    }\n    for (var _i = 0, _a = this.entries; _i < _a.length; _i++) {\n      var entry = _a[_i];\n      if (entry.startTime <= startTime) {\n        if (startTime <= entry.endTime) {\n          return entry.context;\n        }\n        break;\n      }\n    }\n  };\n  /**\n   * Helper function to close the currently active context, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  ContextHistory.prototype.closeActive = function (endTime) {\n    var latestEntry = this.entries[0];\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime);\n    }\n  };\n  /**\n   * Return all contexts that were active during `startTime`, or all currently active contexts if no\n   * `startTime` is provided.\n   */\n  ContextHistory.prototype.findAll = function (startTime) {\n    if (startTime === void 0) {\n      startTime = END_OF_TIMES;\n    }\n    return this.entries.filter(function (entry) {\n      return entry.startTime <= startTime && startTime <= entry.endTime;\n    }).map(function (entry) {\n      return entry.context;\n    });\n  };\n  /**\n   * Remove all entries from this collection.\n   */\n  ContextHistory.prototype.reset = function () {\n    this.entries = [];\n  };\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  ContextHistory.prototype.stop = function () {\n    clearInterval(this.clearOldContextsInterval);\n  };\n  ContextHistory.prototype.clearOldContexts = function () {\n    var oldTimeThreshold = relativeNow() - this.expireDelay;\n    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {\n      this.entries.pop();\n    }\n  };\n  return ContextHistory;\n}();\nexport { ContextHistory };","map":{"version":3,"names":["relativeNow","ONE_MINUTE","END_OF_TIMES","Infinity","CLEAR_OLD_CONTEXTS_INTERVAL","ContextHistory","expireDelay","_this","entries","clearOldContextsInterval","setInterval","clearOldContexts","prototype","add","context","startTime","entry","endTime","remove","index","indexOf","splice","close","unshift","find","_i","_a","length","closeActive","latestEntry","findAll","filter","map","reset","stop","clearInterval","oldTimeThreshold","pop"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/react-app/node_modules/@datadog/browser-core/src/tools/contextHistory.ts"],"sourcesContent":["import type { RelativeTime } from './timeUtils'\nimport { relativeNow } from './timeUtils'\nimport type { TimeoutId } from './utils'\nimport { ONE_MINUTE } from './utils'\n\nconst END_OF_TIMES = Infinity as RelativeTime\n\nexport interface ContextHistoryEntry<T> {\n  startTime: RelativeTime\n  endTime: RelativeTime\n  context: T\n  remove(): void\n  close(endTime: RelativeTime): void\n}\n\nexport const CLEAR_OLD_CONTEXTS_INTERVAL = ONE_MINUTE\n\n/**\n * Store and keep track of contexts spans. This whole class assumes that contexts are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nexport class ContextHistory<Context> {\n  private entries: Array<ContextHistoryEntry<Context>> = []\n  private clearOldContextsInterval: TimeoutId\n\n  constructor(private expireDelay: number) {\n    this.clearOldContextsInterval = setInterval(() => this.clearOldContexts(), CLEAR_OLD_CONTEXTS_INTERVAL)\n  }\n\n  /**\n   * Add a context to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  add(context: Context, startTime: RelativeTime): ContextHistoryEntry<Context> {\n    const entry: ContextHistoryEntry<Context> = {\n      context,\n      startTime,\n      endTime: END_OF_TIMES,\n      remove: () => {\n        const index = this.entries.indexOf(entry)\n        if (index >= 0) {\n          this.entries.splice(index, 1)\n        }\n      },\n      close: (endTime: RelativeTime) => {\n        entry.endTime = endTime\n      },\n    }\n    this.entries.unshift(entry)\n    return entry\n  }\n\n  /**\n   * Return the latest context that was active during `startTime`, or the currently active context\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   */\n  find(startTime: RelativeTime = END_OF_TIMES): Context | undefined {\n    for (const entry of this.entries) {\n      if (entry.startTime <= startTime) {\n        if (startTime <= entry.endTime) {\n          return entry.context\n        }\n        break\n      }\n    }\n  }\n\n  /**\n   * Helper function to close the currently active context, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  closeActive(endTime: RelativeTime) {\n    const latestEntry = this.entries[0]\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime)\n    }\n  }\n\n  /**\n   * Return all contexts that were active during `startTime`, or all currently active contexts if no\n   * `startTime` is provided.\n   */\n  findAll(startTime: RelativeTime = END_OF_TIMES): Context[] {\n    return this.entries\n      .filter((entry) => entry.startTime <= startTime && startTime <= entry.endTime)\n      .map((entry) => entry.context)\n  }\n\n  /**\n   * Remove all entries from this collection.\n   */\n  reset() {\n    this.entries = []\n  }\n\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  stop() {\n    clearInterval(this.clearOldContextsInterval)\n  }\n\n  private clearOldContexts() {\n    const oldTimeThreshold = relativeNow() - this.expireDelay\n    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {\n      this.entries.pop()\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}