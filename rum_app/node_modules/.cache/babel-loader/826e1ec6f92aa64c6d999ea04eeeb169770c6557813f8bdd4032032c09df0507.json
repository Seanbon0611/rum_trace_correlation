{"ast":null,"code":"import { monitor } from '../tools/monitor';\nimport { clocksNow } from '../tools/timeUtils';\nimport { ONE_KIBI_BYTE, ONE_MEBI_BYTE, ONE_SECOND, ONE_MINUTE } from '../tools/utils';\nimport { ErrorSource } from '../tools/error';\nexport var MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE;\nexport var MAX_ONGOING_REQUESTS = 32;\nexport var MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE;\nexport var MAX_BACKOFF_TIME = ONE_MINUTE;\nexport var INITIAL_BACKOFF_TIME = ONE_SECOND;\nexport function sendWithRetryStrategy(payload, state, sendStrategy, endpointType, reportError) {\n  if (state.transportStatus === 0 /* UP */ && state.queuedPayloads.size() === 0 && state.bandwidthMonitor.canHandle(payload)) {\n    send(payload, state, sendStrategy, {\n      onSuccess: function () {\n        return retryQueuedPayloads(0 /* AFTER_SUCCESS */, state, sendStrategy, endpointType, reportError);\n      },\n      onFailure: function () {\n        state.queuedPayloads.enqueue(payload);\n        scheduleRetry(state, sendStrategy, endpointType, reportError);\n      }\n    });\n  } else {\n    state.queuedPayloads.enqueue(payload);\n  }\n}\nfunction scheduleRetry(state, sendStrategy, endpointType, reportError) {\n  if (state.transportStatus !== 2 /* DOWN */) {\n    return;\n  }\n  setTimeout(monitor(function () {\n    var payload = state.queuedPayloads.first();\n    send(payload, state, sendStrategy, {\n      onSuccess: function () {\n        state.queuedPayloads.dequeue();\n        state.currentBackoffTime = INITIAL_BACKOFF_TIME;\n        retryQueuedPayloads(1 /* AFTER_RESUME */, state, sendStrategy, endpointType, reportError);\n      },\n      onFailure: function () {\n        state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2);\n        scheduleRetry(state, sendStrategy, endpointType, reportError);\n      }\n    });\n  }), state.currentBackoffTime);\n}\nfunction send(payload, state, sendStrategy, _a) {\n  var onSuccess = _a.onSuccess,\n    onFailure = _a.onFailure;\n  state.bandwidthMonitor.add(payload);\n  sendStrategy(payload, function (response) {\n    state.bandwidthMonitor.remove(payload);\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = 0 /* UP */;\n      onSuccess();\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus = state.bandwidthMonitor.ongoingRequestCount > 0 ? 1 /* FAILURE_DETECTED */ : 2 /* DOWN */;\n      payload.retry = {\n        count: payload.retry ? payload.retry.count + 1 : 1,\n        lastFailureStatus: response.status\n      };\n      onFailure();\n    }\n  });\n}\nfunction retryQueuedPayloads(reason, state, sendStrategy, endpointType, reportError) {\n  if (reason === 0 /* AFTER_SUCCESS */ && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: \"Reached max \".concat(endpointType, \" events size queued for upload: \").concat(MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE, \"MiB\"),\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow()\n    });\n    state.queueFullReported = true;\n  }\n  var previousQueue = state.queuedPayloads;\n  state.queuedPayloads = newPayloadQueue();\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue(), state, sendStrategy, endpointType, reportError);\n  }\n}\nfunction shouldRetryRequest(response) {\n  return response.type !== 'opaque' && (response.status === 0 && !navigator.onLine || response.status === 408 || response.status === 429 || response.status >= 500);\n}\nexport function newRetryState() {\n  return {\n    transportStatus: 0 /* UP */,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false\n  };\n}\nfunction newPayloadQueue() {\n  var queue = [];\n  return {\n    bytesCount: 0,\n    enqueue: function (payload) {\n      if (this.isFull()) {\n        return;\n      }\n      queue.push(payload);\n      this.bytesCount += payload.bytesCount;\n    },\n    first: function () {\n      return queue[0];\n    },\n    dequeue: function () {\n      var payload = queue.shift();\n      if (payload) {\n        this.bytesCount -= payload.bytesCount;\n      }\n      return payload;\n    },\n    size: function () {\n      return queue.length;\n    },\n    isFull: function () {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT;\n    }\n  };\n}\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle: function (payload) {\n      return this.ongoingRequestCount === 0 || this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT && this.ongoingRequestCount < MAX_ONGOING_REQUESTS;\n    },\n    add: function (payload) {\n      this.ongoingRequestCount += 1;\n      this.ongoingByteCount += payload.bytesCount;\n    },\n    remove: function (payload) {\n      this.ongoingRequestCount -= 1;\n      this.ongoingByteCount -= payload.bytesCount;\n    }\n  };\n}","map":{"version":3,"names":["monitor","clocksNow","ONE_KIBI_BYTE","ONE_MEBI_BYTE","ONE_SECOND","ONE_MINUTE","ErrorSource","MAX_ONGOING_BYTES_COUNT","MAX_ONGOING_REQUESTS","MAX_QUEUE_BYTES_COUNT","MAX_BACKOFF_TIME","INITIAL_BACKOFF_TIME","sendWithRetryStrategy","payload","state","sendStrategy","endpointType","reportError","transportStatus","queuedPayloads","size","bandwidthMonitor","canHandle","send","onSuccess","retryQueuedPayloads","onFailure","enqueue","scheduleRetry","setTimeout","first","dequeue","currentBackoffTime","Math","min","_a","add","response","remove","shouldRetryRequest","ongoingRequestCount","retry","count","lastFailureStatus","status","reason","isFull","queueFullReported","message","concat","source","AGENT","startClocks","previousQueue","newPayloadQueue","type","navigator","onLine","newRetryState","newBandwidthMonitor","queue","bytesCount","push","shift","length","ongoingByteCount"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/rum_and_trace_correlation/rum_app/node_modules/@datadog/browser-core/src/transport/sendWithRetryStrategy.ts"],"sourcesContent":["import type { EndpointType } from '../domain/configuration'\nimport { monitor } from '../tools/monitor'\nimport type { RawError } from '../tools/error'\nimport { clocksNow } from '../tools/timeUtils'\nimport { ONE_KIBI_BYTE, ONE_MEBI_BYTE, ONE_SECOND, ONE_MINUTE } from '../tools/utils'\nimport { ErrorSource } from '../tools/error'\nimport type { Payload, HttpResponse } from './httpRequest'\n\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE\nexport const MAX_ONGOING_REQUESTS = 32\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE\nexport const MAX_BACKOFF_TIME = ONE_MINUTE\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND\n\nconst enum TransportStatus {\n  UP,\n  FAILURE_DETECTED,\n  DOWN,\n}\n\nconst enum RetryReason {\n  AFTER_SUCCESS,\n  AFTER_RESUME,\n}\n\nexport interface RetryState {\n  transportStatus: TransportStatus\n  currentBackoffTime: number\n  bandwidthMonitor: ReturnType<typeof newBandwidthMonitor>\n  queuedPayloads: ReturnType<typeof newPayloadQueue>\n  queueFullReported: boolean\n}\n\ntype SendStrategy = (payload: Payload, onResponse: (r: HttpResponse) => void) => void\n\nexport function sendWithRetryStrategy(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (\n    state.transportStatus === TransportStatus.UP &&\n    state.queuedPayloads.size() === 0 &&\n    state.bandwidthMonitor.canHandle(payload)\n  ) {\n    send(payload, state, sendStrategy, {\n      onSuccess: () => retryQueuedPayloads(RetryReason.AFTER_SUCCESS, state, sendStrategy, endpointType, reportError),\n      onFailure: () => {\n        state.queuedPayloads.enqueue(payload)\n        scheduleRetry(state, sendStrategy, endpointType, reportError)\n      },\n    })\n  } else {\n    state.queuedPayloads.enqueue(payload)\n  }\n}\n\nfunction scheduleRetry(\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (state.transportStatus !== TransportStatus.DOWN) {\n    return\n  }\n  setTimeout(\n    monitor(() => {\n      const payload = state.queuedPayloads.first()\n      send(payload, state, sendStrategy, {\n        onSuccess: () => {\n          state.queuedPayloads.dequeue()\n          state.currentBackoffTime = INITIAL_BACKOFF_TIME\n          retryQueuedPayloads(RetryReason.AFTER_RESUME, state, sendStrategy, endpointType, reportError)\n        },\n        onFailure: () => {\n          state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2)\n          scheduleRetry(state, sendStrategy, endpointType, reportError)\n        },\n      })\n    }),\n    state.currentBackoffTime\n  )\n}\n\nfunction send(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  { onSuccess, onFailure }: { onSuccess: () => void; onFailure: () => void }\n) {\n  state.bandwidthMonitor.add(payload)\n  sendStrategy(payload, (response) => {\n    state.bandwidthMonitor.remove(payload)\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = TransportStatus.UP\n      onSuccess()\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus =\n        state.bandwidthMonitor.ongoingRequestCount > 0 ? TransportStatus.FAILURE_DETECTED : TransportStatus.DOWN\n      payload.retry = {\n        count: payload.retry ? payload.retry.count + 1 : 1,\n        lastFailureStatus: response.status,\n      }\n      onFailure()\n    }\n  })\n}\n\nfunction retryQueuedPayloads(\n  reason: RetryReason,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (reason === RetryReason.AFTER_SUCCESS && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: `Reached max ${endpointType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow(),\n    })\n    state.queueFullReported = true\n  }\n  const previousQueue = state.queuedPayloads\n  state.queuedPayloads = newPayloadQueue()\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue()!, state, sendStrategy, endpointType, reportError)\n  }\n}\n\nfunction shouldRetryRequest(response: HttpResponse) {\n  return (\n    response.type !== 'opaque' &&\n    ((response.status === 0 && !navigator.onLine) ||\n      response.status === 408 ||\n      response.status === 429 ||\n      response.status >= 500)\n  )\n}\n\nexport function newRetryState(): RetryState {\n  return {\n    transportStatus: TransportStatus.UP,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false,\n  }\n}\n\nfunction newPayloadQueue() {\n  const queue: Payload[] = []\n  return {\n    bytesCount: 0,\n    enqueue(payload: Payload) {\n      if (this.isFull()) {\n        return\n      }\n      queue.push(payload)\n      this.bytesCount += payload.bytesCount\n    },\n    first() {\n      return queue[0]\n    },\n    dequeue() {\n      const payload = queue.shift()\n      if (payload) {\n        this.bytesCount -= payload.bytesCount\n      }\n      return payload\n    },\n    size() {\n      return queue.length\n    },\n    isFull() {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT\n    },\n  }\n}\n\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle(payload: Payload) {\n      return (\n        this.ongoingRequestCount === 0 ||\n        (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n          this.ongoingRequestCount < MAX_ONGOING_REQUESTS)\n      )\n    },\n    add(payload: Payload) {\n      this.ongoingRequestCount += 1\n      this.ongoingByteCount += payload.bytesCount\n    },\n    remove(payload: Payload) {\n      this.ongoingRequestCount -= 1\n      this.ongoingByteCount -= payload.bytesCount\n    },\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}