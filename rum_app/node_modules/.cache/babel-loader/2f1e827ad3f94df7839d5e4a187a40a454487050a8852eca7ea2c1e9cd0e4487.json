{"ast":null,"code":"import { canUseEventBridge, noop, runOnReadyState } from '@datadog/browser-core';\nimport { getReplayStats } from '../domain/replayStats';\nimport { startDeflateWorker } from '../domain/segmentCollection';\nexport function makeRecorderApi(startRecordingImpl, startDeflateWorkerImpl) {\n  if (startDeflateWorkerImpl === void 0) {\n    startDeflateWorkerImpl = startDeflateWorker;\n  }\n  if (canUseEventBridge() || !isBrowserSupported()) {\n    return {\n      start: noop,\n      stop: noop,\n      getReplayStats: function () {\n        return undefined;\n      },\n      onRumStart: noop,\n      isRecording: function () {\n        return false;\n      }\n    };\n  }\n  var state = {\n    status: 0 /* Stopped */\n  };\n\n  var startStrategy = function () {\n    state = {\n      status: 1 /* IntentToStart */\n    };\n  };\n\n  var stopStrategy = function () {\n    state = {\n      status: 0 /* Stopped */\n    };\n  };\n\n  return {\n    start: function () {\n      return startStrategy();\n    },\n    stop: function () {\n      return stopStrategy();\n    },\n    getReplayStats: getReplayStats,\n    onRumStart: function (lifeCycle, configuration, sessionManager, viewContexts) {\n      lifeCycle.subscribe(7 /* SESSION_EXPIRED */, function () {\n        if (state.status === 2 /* Starting */ || state.status === 3 /* Started */) {\n          stopStrategy();\n          state = {\n            status: 1 /* IntentToStart */\n          };\n        }\n      });\n\n      lifeCycle.subscribe(8 /* SESSION_RENEWED */, function () {\n        if (state.status === 1 /* IntentToStart */) {\n          startStrategy();\n        }\n      });\n      startStrategy = function () {\n        var session = sessionManager.findTrackedSession();\n        if (!session || !session.sessionReplayAllowed) {\n          state = {\n            status: 1 /* IntentToStart */\n          };\n          return;\n        }\n        if (state.status === 2 /* Starting */ || state.status === 3 /* Started */) {\n          return;\n        }\n        state = {\n          status: 2 /* Starting */\n        };\n        runOnReadyState('interactive', function () {\n          if (state.status !== 2 /* Starting */) {\n            return;\n          }\n          startDeflateWorkerImpl(function (worker) {\n            if (state.status !== 2 /* Starting */) {\n              return;\n            }\n            if (!worker) {\n              state = {\n                status: 0 /* Stopped */\n              };\n\n              return;\n            }\n            var stopRecording = startRecordingImpl(lifeCycle, configuration, sessionManager, viewContexts, worker).stop;\n            state = {\n              status: 3 /* Started */,\n              stopRecording: stopRecording\n            };\n          });\n        });\n      };\n      stopStrategy = function () {\n        if (state.status === 0 /* Stopped */) {\n          return;\n        }\n        if (state.status === 3 /* Started */) {\n          state.stopRecording();\n        }\n        state = {\n          status: 0 /* Stopped */\n        };\n      };\n\n      if (state.status === 1 /* IntentToStart */) {\n        startStrategy();\n      }\n    },\n    isRecording: function () {\n      return state.status === 3 /* Started */;\n    }\n  };\n}\n/**\n * Test for Browser features used while recording\n */\nfunction isBrowserSupported() {\n  return (\n    // Array.from is a bit less supported by browsers than CSSSupportsRule, but has higher chances\n    // to be polyfilled. Test for both to be more confident. We could add more things if we find out\n    // this test is not sufficient.\n    typeof Array.from === 'function' && typeof CSSSupportsRule === 'function' && 'forEach' in NodeList.prototype\n  );\n}","map":{"version":3,"names":["canUseEventBridge","noop","runOnReadyState","getReplayStats","startDeflateWorker","makeRecorderApi","startRecordingImpl","startDeflateWorkerImpl","isBrowserSupported","start","stop","undefined","onRumStart","isRecording","state","status","startStrategy","stopStrategy","lifeCycle","configuration","sessionManager","viewContexts","subscribe","session","findTrackedSession","sessionReplayAllowed","worker","stopRecording","Array","from","CSSSupportsRule","NodeList","prototype"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/rum_and_trace_correlation/rum_app/node_modules/@datadog/browser-rum/src/boot/recorderApi.ts"],"sourcesContent":["import { canUseEventBridge, noop, runOnReadyState } from '@datadog/browser-core'\nimport type {\n  LifeCycle,\n  ViewContexts,\n  RumSessionManager,\n  RecorderApi,\n  RumConfiguration,\n} from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport { getReplayStats } from '../domain/replayStats'\nimport { startDeflateWorker } from '../domain/segmentCollection'\n\nimport type { startRecording } from './startRecording'\n\nexport type StartRecording = typeof startRecording\n\nconst enum RecorderStatus {\n  // The recorder is stopped.\n  Stopped,\n  // The user started the recording while it wasn't possible yet. The recorder should start as soon\n  // as possible.\n  IntentToStart,\n  // The recorder is starting. It does not record anything yet.\n  Starting,\n  // The recorder is started, it records the session.\n  Started,\n}\ntype RecorderState =\n  | {\n      status: RecorderStatus.Stopped\n    }\n  | {\n      status: RecorderStatus.IntentToStart\n    }\n  | {\n      status: RecorderStatus.Starting\n    }\n  | {\n      status: RecorderStatus.Started\n      stopRecording: () => void\n    }\n\nexport function makeRecorderApi(\n  startRecordingImpl: StartRecording,\n  startDeflateWorkerImpl = startDeflateWorker\n): RecorderApi {\n  if (canUseEventBridge() || !isBrowserSupported()) {\n    return {\n      start: noop,\n      stop: noop,\n      getReplayStats: () => undefined,\n      onRumStart: noop,\n      isRecording: () => false,\n    }\n  }\n\n  let state: RecorderState = {\n    status: RecorderStatus.Stopped,\n  }\n\n  let startStrategy = () => {\n    state = { status: RecorderStatus.IntentToStart }\n  }\n  let stopStrategy = () => {\n    state = { status: RecorderStatus.Stopped }\n  }\n  return {\n    start: () => startStrategy(),\n    stop: () => stopStrategy(),\n    getReplayStats,\n\n    onRumStart: (\n      lifeCycle: LifeCycle,\n      configuration: RumConfiguration,\n      sessionManager: RumSessionManager,\n      viewContexts: ViewContexts\n    ) => {\n      lifeCycle.subscribe(LifeCycleEventType.SESSION_EXPIRED, () => {\n        if (state.status === RecorderStatus.Starting || state.status === RecorderStatus.Started) {\n          stopStrategy()\n          state = { status: RecorderStatus.IntentToStart }\n        }\n      })\n\n      lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n        if (state.status === RecorderStatus.IntentToStart) {\n          startStrategy()\n        }\n      })\n\n      startStrategy = () => {\n        const session = sessionManager.findTrackedSession()\n        if (!session || !session.sessionReplayAllowed) {\n          state = { status: RecorderStatus.IntentToStart }\n          return\n        }\n\n        if (state.status === RecorderStatus.Starting || state.status === RecorderStatus.Started) {\n          return\n        }\n\n        state = { status: RecorderStatus.Starting }\n\n        runOnReadyState('interactive', () => {\n          if (state.status !== RecorderStatus.Starting) {\n            return\n          }\n\n          startDeflateWorkerImpl((worker) => {\n            if (state.status !== RecorderStatus.Starting) {\n              return\n            }\n\n            if (!worker) {\n              state = {\n                status: RecorderStatus.Stopped,\n              }\n              return\n            }\n\n            const { stop: stopRecording } = startRecordingImpl(\n              lifeCycle,\n              configuration,\n              sessionManager,\n              viewContexts,\n              worker\n            )\n            state = {\n              status: RecorderStatus.Started,\n              stopRecording,\n            }\n          })\n        })\n      }\n\n      stopStrategy = () => {\n        if (state.status === RecorderStatus.Stopped) {\n          return\n        }\n\n        if (state.status === RecorderStatus.Started) {\n          state.stopRecording()\n        }\n\n        state = {\n          status: RecorderStatus.Stopped,\n        }\n      }\n\n      if (state.status === RecorderStatus.IntentToStart) {\n        startStrategy()\n      }\n    },\n\n    isRecording: () => state.status === RecorderStatus.Started,\n  }\n}\n\n/**\n * Test for Browser features used while recording\n */\nfunction isBrowserSupported() {\n  return (\n    // Array.from is a bit less supported by browsers than CSSSupportsRule, but has higher chances\n    // to be polyfilled. Test for both to be more confident. We could add more things if we find out\n    // this test is not sufficient.\n    typeof Array.from === 'function' && typeof CSSSupportsRule === 'function' && 'forEach' in NodeList.prototype\n  )\n}\n"],"mappings":"AAAA,SAASA,iBAAiB,EAAEC,IAAI,EAAEC,eAAe,QAAQ,uBAAuB;AAShF,SAASC,cAAc,QAAQ,uBAAuB;AACtD,SAASC,kBAAkB,QAAQ,6BAA6B;AAgChE,OAAM,SAAUC,eAAeA,CAC7BC,kBAAkC,EAClCC,sBAA2C;EAA3C,IAAAA,sBAAA;IAAAA,sBAAA,GAAAH,kBAA2C;EAAA;EAE3C,IAAIJ,iBAAiB,EAAE,IAAI,CAACQ,kBAAkB,EAAE,EAAE;IAChD,OAAO;MACLC,KAAK,EAAER,IAAI;MACXS,IAAI,EAAET,IAAI;MACVE,cAAc,EAAE,SAAAA,CAAA;QAAM,OAAAQ,SAAS;MAAT,CAAS;MAC/BC,UAAU,EAAEX,IAAI;MAChBY,WAAW,EAAE,SAAAA,CAAA;QAAM,YAAK;MAAL;KACpB;;EAGH,IAAIC,KAAK,GAAkB;IACzBC,MAAM;GACP;;EAED,IAAIC,aAAa,GAAG,SAAAA,CAAA;IAClBF,KAAK,GAAG;MAAEC,MAAM;IAA8B,CAAE;EAClD,CAAC;;EACD,IAAIE,YAAY,GAAG,SAAAA,CAAA;IACjBH,KAAK,GAAG;MAAEC,MAAM;IAAwB,CAAE;EAC5C,CAAC;;EACD,OAAO;IACLN,KAAK,EAAE,SAAAA,CAAA;MAAM,OAAAO,aAAa,EAAE;IAAf,CAAe;IAC5BN,IAAI,EAAE,SAAAA,CAAA;MAAM,OAAAO,YAAY,EAAE;IAAd,CAAc;IAC1Bd,cAAc,EAAAA,cAAA;IAEdS,UAAU,EAAE,SAAAA,CACVM,SAAoB,EACpBC,aAA+B,EAC/BC,cAAiC,EACjCC,YAA0B;MAE1BH,SAAS,CAACI,SAAS,0BAAqC;QACtD,IAAIR,KAAK,CAACC,MAAM,yBAAgCD,KAAK,CAACC,MAAM,sBAA6B;UACvFE,YAAY,EAAE;UACdH,KAAK,GAAG;YAAEC,MAAM;UAA8B,CAAE;;MAEpD,CAAC,CAAC;;MAEFG,SAAS,CAACI,SAAS,0BAAqC;QACtD,IAAIR,KAAK,CAACC,MAAM,4BAAmC;UACjDC,aAAa,EAAE;;MAEnB,CAAC,CAAC;MAEFA,aAAa,GAAG,SAAAA,CAAA;QACd,IAAMO,OAAO,GAAGH,cAAc,CAACI,kBAAkB,EAAE;QACnD,IAAI,CAACD,OAAO,IAAI,CAACA,OAAO,CAACE,oBAAoB,EAAE;UAC7CX,KAAK,GAAG;YAAEC,MAAM;UAA8B,CAAE;UAChD;;QAGF,IAAID,KAAK,CAACC,MAAM,yBAAgCD,KAAK,CAACC,MAAM,sBAA6B;UACvF;;QAGFD,KAAK,GAAG;UAAEC,MAAM;QAAyB,CAAE;QAE3Cb,eAAe,CAAC,aAAa,EAAE;UAC7B,IAAIY,KAAK,CAACC,MAAM,uBAA8B;YAC5C;;UAGFR,sBAAsB,CAAC,UAACmB,MAAM;YAC5B,IAAIZ,KAAK,CAACC,MAAM,uBAA8B;cAC5C;;YAGF,IAAI,CAACW,MAAM,EAAE;cACXZ,KAAK,GAAG;gBACNC,MAAM;eACP;;cACD;;YAGM,IAAMY,aAAa,GAAKrB,kBAAkB,CAChDY,SAAS,EACTC,aAAa,EACbC,cAAc,EACdC,YAAY,EACZK,MAAM,CACP,CAAAhB,IAN0B;YAO3BI,KAAK,GAAG;cACNC,MAAM;cACNY,aAAa,EAAAA;aACd;UACH,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ,CAAC;MAEDV,YAAY,GAAG,SAAAA,CAAA;QACb,IAAIH,KAAK,CAACC,MAAM,sBAA6B;UAC3C;;QAGF,IAAID,KAAK,CAACC,MAAM,sBAA6B;UAC3CD,KAAK,CAACa,aAAa,EAAE;;QAGvBb,KAAK,GAAG;UACNC,MAAM;SACP;MACH,CAAC;;MAED,IAAID,KAAK,CAACC,MAAM,4BAAmC;QACjDC,aAAa,EAAE;;IAEnB,CAAC;IAEDH,WAAW,EAAE,SAAAA,CAAA;MAAM,OAAAC,KAAK,CAACC,MAAM;IAAZ;GACpB;AACH;AAEA;;;AAGA,SAASP,kBAAkBA,CAAA;EACzB;IACE;IACA;IACA;IACA,OAAOoB,KAAK,CAACC,IAAI,KAAK,UAAU,IAAI,OAAOC,eAAe,KAAK,UAAU,IAAI,SAAS,IAAIC,QAAQ,CAACC;EAAS;AAEhH"},"metadata":{},"sourceType":"module","externalDependencies":[]}