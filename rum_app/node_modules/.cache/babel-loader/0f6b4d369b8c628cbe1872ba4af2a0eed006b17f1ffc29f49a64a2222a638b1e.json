{"ast":null,"code":"import { display } from '../tools/display';\nimport { computeBytesCount, jsonStringify, objectValues } from '../tools/utils';\nimport { monitor } from '../tools/monitor';\nimport { Observable } from '../tools/observable';\nvar Batch = /** @class */function () {\n  function Batch(request, batchMessagesLimit, batchBytesLimit, messageBytesLimit, flushTimeout, pageExitObservable) {\n    var _this = this;\n    this.request = request;\n    this.batchMessagesLimit = batchMessagesLimit;\n    this.batchBytesLimit = batchBytesLimit;\n    this.messageBytesLimit = messageBytesLimit;\n    this.flushTimeout = flushTimeout;\n    this.pageExitObservable = pageExitObservable;\n    this.flushObservable = new Observable();\n    this.pushOnlyBuffer = [];\n    this.upsertBuffer = {};\n    this.bufferBytesCount = 0;\n    this.bufferMessagesCount = 0;\n    pageExitObservable.subscribe(function () {\n      return _this.flush(_this.request.sendOnExit);\n    });\n    this.flushPeriodically();\n  }\n  Batch.prototype.add = function (message) {\n    this.addOrUpdate(message);\n  };\n  Batch.prototype.upsert = function (message, key) {\n    this.addOrUpdate(message, key);\n  };\n  Batch.prototype.flush = function (sendFn) {\n    if (sendFn === void 0) {\n      sendFn = this.request.send;\n    }\n    if (this.bufferMessagesCount !== 0) {\n      var messages = this.pushOnlyBuffer.concat(objectValues(this.upsertBuffer));\n      var bytesCount = this.bufferBytesCount;\n      this.flushObservable.notify({\n        bufferBytesCount: this.bufferBytesCount,\n        bufferMessagesCount: this.bufferMessagesCount\n      });\n      this.pushOnlyBuffer = [];\n      this.upsertBuffer = {};\n      this.bufferBytesCount = 0;\n      this.bufferMessagesCount = 0;\n      sendFn({\n        data: messages.join('\\n'),\n        bytesCount: bytesCount\n      });\n    }\n  };\n  Batch.prototype.addOrUpdate = function (message, key) {\n    var _a = this.process(message),\n      processedMessage = _a.processedMessage,\n      messageBytesCount = _a.messageBytesCount;\n    if (messageBytesCount >= this.messageBytesLimit) {\n      display.warn(\"Discarded a message whose size was bigger than the maximum allowed size \".concat(this.messageBytesLimit, \"KB.\"));\n      return;\n    }\n    if (this.hasMessageFor(key)) {\n      this.remove(key);\n    }\n    if (this.willReachedBytesLimitWith(messageBytesCount)) {\n      this.flush();\n    }\n    this.push(processedMessage, messageBytesCount, key);\n    if (this.isFull()) {\n      this.flush();\n    }\n  };\n  Batch.prototype.process = function (message) {\n    var processedMessage = jsonStringify(message);\n    var messageBytesCount = computeBytesCount(processedMessage);\n    return {\n      processedMessage: processedMessage,\n      messageBytesCount: messageBytesCount\n    };\n  };\n  Batch.prototype.push = function (processedMessage, messageBytesCount, key) {\n    if (this.bufferMessagesCount > 0) {\n      // \\n separator at serialization\n      this.bufferBytesCount += 1;\n    }\n    if (key !== undefined) {\n      this.upsertBuffer[key] = processedMessage;\n    } else {\n      this.pushOnlyBuffer.push(processedMessage);\n    }\n    this.bufferBytesCount += messageBytesCount;\n    this.bufferMessagesCount += 1;\n  };\n  Batch.prototype.remove = function (key) {\n    var removedMessage = this.upsertBuffer[key];\n    delete this.upsertBuffer[key];\n    var messageBytesCount = computeBytesCount(removedMessage);\n    this.bufferBytesCount -= messageBytesCount;\n    this.bufferMessagesCount -= 1;\n    if (this.bufferMessagesCount > 0) {\n      this.bufferBytesCount -= 1;\n    }\n  };\n  Batch.prototype.hasMessageFor = function (key) {\n    return key !== undefined && this.upsertBuffer[key] !== undefined;\n  };\n  Batch.prototype.willReachedBytesLimitWith = function (messageBytesCount) {\n    // byte of the separator at the end of the message\n    return this.bufferBytesCount + messageBytesCount + 1 >= this.batchBytesLimit;\n  };\n  Batch.prototype.isFull = function () {\n    return this.bufferMessagesCount === this.batchMessagesLimit || this.bufferBytesCount >= this.batchBytesLimit;\n  };\n  Batch.prototype.flushPeriodically = function () {\n    var _this = this;\n    setTimeout(monitor(function () {\n      _this.flush();\n      _this.flushPeriodically();\n    }), this.flushTimeout);\n  };\n  return Batch;\n}();\nexport { Batch };","map":{"version":3,"names":["display","computeBytesCount","jsonStringify","objectValues","monitor","Observable","Batch","request","batchMessagesLimit","batchBytesLimit","messageBytesLimit","flushTimeout","pageExitObservable","_this","flushObservable","pushOnlyBuffer","upsertBuffer","bufferBytesCount","bufferMessagesCount","subscribe","flush","sendOnExit","flushPeriodically","prototype","add","message","addOrUpdate","upsert","key","sendFn","send","messages","concat","bytesCount","notify","data","join","_a","process","processedMessage","messageBytesCount","warn","hasMessageFor","remove","willReachedBytesLimitWith","push","isFull","undefined","removedMessage","setTimeout"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/apm-enablement-sessions/rum_and_trace_correlation/react-app/node_modules/@datadog/browser-core/src/transport/batch.ts"],"sourcesContent":["import { display } from '../tools/display'\nimport type { Context } from '../tools/context'\nimport { computeBytesCount, jsonStringify, objectValues } from '../tools/utils'\nimport { monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { PageExitEvent } from '../browser/pageExitObservable'\nimport type { HttpRequest } from './httpRequest'\n\nexport interface BatchFlushEvent {\n  bufferBytesCount: number\n  bufferMessagesCount: number\n}\n\nexport class Batch {\n  flushObservable = new Observable<BatchFlushEvent>()\n\n  private pushOnlyBuffer: string[] = []\n  private upsertBuffer: { [key: string]: string } = {}\n  private bufferBytesCount = 0\n  private bufferMessagesCount = 0\n\n  constructor(\n    private request: HttpRequest,\n    private batchMessagesLimit: number,\n    private batchBytesLimit: number,\n    private messageBytesLimit: number,\n    private flushTimeout: number,\n    private pageExitObservable: Observable<PageExitEvent>\n  ) {\n    pageExitObservable.subscribe(() => this.flush(this.request.sendOnExit))\n    this.flushPeriodically()\n  }\n\n  add(message: Context) {\n    this.addOrUpdate(message)\n  }\n\n  upsert(message: Context, key: string) {\n    this.addOrUpdate(message, key)\n  }\n\n  flush(sendFn = this.request.send) {\n    if (this.bufferMessagesCount !== 0) {\n      const messages = this.pushOnlyBuffer.concat(objectValues(this.upsertBuffer))\n      const bytesCount = this.bufferBytesCount\n\n      this.flushObservable.notify({\n        bufferBytesCount: this.bufferBytesCount,\n        bufferMessagesCount: this.bufferMessagesCount,\n      })\n\n      this.pushOnlyBuffer = []\n      this.upsertBuffer = {}\n      this.bufferBytesCount = 0\n      this.bufferMessagesCount = 0\n\n      sendFn({ data: messages.join('\\n'), bytesCount })\n    }\n  }\n\n  private addOrUpdate(message: Context, key?: string) {\n    const { processedMessage, messageBytesCount } = this.process(message)\n    if (messageBytesCount >= this.messageBytesLimit) {\n      display.warn(\n        `Discarded a message whose size was bigger than the maximum allowed size ${this.messageBytesLimit}KB.`\n      )\n      return\n    }\n    if (this.hasMessageFor(key)) {\n      this.remove(key)\n    }\n    if (this.willReachedBytesLimitWith(messageBytesCount)) {\n      this.flush()\n    }\n\n    this.push(processedMessage, messageBytesCount, key)\n    if (this.isFull()) {\n      this.flush()\n    }\n  }\n\n  private process(message: Context) {\n    const processedMessage = jsonStringify(message)!\n    const messageBytesCount = computeBytesCount(processedMessage)\n    return { processedMessage, messageBytesCount }\n  }\n\n  private push(processedMessage: string, messageBytesCount: number, key?: string) {\n    if (this.bufferMessagesCount > 0) {\n      // \\n separator at serialization\n      this.bufferBytesCount += 1\n    }\n    if (key !== undefined) {\n      this.upsertBuffer[key] = processedMessage\n    } else {\n      this.pushOnlyBuffer.push(processedMessage)\n    }\n    this.bufferBytesCount += messageBytesCount\n    this.bufferMessagesCount += 1\n  }\n\n  private remove(key: string) {\n    const removedMessage = this.upsertBuffer[key]\n    delete this.upsertBuffer[key]\n    const messageBytesCount = computeBytesCount(removedMessage)\n    this.bufferBytesCount -= messageBytesCount\n    this.bufferMessagesCount -= 1\n    if (this.bufferMessagesCount > 0) {\n      this.bufferBytesCount -= 1\n    }\n  }\n\n  private hasMessageFor(key?: string): key is string {\n    return key !== undefined && this.upsertBuffer[key] !== undefined\n  }\n\n  private willReachedBytesLimitWith(messageBytesCount: number) {\n    // byte of the separator at the end of the message\n    return this.bufferBytesCount + messageBytesCount + 1 >= this.batchBytesLimit\n  }\n\n  private isFull() {\n    return this.bufferMessagesCount === this.batchMessagesLimit || this.bufferBytesCount >= this.batchBytesLimit\n  }\n\n  private flushPeriodically() {\n    setTimeout(\n      monitor(() => {\n        this.flush()\n        this.flushPeriodically()\n      }),\n      this.flushTimeout\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}