{"ast":null,"code":"import { isPageExitReason, ONE_SECOND, monitor } from '@datadog/browser-core';\nimport { buildReplayPayload } from './buildReplayPayload';\nimport { Segment } from './segment';\nexport var SEGMENT_DURATION_LIMIT = 30 * ONE_SECOND;\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport var SEGMENT_BYTES_LIMIT = 60000;\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\nexport function startSegmentCollection(lifeCycle, applicationId, sessionManager, viewContexts, httpRequest, worker) {\n  return doStartSegmentCollection(lifeCycle, function () {\n    return computeSegmentContext(applicationId, sessionManager, viewContexts);\n  }, httpRequest, worker);\n}\nexport function doStartSegmentCollection(lifeCycle, getSegmentContext, httpRequest, worker) {\n  var state = {\n    status: 0 /* WaitingForInitialRecord */,\n    nextSegmentCreationReason: 'init'\n  };\n  var unsubscribeViewCreated = lifeCycle.subscribe(2 /* VIEW_CREATED */, function () {\n    flushSegment('view_change');\n  }).unsubscribe;\n  var unsubscribePageExited = lifeCycle.subscribe(9 /* PAGE_EXITED */, function (pageExitEvent) {\n    flushSegment(pageExitEvent.reason);\n  }).unsubscribe;\n  function flushSegment(flushReason) {\n    if (state.status === 1 /* SegmentPending */) {\n      state.segment.flush(flushReason);\n      clearTimeout(state.expirationTimeoutId);\n    }\n    if (flushReason !== 'stop') {\n      state = {\n        status: 0 /* WaitingForInitialRecord */,\n        nextSegmentCreationReason: flushReason\n      };\n    } else {\n      state = {\n        status: 2 /* Stopped */\n      };\n    }\n  }\n\n  function createNewSegment(creationReason, initialRecord) {\n    var context = getSegmentContext();\n    if (!context) {\n      return;\n    }\n    var segment = new Segment(worker, context, creationReason, initialRecord, function (compressedSegmentBytesCount) {\n      if (!segment.flushReason && compressedSegmentBytesCount > SEGMENT_BYTES_LIMIT) {\n        flushSegment('segment_bytes_limit');\n      }\n    }, function (data, rawSegmentBytesCount) {\n      var payload = buildReplayPayload(data, segment.metadata, rawSegmentBytesCount);\n      if (isPageExitReason(segment.flushReason)) {\n        httpRequest.sendOnExit(payload);\n      } else {\n        httpRequest.send(payload);\n      }\n    });\n    state = {\n      status: 1 /* SegmentPending */,\n      segment: segment,\n      expirationTimeoutId: setTimeout(monitor(function () {\n        flushSegment('segment_duration_limit');\n      }), SEGMENT_DURATION_LIMIT)\n    };\n  }\n  return {\n    addRecord: function (record) {\n      switch (state.status) {\n        case 0 /* WaitingForInitialRecord */:\n          createNewSegment(state.nextSegmentCreationReason, record);\n          break;\n        case 1 /* SegmentPending */:\n          state.segment.addRecord(record);\n          break;\n      }\n    },\n    stop: function () {\n      flushSegment('stop');\n      unsubscribeViewCreated();\n      unsubscribePageExited();\n    }\n  };\n}\nexport function computeSegmentContext(applicationId, sessionManager, viewContexts) {\n  var session = sessionManager.findTrackedSession();\n  var viewContext = viewContexts.findView();\n  if (!session || !viewContext) {\n    return undefined;\n  }\n  return {\n    application: {\n      id: applicationId\n    },\n    session: {\n      id: session.id\n    },\n    view: {\n      id: viewContext.id\n    }\n  };\n}\nexport function setSegmentBytesLimit(newSegmentBytesLimit) {\n  if (newSegmentBytesLimit === void 0) {\n    newSegmentBytesLimit = 60000;\n  }\n  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit;\n}","map":{"version":3,"names":["isPageExitReason","ONE_SECOND","monitor","buildReplayPayload","Segment","SEGMENT_DURATION_LIMIT","SEGMENT_BYTES_LIMIT","startSegmentCollection","lifeCycle","applicationId","sessionManager","viewContexts","httpRequest","worker","doStartSegmentCollection","computeSegmentContext","getSegmentContext","state","status","nextSegmentCreationReason","unsubscribeViewCreated","subscribe","flushSegment","unsubscribe","unsubscribePageExited","pageExitEvent","reason","flushReason","segment","flush","clearTimeout","expirationTimeoutId","createNewSegment","creationReason","initialRecord","context","compressedSegmentBytesCount","data","rawSegmentBytesCount","payload","metadata","sendOnExit","send","setTimeout","addRecord","record","stop","session","findTrackedSession","viewContext","findView","undefined","application","id","view","setSegmentBytesLimit","newSegmentBytesLimit"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/apm-enablement-sessions/rum_and_trace_correlation/react-app/node_modules/@datadog/browser-rum/src/domain/segmentCollection/segmentCollection.ts"],"sourcesContent":["import type { HttpRequest, TimeoutId } from '@datadog/browser-core'\nimport { isPageExitReason, ONE_SECOND, monitor } from '@datadog/browser-core'\nimport type { LifeCycle, ViewContexts, RumSessionManager } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { BrowserRecord, CreationReason, SegmentContext } from '../../types'\nimport type { DeflateWorker } from './deflateWorker'\nimport { buildReplayPayload } from './buildReplayPayload'\nimport type { FlushReason } from './segment'\nimport { Segment } from './segment'\n\nexport const SEGMENT_DURATION_LIMIT = 30 * ONE_SECOND\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport let SEGMENT_BYTES_LIMIT = 60_000\n\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\n\nexport function startSegmentCollection(\n  lifeCycle: LifeCycle,\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  httpRequest: HttpRequest,\n  worker: DeflateWorker\n) {\n  return doStartSegmentCollection(\n    lifeCycle,\n    () => computeSegmentContext(applicationId, sessionManager, viewContexts),\n    httpRequest,\n    worker\n  )\n}\n\nconst enum SegmentCollectionStatus {\n  WaitingForInitialRecord,\n  SegmentPending,\n  Stopped,\n}\ntype SegmentCollectionState =\n  | {\n      status: SegmentCollectionStatus.WaitingForInitialRecord\n      nextSegmentCreationReason: CreationReason\n    }\n  | {\n      status: SegmentCollectionStatus.SegmentPending\n      segment: Segment\n      expirationTimeoutId: TimeoutId\n    }\n  | {\n      status: SegmentCollectionStatus.Stopped\n    }\n\nexport function doStartSegmentCollection(\n  lifeCycle: LifeCycle,\n  getSegmentContext: () => SegmentContext | undefined,\n  httpRequest: HttpRequest,\n  worker: DeflateWorker\n) {\n  let state: SegmentCollectionState = {\n    status: SegmentCollectionStatus.WaitingForInitialRecord,\n    nextSegmentCreationReason: 'init',\n  }\n\n  const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, () => {\n    flushSegment('view_change')\n  })\n\n  const { unsubscribe: unsubscribePageExited } = lifeCycle.subscribe(\n    LifeCycleEventType.PAGE_EXITED,\n    (pageExitEvent) => {\n      flushSegment(pageExitEvent.reason)\n    }\n  )\n\n  function flushSegment(flushReason: FlushReason) {\n    if (state.status === SegmentCollectionStatus.SegmentPending) {\n      state.segment.flush(flushReason)\n      clearTimeout(state.expirationTimeoutId)\n    }\n\n    if (flushReason !== 'stop') {\n      state = {\n        status: SegmentCollectionStatus.WaitingForInitialRecord,\n        nextSegmentCreationReason: flushReason,\n      }\n    } else {\n      state = {\n        status: SegmentCollectionStatus.Stopped,\n      }\n    }\n  }\n\n  function createNewSegment(creationReason: CreationReason, initialRecord: BrowserRecord) {\n    const context = getSegmentContext()\n    if (!context) {\n      return\n    }\n\n    const segment = new Segment(\n      worker,\n      context,\n      creationReason,\n      initialRecord,\n      (compressedSegmentBytesCount) => {\n        if (!segment.flushReason && compressedSegmentBytesCount > SEGMENT_BYTES_LIMIT) {\n          flushSegment('segment_bytes_limit')\n        }\n      },\n      (data, rawSegmentBytesCount) => {\n        const payload = buildReplayPayload(data, segment.metadata, rawSegmentBytesCount)\n\n        if (isPageExitReason(segment.flushReason)) {\n          httpRequest.sendOnExit(payload)\n        } else {\n          httpRequest.send(payload)\n        }\n      }\n    )\n\n    state = {\n      status: SegmentCollectionStatus.SegmentPending,\n      segment,\n      expirationTimeoutId: setTimeout(\n        monitor(() => {\n          flushSegment('segment_duration_limit')\n        }),\n        SEGMENT_DURATION_LIMIT\n      ),\n    }\n  }\n\n  return {\n    addRecord: (record: BrowserRecord) => {\n      switch (state.status) {\n        case SegmentCollectionStatus.WaitingForInitialRecord:\n          createNewSegment(state.nextSegmentCreationReason, record)\n          break\n\n        case SegmentCollectionStatus.SegmentPending:\n          state.segment.addRecord(record)\n          break\n      }\n    },\n\n    stop: () => {\n      flushSegment('stop')\n      unsubscribeViewCreated()\n      unsubscribePageExited()\n    },\n  }\n}\n\nexport function computeSegmentContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts\n) {\n  const session = sessionManager.findTrackedSession()\n  const viewContext = viewContexts.findView()\n  if (!session || !viewContext) {\n    return undefined\n  }\n  return {\n    application: {\n      id: applicationId,\n    },\n    session: {\n      id: session.id,\n    },\n    view: {\n      id: viewContext.id,\n    },\n  }\n}\n\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60_000) {\n  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}