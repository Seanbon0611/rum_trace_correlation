{"ast":null,"code":"var workerURL;\nexport function createDeflateWorker() {\n  // Lazily compute the worker URL to allow importing the SDK in NodeJS\n  if (!workerURL) {\n    workerURL = URL.createObjectURL(new Blob([\"(\".concat(workerCodeFn, \")(self)\")]));\n  }\n  return new Worker(workerURL);\n}\nfunction workerCodeFn() {\n  monitor(function () {\n    var _a = makePakoDeflate(),\n      Deflate = _a.Deflate,\n      constants = _a.constants,\n      string2buf = _a.string2buf;\n    var deflate = new Deflate();\n    var rawBytesCount = 0;\n    self.addEventListener('message', monitor(function (event) {\n      var data = event.data;\n      switch (data.action) {\n        case 'init':\n          self.postMessage({\n            type: 'initialized'\n          });\n          break;\n        case 'write':\n          {\n            var additionalBytesCount = pushData(data.data);\n            self.postMessage({\n              type: 'wrote',\n              id: data.id,\n              compressedBytesCount: deflate.chunks.reduce(function (total, chunk) {\n                return total + chunk.length;\n              }, 0),\n              additionalBytesCount: additionalBytesCount\n            });\n            break;\n          }\n        case 'flush':\n          {\n            var additionalBytesCount = data.data ? pushData(data.data) : 0;\n            deflate.push('', constants.Z_FINISH);\n            self.postMessage({\n              type: 'flushed',\n              id: data.id,\n              result: deflate.result,\n              additionalBytesCount: additionalBytesCount,\n              rawBytesCount: rawBytesCount\n            });\n            deflate = new Deflate();\n            rawBytesCount = 0;\n            break;\n          }\n      }\n    }));\n    function pushData(data) {\n      // TextEncoder is not supported on old browser version like Edge 18, therefore we use string2buf\n      var binaryData = string2buf(data);\n      deflate.push(binaryData, constants.Z_SYNC_FLUSH);\n      rawBytesCount += binaryData.length;\n      return binaryData.length;\n    }\n  })();\n  function monitor(fn) {\n    return function () {\n      try {\n        return fn.apply(this, arguments);\n      } catch (e) {\n        try {\n          self.postMessage({\n            type: 'errored',\n            error: e\n          });\n        } catch (_) {\n          // DATA_CLONE_ERR, cf https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n          self.postMessage({\n            type: 'errored',\n            error: \"\".concat(e)\n          });\n        }\n      }\n    };\n  }\n  // https://github.com/nodeca/pako/blob/034669ba0f1a4c0590e45f7c2820128200f972b3/dist/pako_deflate.es5.js\n  function makePakoDeflate() {\n    /* eslint-disable camelcase, no-bitwise */\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n    /* Public constants ========================================================== */\n    /* =========================================================================== */\n    // const Z_FILTERED          = 1;\n    // const Z_HUFFMAN_ONLY      = 2;\n    // const Z_RLE               = 3;\n    var Z_FIXED = 4; // const Z_DEFAULT_STRATEGY  = 0;\n    /* Possible values of the data_type field (though see inflate()) */\n    var Z_BINARY = 0;\n    var Z_TEXT = 1; // const Z_ASCII             = 1; // = Z_TEXT\n    var Z_UNKNOWN = 2;\n    /* ============================================================================ */\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0) {\n        buf[len] = 0;\n      }\n    } // From zutil.h\n    var STORED_BLOCK = 0;\n    var STATIC_TREES = 1;\n    var DYN_TREES = 2;\n    /* The three kinds of block type */\n    var MIN_MATCH = 3;\n    var MAX_MATCH = 258;\n    /* The minimum and maximum match lengths */\n    // From deflate.h\n    /* ===========================================================================\n     * Internal compression state.\n     */\n    var LENGTH_CODES = 29;\n    /* number of length codes, not counting the special END_BLOCK code */\n    var LITERALS = 256;\n    /* number of literal bytes 0..255 */\n    var L_CODES = LITERALS + 1 + LENGTH_CODES;\n    /* number of Literal or Length codes, including the END_BLOCK code */\n    var D_CODES = 30;\n    /* number of distance codes */\n    var BL_CODES = 19;\n    /* number of codes used to transfer the bit lengths */\n    var HEAP_SIZE = 2 * L_CODES + 1;\n    /* maximum heap size */\n    var MAX_BITS = 15;\n    /* All codes must not exceed MAX_BITS bits */\n    var Buf_size = 16;\n    /* size of bit buffer in bi_buf */\n    /* ===========================================================================\n     * Constants\n     */\n    var MAX_BL_BITS = 7;\n    /* Bit length codes must not exceed MAX_BL_BITS bits */\n    var END_BLOCK = 256;\n    /* end of block literal code */\n    var REP_3_6 = 16;\n    /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n    var REPZ_3_10 = 17;\n    /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n    var REPZ_11_138 = 18;\n    /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n    var extra_lbits = /* extra bits for each length code */\n    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);\n    var extra_dbits = /* extra bits for each distance code */\n    new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);\n    var extra_blbits = /* extra bits for each bit length code */\n    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);\n    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n    /* eslint-enable comma-spacing,array-bracket-spacing */\n    /* The lengths of the bit length codes are sent in order of decreasing\n     * probability, to avoid transmitting the lengths for unused bit length codes.\n     */\n    /* ===========================================================================\n     * Local data. These are initialized only once.\n     */\n    // We pre-fill arrays with 0 to avoid uninitialized gaps\n    var DIST_CODE_LEN = 512;\n    /* see definition of array dist_code below */\n    // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n    var static_ltree = new Array((L_CODES + 2) * 2);\n    zero(static_ltree);\n    /* The static literal tree. Since the bit lengths are imposed, there is no\n     * need for the L_CODES extra codes used during heap construction. However\n     * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n     * below).\n     */\n    var static_dtree = new Array(D_CODES * 2);\n    zero(static_dtree);\n    /* The static distance tree. (Actually a trivial tree since all codes use\n     * 5 bits.)\n     */\n    var _dist_code = new Array(DIST_CODE_LEN);\n    zero(_dist_code);\n    /* Distance codes. The first 256 values correspond to the distances\n     * 3 .. 258, the last 256 values correspond to the top 8 bits of\n     * the 15 bit distances.\n     */\n    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n    zero(_length_code);\n    /* length code for each normalized match length (0 == MIN_MATCH) */\n    var base_length = new Array(LENGTH_CODES);\n    zero(base_length);\n    /* First normalized length for each code (0 = MIN_MATCH) */\n    var base_dist = new Array(D_CODES);\n    zero(base_dist);\n    /* First normalized distance for each code (0 = distance of 1) */\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n      this.static_tree = static_tree;\n      /* static tree or NULL */\n      this.extra_bits = extra_bits;\n      /* extra bits for each code or NULL */\n      this.extra_base = extra_base;\n      /* base index for extra_bits */\n      this.elems = elems;\n      /* max number of elements in the tree */\n      this.max_length = max_length;\n      /* max bit length for the codes */\n      // show if `static_tree` has data or dummy - needed for monomorphic objects\n      this.has_stree = static_tree && static_tree.length;\n    }\n    var static_l_desc;\n    var static_d_desc;\n    var static_bl_desc;\n    function TreeDesc(dyn_tree, stat_desc) {\n      this.dyn_tree = dyn_tree;\n      /* the dynamic tree */\n      this.max_code = 0;\n      /* largest code with non zero frequency */\n      this.stat_desc = stat_desc;\n      /* the corresponding static tree */\n    }\n\n    var d_code = function d_code(dist) {\n      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n    };\n    /* ===========================================================================\n     * Output a short LSB first on the stream.\n     * IN assertion: there is enough room in pendingBuf.\n     */\n    var put_short = function put_short(s, w) {\n      //    put_byte(s, (uch)((w) & 0xff));\n      //    put_byte(s, (uch)((ush)(w) >> 8));\n      s.pending_buf[s.pending++] = w & 0xff;\n      s.pending_buf[s.pending++] = w >>> 8 & 0xff;\n    };\n    /* ===========================================================================\n     * Send a value on a given number of bits.\n     * IN assertion: length <= 16 and value fits in length bits.\n     */\n    var send_bits = function send_bits(s, value, length) {\n      if (s.bi_valid > Buf_size - length) {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        put_short(s, s.bi_buf);\n        s.bi_buf = value >> Buf_size - s.bi_valid;\n        s.bi_valid += length - Buf_size;\n      } else {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        s.bi_valid += length;\n      }\n    };\n    var send_code = function send_code(s, c, tree) {\n      send_bits(s, tree[c * 2], /* .Code */\n      tree[c * 2 + 1]\n      /* .Len */);\n    };\n    /* ===========================================================================\n     * Reverse the first len bits of a code, using straightforward code (a faster\n     * method would use a table)\n     * IN assertion: 1 <= len <= 15\n     */\n    var bi_reverse = function bi_reverse(code, len) {\n      var res = 0;\n      do {\n        res |= code & 1;\n        code >>>= 1;\n        res <<= 1;\n      } while (--len > 0);\n      return res >>> 1;\n    };\n    /* ===========================================================================\n     * Flush the bit buffer, keeping at most 7 bits in it.\n     */\n    var bi_flush = function bi_flush(s) {\n      if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n      } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n        s.bi_buf >>= 8;\n        s.bi_valid -= 8;\n      }\n    };\n    /* ===========================================================================\n     * Compute the optimal bit lengths for a tree and update the total bit length\n     * for the current block.\n     * IN assertion: the fields freq and dad are set, heap[heap_max] and\n     *    above are the tree nodes sorted by increasing frequency.\n     * OUT assertions: the field len is set to the optimal bit length, the\n     *     array bl_count contains the frequencies for each bit length.\n     *     The length opt_len is updated; static_len is also updated if stree is\n     *     not null.\n     */\n    var gen_bitlen = function gen_bitlen(s, desc //    deflate_state *s; //    tree_desc *desc;    /* the tree descriptor */\n    ) {\n      var tree = desc.dyn_tree;\n      var max_code = desc.max_code;\n      var stree = desc.stat_desc.static_tree;\n      var has_stree = desc.stat_desc.has_stree;\n      var extra = desc.stat_desc.extra_bits;\n      var base = desc.stat_desc.extra_base;\n      var max_length = desc.stat_desc.max_length;\n      var h;\n      /* heap index */\n      var n;\n      var m;\n      /* iterate over the tree elements */\n      var bits;\n      /* bit length */\n      var xbits;\n      /* extra bits */\n      var f;\n      /* frequency */\n      var overflow = 0;\n      /* number of elements with bit length too large */\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        s.bl_count[bits] = 0;\n      }\n      /* In a first pass, compute the optimal bit lengths (which may\n       * overflow in the case of the bit length tree).\n       */\n      tree[s.heap[s.heap_max] * 2 + 1] = /* .Len */\n      0;\n      /* root of the heap */\n      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s.heap[h];\n        bits = tree[tree[n * 2 + 1] * /* .Dad */\n        2 + 1] + /* .Len */\n        1;\n        if (bits > max_length) {\n          bits = max_length;\n          overflow++;\n        }\n        tree[n * 2 + 1] = /* .Len */\n        bits;\n        /* We overwrite tree[n].Dad which is no longer needed */\n        if (n > max_code) {\n          continue;\n        }\n        /* not a leaf node */\n        s.bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) {\n          xbits = extra[n - base];\n        }\n        f = tree[n * 2];\n        /* .Freq */\n        s.opt_len += f * (bits + xbits);\n        if (has_stree) {\n          s.static_len += f * (stree[n * 2 + 1] + /* .Len */\n          xbits);\n        }\n      }\n      if (overflow === 0) {\n        return;\n      } // Trace((stderr,\"\\nbit length overflow\\n\"));\n      /* This happens for example on obj2 and pic of the Calgary corpus */\n      /* Find the first bit length which could increase: */\n      do {\n        bits = max_length - 1;\n        while (s.bl_count[bits] === 0) {\n          bits--;\n        }\n        s.bl_count[bits]--;\n        /* move one leaf down the tree */\n        s.bl_count[bits + 1] += 2;\n        /* move one overflow item as its brother */\n        s.bl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count[max_length]\n         */\n        overflow -= 2;\n      } while (overflow > 0);\n      /* Now recompute all bit lengths, scanning in increasing frequency.\n       * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n       * lengths instead of fixing only the wrong ones. This idea is taken\n       * from 'ar' written by Haruhiko Okumura.)\n       */\n      for (bits = max_length; bits !== 0; bits--) {\n        n = s.bl_count[bits];\n        while (n !== 0) {\n          m = s.heap[--h];\n          if (m > max_code) {\n            continue;\n          }\n          if (tree[m * 2 + 1] !== /* .Len */\n          bits) {\n            // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n            s.opt_len += (bits - tree[m * 2 + 1]) * /* .Len */\n            tree[m * 2];\n            /* .Freq */\n            tree[m * 2 + 1] = /* .Len */\n            bits;\n          }\n          n--;\n        }\n      }\n    };\n    /* ===========================================================================\n     * Generate the codes for a given tree and bit counts (which need not be\n     * optimal).\n     * IN assertion: the array bl_count contains the bit length statistics for\n     * the given tree and the field len is set for all tree elements.\n     * OUT assertion: the field code is set for all tree elements of non\n     *     zero code length.\n     */\n    var gen_codes = function gen_codes(tree, max_code, bl_count\n    //    ct_data *tree;             /* the tree to decorate */\n    //    int max_code;              /* largest code with non zero frequency */\n    //    ushf *bl_count;            /* number of codes at each bit length */\n    ) {\n      var next_code = new Array(MAX_BITS + 1);\n      /* next code value for each bit length */\n      var code = 0;\n      /* running code value */\n      var bits;\n      /* bit index */\n      var n;\n      /* code index */\n      /* The distribution counts are first used to generate the code values\n       * without bit reversal.\n       */\n      for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code[bits] = code = code + bl_count[bits - 1] << 1;\n      }\n      /* Check that the bit counts in bl_count are consistent. The last code\n       * must be all ones.\n       */\n      // Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n      //        \"inconsistent bit counts\");\n      // Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n      for (n = 0; n <= max_code; n++) {\n        var len = tree[n * 2 + 1];\n        /* .Len */\n        if (len === 0) {\n          continue;\n        }\n        /* Now reverse the bits */\n        tree[n * 2] = /* .Code */\n        bi_reverse(next_code[len]++, len); // Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n        //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n      }\n    };\n    /* ===========================================================================\n     * Initialize the various 'constant' tables.\n     */\n    var tr_static_init = function tr_static_init() {\n      var n;\n      /* iterates over tree elements */\n      var bits;\n      /* bit counter */\n      var length;\n      /* length value */\n      var code;\n      /* code value */\n      var dist;\n      /* distance index */\n      var bl_count = new Array(MAX_BITS + 1);\n      /* number of codes at each bit length for an optimal tree */\n      // do check in _tr_init()\n      // if (static_init_done) return;\n      /* For some embedded targets, global variables are not initialized: */\n      /* #ifdef NO_INIT_GLOBAL_POINTERS\n      static_l_desc.static_tree = static_ltree;\n      static_l_desc.extra_bits = extra_lbits;\n      static_d_desc.static_tree = static_dtree;\n      static_d_desc.extra_bits = extra_dbits;\n      static_bl_desc.extra_bits = extra_blbits;\n      #endif */\n      /* Initialize the mapping length (0..255) -> length code (0..28) */\n      length = 0;\n      for (code = 0; code < LENGTH_CODES - 1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < 1 << extra_lbits[code]; n++) {\n          _length_code[length++] = code;\n        }\n      } // Assert (length == 256, \"tr_static_init: length != 256\");\n      /* Note that the length 255 (match length 258) can be represented\n       * in two different ways: code 284 + 5 bits or code 285, so we\n       * overwrite length_code[255] to use the best encoding:\n       */\n      _length_code[length - 1] = code;\n      /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n      dist = 0;\n      for (code = 0; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < 1 << extra_dbits[code]; n++) {\n          _dist_code[dist++] = code;\n        }\n      } // Assert (dist == 256, \"tr_static_init: dist != 256\");\n      dist >>= 7;\n      /* from now on, all distances are divided by 128 */\n      for (; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {\n          _dist_code[256 + dist++] = code;\n        }\n      } // Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n      /* Construct the codes of the static literal tree */\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        bl_count[bits] = 0;\n      }\n      n = 0;\n      while (n <= 143) {\n        static_ltree[n * 2 + 1] = /* .Len */\n        8;\n        n++;\n        bl_count[8]++;\n      }\n      while (n <= 255) {\n        static_ltree[n * 2 + 1] = /* .Len */\n        9;\n        n++;\n        bl_count[9]++;\n      }\n      while (n <= 279) {\n        static_ltree[n * 2 + 1] = /* .Len */\n        7;\n        n++;\n        bl_count[7]++;\n      }\n      while (n <= 287) {\n        static_ltree[n * 2 + 1] = /* .Len */\n        8;\n        n++;\n        bl_count[8]++;\n      }\n      /* Codes 286 and 287 do not exist, but we must include them in the\n       * tree construction to get a canonical Huffman tree (longest code\n       * all ones)\n       */\n      gen_codes(static_ltree, L_CODES + 1, bl_count);\n      /* The static distance tree is trivial: */\n      for (n = 0; n < D_CODES; n++) {\n        static_dtree[n * 2 + 1] = /* .Len */\n        5;\n        static_dtree[n * 2] = /* .Code */\n        bi_reverse(n, 5);\n      } // Now data ready and we can init static trees\n      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n      // static_init_done = true;\n    };\n    /* ===========================================================================\n     * Initialize a new block.\n     */\n    var init_block = function init_block(s) {\n      var n;\n      /* iterates over tree elements */\n      /* Initialize the trees. */\n      for (n = 0; n < L_CODES; n++) {\n        s.dyn_ltree[n * 2] = /* .Freq */\n        0;\n      }\n      for (n = 0; n < D_CODES; n++) {\n        s.dyn_dtree[n * 2] = /* .Freq */\n        0;\n      }\n      for (n = 0; n < BL_CODES; n++) {\n        s.bl_tree[n * 2] = /* .Freq */\n        0;\n      }\n      s.dyn_ltree[END_BLOCK * 2] = /* .Freq */\n      1;\n      s.opt_len = s.static_len = 0;\n      s.last_lit = s.matches = 0;\n    };\n    /* ===========================================================================\n     * Flush the bit buffer and align the output on a byte boundary\n     */\n    var bi_windup = function bi_windup(s) {\n      if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf);\n      } else if (s.bi_valid > 0) {\n        // put_byte(s, (Byte)s->bi_buf);\n        s.pending_buf[s.pending++] = s.bi_buf;\n      }\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n    };\n    /* ===========================================================================\n     * Copy a stored block, storing first the length and its\n     * one's complement if requested.\n     */\n    var copy_block = function copy_block(s, buf, len, header\n    // DeflateState *s;\n    // charf    *buf;    /* the input data */\n    // unsigned len;     /* its length */\n    // int      header;  /* true if block header must be written */\n    ) {\n      bi_windup(s);\n      /* align on byte boundary */\n      if (header) {\n        put_short(s, len);\n        put_short(s, ~len);\n      }\n      //  while (len--) {\n      //    put_byte(s, *buf++);\n      //  }\n      s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n      s.pending += len;\n    };\n    /* ===========================================================================\n     * Compares to subtrees, using the tree depth as tie breaker when\n     * the subtrees have equal frequency. This minimizes the worst case length.\n     */\n    var smaller = function smaller(tree, n, m, depth) {\n      var _n2 = n * 2;\n      var _m2 = m * 2;\n      return tree[_n2] < /* .Freq */\n      tree[_m2] || /* .Freq */\n      tree[_n2] === /* .Freq */\n      tree[_m2] && /* .Freq */\n      depth[n] <= depth[m];\n    };\n    /* ===========================================================================\n     * Restore the heap property by moving down the tree starting at node k,\n     * exchanging a node with the smallest of its two sons if necessary, stopping\n     * when the heap property is re-established (each father smaller than its\n     * two sons).\n     */\n    var pqdownheap = function pqdownheap(s, tree, k\n    //    deflate_state *s;\n    //    ct_data *tree;  /* the tree to restore */\n    //    int k;               /* node to move down */\n    ) {\n      var v = s.heap[k];\n      var j = k << 1;\n      /* left son of k */\n      while (j <= s.heap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n          j++;\n        }\n        /* Exit if v is smaller than both sons */\n        if (smaller(tree, v, s.heap[j], s.depth)) {\n          break;\n        }\n        /* Exchange v with the smallest son */\n        s.heap[k] = s.heap[j];\n        k = j;\n        /* And continue down the tree, setting j to the left son of k */\n        j <<= 1;\n      }\n      s.heap[k] = v;\n    }; // inlined manually\n    // const SMALLEST = 1;\n    /* ===========================================================================\n     * Send the block data compressed using the given Huffman trees\n     */\n    var compress_block = function compress_block(s, ltree, dtree\n    //    deflate_state *s;\n    //    const ct_data *ltree; /* literal tree */\n    //    const ct_data *dtree; /* distance tree */\n    ) {\n      var dist;\n      /* distance of matched string */\n      var lc;\n      /* match length or unmatched char (if dist == 0) */\n      var lx = 0;\n      /* running index in l_buf */\n      var code;\n      /* the code to send */\n      var extra;\n      /* number of extra bits to send */\n      if (s.last_lit !== 0) {\n        do {\n          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n          lc = s.pending_buf[s.l_buf + lx];\n          lx++;\n          if (dist === 0) {\n            send_code(s, lc, ltree);\n            /* send a literal byte */\n            // Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n          } else {\n            /* Here, lc is the match length - MIN_MATCH */\n            code = _length_code[lc];\n            send_code(s, code + LITERALS + 1, ltree);\n            /* send the length code */\n            extra = extra_lbits[code];\n            if (extra !== 0) {\n              lc -= base_length[code];\n              send_bits(s, lc, extra);\n              /* send the extra length bits */\n            }\n\n            dist--;\n            /* dist is now the match distance - 1 */\n            code = d_code(dist); // Assert (code < D_CODES, \"bad d_code\");\n            send_code(s, code, dtree);\n            /* send the distance code */\n            extra = extra_dbits[code];\n            if (extra !== 0) {\n              dist -= base_dist[code];\n              send_bits(s, dist, extra);\n              /* send the extra distance bits */\n            }\n          }\n          /* literal or match pair ? */\n          /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n          // Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n          //       \"pendingBuf overflow\");\n        } while (lx < s.last_lit);\n      }\n      send_code(s, END_BLOCK, ltree);\n    };\n    /* ===========================================================================\n     * Construct one Huffman tree and assigns the code bit strings and lengths.\n     * Update the total bit length for the current block.\n     * IN assertion: the field freq is set for all tree elements.\n     * OUT assertions: the fields len and code are set to the optimal bit length\n     *     and corresponding code. The length opt_len is updated; static_len is\n     *     also updated if stree is not null. The field max_code is set.\n     */\n    var build_tree = function build_tree(s, desc //    deflate_state *s; //    tree_desc *desc; /* the tree descriptor */\n    ) {\n      var tree = desc.dyn_tree;\n      var stree = desc.stat_desc.static_tree;\n      var has_stree = desc.stat_desc.has_stree;\n      var elems = desc.stat_desc.elems;\n      var n;\n      var m;\n      /* iterate over heap elements */\n      var max_code = -1;\n      /* largest code with non zero frequency */\n      var node;\n      /* new node being created */\n      /* Construct the initial heap, with least frequent element in\n       * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n       * heap[0] is not used.\n       */\n      s.heap_len = 0;\n      s.heap_max = HEAP_SIZE;\n      for (n = 0; n < elems; n++) {\n        if (tree[n * 2] !== /* .Freq */\n        0) {\n          s.heap[++s.heap_len] = max_code = n;\n          s.depth[n] = 0;\n        } else {\n          tree[n * 2 + 1] = /* .Len */\n          0;\n        }\n      }\n      /* The pkzip format requires that at least one distance code exists,\n       * and that at least one bit should be sent even if there is only one\n       * possible code. So to avoid special checks later on we force at least\n       * two codes of non zero frequency.\n       */\n      while (s.heap_len < 2) {\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n        tree[node * 2] = /* .Freq */\n        1;\n        s.depth[node] = 0;\n        s.opt_len--;\n        if (has_stree) {\n          s.static_len -= stree[node * 2 + 1];\n          /* .Len */\n        }\n        /* node is 0 or 1 so it does not have extra bits */\n      }\n\n      desc.max_code = max_code;\n      /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n       * establish sub-heaps of increasing lengths:\n       */\n      for (n = s.heap_len >> 1; /* int /2 */\n      n >= 1; n--) {\n        pqdownheap(s, tree, n);\n      }\n      /* Construct the Huffman tree by repeatedly combining the least two\n       * frequent nodes.\n       */\n      node = elems;\n      /* next internal node of the tree */\n      do {\n        // pqremove(s, tree, n);  /* n = node of least frequency */\n        /** * pqremove ** */\n        n = s.heap[1];\n        /* SMALLEST */\n        s.heap[1] = s.heap[s.heap_len--];\n        /* SMALLEST */\n        pqdownheap(s, tree, 1\n        /* SMALLEST */);\n        /***/\n        m = s.heap[1];\n        /* SMALLEST */\n        /* m = node of next least frequency */\n        s.heap[--s.heap_max] = n;\n        /* keep the nodes sorted by frequency */\n        s.heap[--s.heap_max] = m;\n        /* Create a new node father of n and m */\n        tree[node * 2] = /* .Freq */\n        tree[n * 2] + /* .Freq */\n        tree[m * 2];\n        /* .Freq */\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n        tree[n * 2 + 1] = /* .Dad */\n        tree[m * 2 + 1] = /* .Dad */\n        node;\n        /* and insert the new node in the heap */\n        s.heap[1] = node++;\n        /* SMALLEST */\n        pqdownheap(s, tree, 1\n        /* SMALLEST */);\n      } while (s.heap_len >= 2);\n      s.heap[--s.heap_max] = s.heap[1];\n      /* SMALLEST */\n      /* At this point, the fields freq and dad are set. We can now\n       * generate the bit lengths.\n       */\n      gen_bitlen(s, desc);\n      /* The field len is now set, we can generate the bit codes */\n      gen_codes(tree, max_code, s.bl_count);\n    };\n    /* ===========================================================================\n     * Scan a literal or distance tree to determine the frequencies of the codes\n     * in the bit length tree.\n     */\n    var scan_tree = function scan_tree(s, tree, max_code\n    //    deflate_state *s;\n    //    ct_data *tree;   /* the tree to be scanned */\n    //    int max_code;    /* and its largest code of non zero frequency */\n    ) {\n      var n;\n      /* iterates over all tree elements */\n      var prevlen = -1;\n      /* last emitted length */\n      var curlen;\n      /* length of current code */\n      var nextlen = tree[0 * 2 + 1];\n      /* .Len */\n      /* length of next code */\n      var count = 0;\n      /* repeat count of the current code */\n      var max_count = 7;\n      /* max repeat count */\n      var min_count = 4;\n      /* min repeat count */\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n      tree[(max_code + 1) * 2 + 1] = /* .Len */\n      0xffff;\n      /* guard */\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n        /* .Len */\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n        } else if (count < min_count) {\n          s.bl_tree[curlen * 2] += /* .Freq */\n          count;\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            s.bl_tree[curlen * 2] /* .Freq */++;\n          }\n\n          s.bl_tree[REP_3_6 * 2] /* .Freq */++;\n        } else if (count <= 10) {\n          s.bl_tree[REPZ_3_10 * 2] /* .Freq */++;\n        } else {\n          s.bl_tree[REPZ_11_138 * 2] /* .Freq */++;\n        }\n\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    };\n    /* ===========================================================================\n     * Send a literal or distance tree in compressed form, using the codes in\n     * bl_tree.\n     */\n    var send_tree = function send_tree(s, tree, max_code\n    //    deflate_state *s;\n    //    ct_data *tree; /* the tree to be scanned */\n    //    int max_code;       /* and its largest code of non zero frequency */\n    ) {\n      var n;\n      /* iterates over all tree elements */\n      var prevlen = -1;\n      /* last emitted length */\n      var curlen;\n      /* length of current code */\n      var nextlen = tree[0 * 2 + 1];\n      /* .Len */\n      /* length of next code */\n      var count = 0;\n      /* repeat count of the current code */\n      var max_count = 7;\n      /* max repeat count */\n      var min_count = 4;\n      /* min repeat count */\n      /* tree[max_code+1].Len = -1; */\n      /* guard already set */\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n        /* .Len */\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n        } else if (count < min_count) {\n          do {\n            send_code(s, curlen, s.bl_tree);\n          } while (--count !== 0);\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            send_code(s, curlen, s.bl_tree);\n            count--;\n          } // Assert(count >= 3 && count <= 6, \" 3_6?\");\n          send_code(s, REP_3_6, s.bl_tree);\n          send_bits(s, count - 3, 2);\n        } else if (count <= 10) {\n          send_code(s, REPZ_3_10, s.bl_tree);\n          send_bits(s, count - 3, 3);\n        } else {\n          send_code(s, REPZ_11_138, s.bl_tree);\n          send_bits(s, count - 11, 7);\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    };\n    /* ===========================================================================\n     * Construct the Huffman tree for the bit lengths and return the index in\n     * bl_order of the last bit length code to send.\n     */\n    var build_bl_tree = function build_bl_tree(s) {\n      var max_blindex;\n      /* index of last bit length code of non zero freq */\n      /* Determine the bit length frequencies for literal and distance trees */\n      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n      /* Build the bit length tree: */\n      build_tree(s, s.bl_desc);\n      /* opt_len now includes the length of the tree representations, except\n       * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n       */\n      /* Determine the number of bit length codes to send. The pkzip format\n       * requires that at least 4 bit length codes be sent. (appnote.txt says\n       * 3 but the actual value used is 4.)\n       */\n      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== /* .Len */\n        0) {\n          break;\n        }\n      }\n      /* Update opt_len to include the bit length tree and counts */\n      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; // Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n      //        s->opt_len, s->static_len));\n      return max_blindex;\n    };\n    /* ===========================================================================\n     * Send the header for a block using dynamic Huffman trees: the counts, the\n     * lengths of the bit length codes, the literal tree and the distance tree.\n     * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n     */\n    var send_all_trees = function send_all_trees(s, lcodes, dcodes, blcodes //    deflate_state *s; //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n    ) {\n      var rank;\n      /* index in bl_order */\n      // Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n      // Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n      //        \"too many codes\");\n      // Tracev((stderr, \"\\nbl counts: \"));\n      send_bits(s, lcodes - 257, 5);\n      /* not +255 as stated in appnote.txt */\n      send_bits(s, dcodes - 1, 5);\n      send_bits(s, blcodes - 4, 4);\n      /* not -3 as stated in appnote.txt */\n      for (rank = 0; rank < blcodes; rank++) {\n        // Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], /* .Len */\n        3);\n      } // Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n      send_tree(s, s.dyn_ltree, lcodes - 1);\n      /* literal tree */\n      // Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n      send_tree(s, s.dyn_dtree, dcodes - 1);\n      /* distance tree */\n      // Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n    };\n    /* ===========================================================================\n     * Check if the data type is TEXT or BINARY, using the following algorithm:\n     * - TEXT if the two conditions below are satisfied:\n     *    a) There are no non-portable control characters belonging to the\n     *       \"black list\" (0..6, 14..25, 28..31).\n     *    b) There is at least one printable character belonging to the\n     *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n     * - BINARY otherwise.\n     * - The following partially-portable control characters form a\n     *   \"gray list\" that is ignored in this detection algorithm:\n     *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n     * IN assertion: the fields Freq of dyn_ltree are set.\n     */\n    var detect_data_type = function detect_data_type(s) {\n      /* black_mask is the bit mask of black-listed bytes\n       * set bits 0..6, 14..25, and 28..31\n       * 0xf3ffc07f = binary 11110011111111111100000001111111\n       */\n      var black_mask = 0xf3ffc07f;\n      var n;\n      /* Check for non-textual (\"black-listed\") bytes. */\n      for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !== /* .Freq */\n        0) {\n          return Z_BINARY;\n        }\n      }\n      /* Check for textual (\"white-listed\") bytes. */\n      if (s.dyn_ltree[9 * 2] !== /* .Freq */\n      0 || s.dyn_ltree[10 * 2] !== /* .Freq */\n      0 || s.dyn_ltree[13 * 2] !== /* .Freq */\n      0) {\n        return Z_TEXT;\n      }\n      for (n = 32; n < LITERALS; n++) {\n        if (s.dyn_ltree[n * 2] !== /* .Freq */\n        0) {\n          return Z_TEXT;\n        }\n      }\n      /* There are no \"black-listed\" or \"white-listed\" bytes:\n       * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n       */\n      return Z_BINARY;\n    };\n    var static_init_done = false;\n    /* ===========================================================================\n     * Initialize the tree data structures for a new zlib stream.\n     */\n    var _tr_init = function _tr_init(s) {\n      if (!static_init_done) {\n        tr_static_init();\n        static_init_done = true;\n      }\n      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n      /* Initialize the first block of the first file: */\n      init_block(s);\n    };\n    /* ===========================================================================\n     * Send a stored block\n     */\n    var _tr_stored_block = function _tr_stored_block(s, buf, stored_len, last\n    // DeflateState *s;\n    // charf *buf;       /* input block */\n    // ulg stored_len;   /* length of input block */\n    // int last;         /* one if this is the last block for a file */\n    ) {\n      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n      /* send block type */\n      copy_block(s, buf, stored_len, true);\n      /* with header */\n    };\n    /* ===========================================================================\n     * Send one empty static block to give enough lookahead for inflate.\n     * This takes 10 bits, of which 7 may remain in the bit buffer.\n     */\n    var _tr_align = function _tr_align(s) {\n      send_bits(s, STATIC_TREES << 1, 3);\n      send_code(s, END_BLOCK, static_ltree);\n      bi_flush(s);\n    };\n    /* ===========================================================================\n     * Determine the best encoding for the current block: dynamic trees, static\n     * trees or store, and output the encoded block to the zip file.\n     */\n    var _tr_flush_block = function _tr_flush_block(s, buf, stored_len, last\n    // DeflateState *s;\n    // charf *buf;       /* input block, or NULL if too old */\n    // ulg stored_len;   /* length of input block */\n    // int last;         /* one if this is the last block for a file */\n    ) {\n      var opt_lenb;\n      var static_lenb;\n      /* opt_len and static_len in bytes */\n      var max_blindex = 0;\n      /* index of last bit length code of non zero freq */\n      /* Build the Huffman trees unless a stored block is forced */\n      if (s.level > 0) {\n        /* Check if the file is binary or text */\n        if (s.strm.data_type === Z_UNKNOWN) {\n          s.strm.data_type = detect_data_type(s);\n        }\n        /* Construct the literal and distance trees */\n        build_tree(s, s.l_desc); // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n        build_tree(s, s.d_desc); // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n        /* At this point, opt_len and static_len are the total bit lengths of\n         * the compressed block data, excluding the tree representations.\n         */\n        /* Build the bit length tree for the above two trees, and get the index\n         * in bl_order of the last bit length code to send.\n         */\n        max_blindex = build_bl_tree(s);\n        /* Determine the best encoding. Compute the block lengths in bytes. */\n        opt_lenb = s.opt_len + 3 + 7 >>> 3;\n        static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n        //        s->last_lit));\n        if (static_lenb <= opt_lenb) {\n          opt_lenb = static_lenb;\n        }\n      } else {\n        // Assert(buf != (char*)0, \"lost buf\");\n        opt_lenb = static_lenb = stored_len + 5;\n        /* force a stored block */\n      }\n\n      if (stored_len + 4 <= opt_lenb && buf !== -1) {\n        /* 4: two words for the lengths */\n        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         */\n        _tr_stored_block(s, buf, stored_len, last);\n      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n        compress_block(s, static_ltree, static_dtree);\n      } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n        compress_block(s, s.dyn_ltree, s.dyn_dtree);\n      } // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n      /* The above check is made mod 2^32, for files larger than 512 MB\n       * and uLong implemented on 32 bits.\n       */\n      init_block(s);\n      if (last) {\n        bi_windup(s);\n      } // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n      //       s->compressed_len-7*last));\n    };\n    /* ===========================================================================\n     * Save the match info and tally the frequency counts. Return true if\n     * the current block must be flushed.\n     */\n    var _tr_tally = function _tr_tally(s, dist, lc\n    //    deflate_state *s;\n    //    unsigned dist;  /* distance of matched string */\n    //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n    ) {\n      // let out_length, in_length, dcode;\n      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;\n      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n      s.last_lit++;\n      if (dist === 0) {\n        /* lc is the unmatched char */\n        s.dyn_ltree[lc * 2] /* .Freq */++;\n      } else {\n        s.matches++;\n        /* Here, lc is the match length - MIN_MATCH */\n        dist--;\n        /* dist = match distance - 1 */\n        // Assert((ush)dist < (ush)MAX_DIST(s) &&\n        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n        //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /* .Freq */++;\n        s.dyn_dtree[d_code(dist) * 2] /* .Freq */++;\n      } // (!) This block is disabled in zlib defaults,\n      // don't enable it for binary compatibility\n      // #ifdef TRUNCATE_BLOCK\n      //  /* Try to guess if it is profitable to stop the current block here */\n      //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n      //    /* Compute an upper bound for the compressed length */\n      //    out_length = s.last_lit*8;\n      //    in_length = s.strstart - s.block_start;\n      //\n      //    for (dcode = 0; dcode < D_CODES; dcode++) {\n      //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n      //    }\n      //    out_length >>>= 3;\n      //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n      //    //       s->last_lit, in_length, out_length,\n      //    //       100L - out_length*100L/in_length));\n      //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n      //      return true;\n      //    }\n      //  }\n      // #endif\n      return s.last_lit === s.lit_bufsize - 1;\n      /* We avoid equality with lit_bufsize because of wraparound at 64K\n       * on 16 bit machines and because stored blocks are restricted to\n       * 64K-1 bytes.\n       */\n    };\n\n    var _tr_init_1 = _tr_init;\n    var _tr_stored_block_1 = _tr_stored_block;\n    var _tr_flush_block_1 = _tr_flush_block;\n    var _tr_tally_1 = _tr_tally;\n    var _tr_align_1 = _tr_align;\n    var trees = {\n      _tr_init: _tr_init_1,\n      _tr_stored_block: _tr_stored_block_1,\n      _tr_flush_block: _tr_flush_block_1,\n      _tr_tally: _tr_tally_1,\n      _tr_align: _tr_align_1\n    };\n    // It isn't worth it to make additional optimizations as in original.\n    // Small size is preferable.\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n    var adler32 = function adler32(adler, buf, len, pos) {\n      var s1 = adler & 0xffff | 0;\n      var s2 = adler >>> 16 & 0xffff | 0;\n      var n = 0;\n      while (len !== 0) {\n        // Set limit ~ twice less than 5552, to keep\n        // s2 in 31-bits, because we force signed ints.\n        // in other case %= will fail.\n        n = len > 2000 ? 2000 : len;\n        len -= n;\n        do {\n          s1 = s1 + buf[pos++] | 0;\n          s2 = s2 + s1 | 0;\n        } while (--n);\n        s1 %= 65521;\n        s2 %= 65521;\n      }\n      return s1 | s2 << 16 | 0;\n    };\n    var adler32_1 = adler32;\n    // So write code to minimize size - no pregenerated tables\n    // and array tools dependencies.\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n    // Use ordinary array, since untyped makes no boost here\n    var makeTable = function makeTable() {\n      var c;\n      var table = [];\n      for (var n = 0; n < 256; n++) {\n        c = n;\n        for (var k = 0; k < 8; k++) {\n          c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;\n        }\n        table[n] = c;\n      }\n      return table;\n    }; // Create table on load. Just 255 signed longs. Not a problem.\n    var crcTable = new Uint32Array(makeTable());\n    var crc32 = function crc32(crc, buf, len, pos) {\n      var t = crcTable;\n      var end = pos + len;\n      crc ^= -1;\n      for (var i = pos; i < end; i++) {\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xff];\n      }\n      return crc ^ -1; // >>> 0;\n    };\n\n    var crc32_1 = crc32;\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n    var messages = {\n      2: 'need dictionary',\n      /* Z_NEED_DICT       2  */\n      1: 'stream end',\n      /* Z_STREAM_END      1  */\n      0: '',\n      /* Z_OK              0  */\n      '-1': 'file error',\n      /* Z_ERRNO         (-1) */\n      '-2': 'stream error',\n      /* Z_STREAM_ERROR  (-2) */\n      '-3': 'data error',\n      /* Z_DATA_ERROR    (-3) */\n      '-4': 'insufficient memory',\n      /* Z_MEM_ERROR     (-4) */\n      '-5': 'buffer error',\n      /* Z_BUF_ERROR     (-5) */\n      '-6': 'incompatible version'\n      /* Z_VERSION_ERROR (-6) */\n    };\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n    var constants = {\n      /* Allowed flush values; see deflate() and inflate() below for details */\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_TREES: 6,\n      /* Return codes for the compression/decompression functions. Negative values\n       * are errors, positive values are used for special but normal events.\n       */\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_MEM_ERROR: -4,\n      Z_BUF_ERROR: -5,\n      // Z_VERSION_ERROR: -6,\n      /* compression levels */\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n      /* Possible values of the data_type field (though see inflate()) */\n      Z_BINARY: 0,\n      Z_TEXT: 1,\n      // Z_ASCII:                1, // = Z_TEXT (deprecated)\n      Z_UNKNOWN: 2,\n      /* The deflate compression method */\n      Z_DEFLATED: 8 // Z_NULL:                 null // Use -1 or null inline, depending on var type\n    };\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n    var _tr_init$1 = trees._tr_init;\n    var _tr_stored_block$1 = trees._tr_stored_block;\n    var _tr_flush_block$1 = trees._tr_flush_block;\n    var _tr_tally$1 = trees._tr_tally;\n    var _tr_align$1 = trees._tr_align;\n    /* Public constants ========================================================== */\n    /* =========================================================================== */\n    var Z_NO_FLUSH = constants.Z_NO_FLUSH;\n    var Z_PARTIAL_FLUSH = constants.Z_PARTIAL_FLUSH;\n    var Z_FULL_FLUSH = constants.Z_FULL_FLUSH;\n    var Z_FINISH = constants.Z_FINISH;\n    var Z_BLOCK = constants.Z_BLOCK;\n    var Z_OK = constants.Z_OK;\n    var Z_STREAM_END = constants.Z_STREAM_END;\n    var Z_STREAM_ERROR = constants.Z_STREAM_ERROR;\n    var Z_DATA_ERROR = constants.Z_DATA_ERROR;\n    var Z_BUF_ERROR = constants.Z_BUF_ERROR;\n    var Z_DEFAULT_COMPRESSION = constants.Z_DEFAULT_COMPRESSION;\n    var Z_FILTERED = constants.Z_FILTERED;\n    var Z_HUFFMAN_ONLY = constants.Z_HUFFMAN_ONLY;\n    var Z_RLE = constants.Z_RLE;\n    var Z_FIXED$1 = constants.Z_FIXED;\n    var Z_DEFAULT_STRATEGY = constants.Z_DEFAULT_STRATEGY;\n    var Z_UNKNOWN$1 = constants.Z_UNKNOWN;\n    var Z_DEFLATED = constants.Z_DEFLATED;\n    /* ============================================================================ */\n    var MAX_MEM_LEVEL = 9;\n    /* Maximum value for memLevel in deflateInit2 */\n    var MAX_WBITS = 15;\n    /* 32K LZ77 window */\n    var DEF_MEM_LEVEL = 8;\n    var LENGTH_CODES$1 = 29;\n    /* number of length codes, not counting the special END_BLOCK code */\n    var LITERALS$1 = 256;\n    /* number of literal bytes 0..255 */\n    var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;\n    /* number of Literal or Length codes, including the END_BLOCK code */\n    var D_CODES$1 = 30;\n    /* number of distance codes */\n    var BL_CODES$1 = 19;\n    /* number of codes used to transfer the bit lengths */\n    var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;\n    /* maximum heap size */\n    var MAX_BITS$1 = 15;\n    /* All codes must not exceed MAX_BITS bits */\n    var MIN_MATCH$1 = 3;\n    var MAX_MATCH$1 = 258;\n    var MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1;\n    var PRESET_DICT = 0x20;\n    var INIT_STATE = 42;\n    var EXTRA_STATE = 69;\n    var NAME_STATE = 73;\n    var COMMENT_STATE = 91;\n    var HCRC_STATE = 103;\n    var BUSY_STATE = 113;\n    var FINISH_STATE = 666;\n    var BS_NEED_MORE = 1;\n    /* block not completed, need more input or more output */\n    var BS_BLOCK_DONE = 2;\n    /* block flush performed */\n    var BS_FINISH_STARTED = 3;\n    /* finish started, need only more output at next deflate */\n    var BS_FINISH_DONE = 4;\n    /* finish done, accept no more input or output */\n    var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n    var err = function err(strm, errorCode) {\n      strm.msg = messages[errorCode];\n      return errorCode;\n    };\n    var rank = function rank(f) {\n      return (f << 1) - (f > 4 ? 9 : 0);\n    };\n    var zero$1 = function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0) {\n        buf[len] = 0;\n      }\n    };\n    var HASH_ZLIB = function HASH_ZLIB(s, prev, data) {\n      return (prev << s.hash_shift ^ data) & s.hash_mask;\n    }; // This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n    // But breaks binary compatibility\n    // let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n    var HASH = HASH_ZLIB;\n    /* =========================================================================\n     * Flush as much pending output as possible. All deflate() output goes\n     * through this function so some applications may wish to modify it\n     * to avoid allocating a large strm->output buffer and copying into it.\n     * (See also read_buf()).\n     */\n    var flush_pending = function flush_pending(strm) {\n      var s = strm.state; // _tr_flush_bits(s);\n      var len = s.pending;\n      if (len > strm.avail_out) {\n        len = strm.avail_out;\n      }\n      if (len === 0) {\n        return;\n      }\n      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n      strm.next_out += len;\n      s.pending_out += len;\n      strm.total_out += len;\n      strm.avail_out -= len;\n      s.pending -= len;\n      if (s.pending === 0) {\n        s.pending_out = 0;\n      }\n    };\n    var flush_block_only = function flush_block_only(s, last) {\n      _tr_flush_block$1(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n      s.block_start = s.strstart;\n      flush_pending(s.strm);\n    };\n    var put_byte = function put_byte(s, b) {\n      s.pending_buf[s.pending++] = b;\n    };\n    /* =========================================================================\n     * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n     * IN assertion: the stream state is correct and there is enough room in\n     * pending_buf.\n     */\n    var putShortMSB = function putShortMSB(s, b) {\n      //  put_byte(s, (Byte)(b >> 8));\n      //  put_byte(s, (Byte)(b & 0xff));\n      s.pending_buf[s.pending++] = b >>> 8 & 0xff;\n      s.pending_buf[s.pending++] = b & 0xff;\n    };\n    /* ===========================================================================\n     * Read a new buffer from the current input stream, update the adler32\n     * and total number of bytes read.  All deflate() input goes through\n     * this function so some applications may wish to modify it to avoid\n     * allocating a large strm->input buffer and copying from it.\n     * (See also flush_pending()).\n     */\n    var read_buf = function read_buf(strm, buf, start, size) {\n      var len = strm.avail_in;\n      if (len > size) {\n        len = size;\n      }\n      if (len === 0) {\n        return 0;\n      }\n      strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);\n      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n      if (strm.state.wrap === 1) {\n        strm.adler = adler32_1(strm.adler, buf, len, start);\n      } else if (strm.state.wrap === 2) {\n        strm.adler = crc32_1(strm.adler, buf, len, start);\n      }\n      strm.next_in += len;\n      strm.total_in += len;\n      return len;\n    };\n    /* ===========================================================================\n     * Set match_start to the longest match starting at the given string and\n     * return its length. Matches shorter or equal to prev_length are discarded,\n     * in which case the result is equal to prev_length and match_start is\n     * garbage.\n     * IN assertions: cur_match is the head of the hash chain for the current\n     *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n     * OUT assertion: the match length is not greater than s->lookahead.\n     */\n    var longest_match = function longest_match(s, cur_match) {\n      var chain_length = s.max_chain_length;\n      /* max hash chain length */\n      var scan = s.strstart;\n      /* current string */\n      var match;\n      /* matched string */\n      var len;\n      /* length of current match */\n      var best_len = s.prev_length;\n      /* best match length so far */\n      var nice_match = s.nice_match;\n      /* stop if match long enough */\n      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;\n      /* NIL */\n      var _win = s.window; // shortcut\n      var wmask = s.w_mask;\n      var prev = s.prev;\n      /* Stop when cur_match becomes <= limit. To simplify the code,\n       * we prevent matches with the string of window index 0.\n       */\n      var strend = s.strstart + MAX_MATCH$1;\n      var scan_end1 = _win[scan + best_len - 1];\n      var scan_end = _win[scan + best_len];\n      /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n       * It is easy to get rid of this optimization if necessary.\n       */\n      // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n      /* Do not waste too much time if we already have a good match: */\n      if (s.prev_length >= s.good_match) {\n        chain_length >>= 2;\n      }\n      /* Do not look for matches beyond the end of the input. This is necessary\n       * to make deflate deterministic.\n       */\n      if (nice_match > s.lookahead) {\n        nice_match = s.lookahead;\n      } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n      do {\n        // Assert(cur_match < s->strstart, \"no future\");\n        match = cur_match;\n        /* Skip to next match if the match length cannot increase\n         * or if the match length is less than 2.  Note that the checks below\n         * for insufficient lookahead only occur occasionally for performance\n         * reasons.  Therefore uninitialized memory will be accessed, and\n         * conditional jumps will be made that depend on those values.\n         * However the length of the match is limited to the lookahead, so\n         * the output of deflate is not affected by the uninitialized values.\n         */\n        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n          continue;\n        }\n        /* The check at best_len-1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan[2] and match[2] since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         */\n        scan += 2;\n        match++; // Assert(*scan == *match, \"match[2]?\");\n        /* We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart+258.\n         */\n        do {\n          /* jshint noempty:false */\n        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n        len = MAX_MATCH$1 - (strend - scan);\n        scan = strend - MAX_MATCH$1;\n        if (len > best_len) {\n          s.match_start = cur_match;\n          best_len = len;\n          if (len >= nice_match) {\n            break;\n          }\n          scan_end1 = _win[scan + best_len - 1];\n          scan_end = _win[scan + best_len];\n        }\n      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n      if (best_len <= s.lookahead) {\n        return best_len;\n      }\n      return s.lookahead;\n    };\n    /* ===========================================================================\n     * Fill the window when the lookahead becomes insufficient.\n     * Updates strstart and lookahead.\n     *\n     * IN assertion: lookahead < MIN_LOOKAHEAD\n     * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n     *    At least one byte has been read, or avail_in == 0; reads are\n     *    performed for at least two bytes (required for the zip translate_eol\n     *    option -- not supported here).\n     */\n    var fill_window = function fill_window(s) {\n      var _w_size = s.w_size;\n      var p;\n      var n;\n      var m;\n      var more;\n      var str; // Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n      do {\n        more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed\n        /* Deal with !@#$% 64K limit: */\n        // if (sizeof(int) <= 2) {\n        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n        //        more = wsize;\n        //\n        //  } else if (more == (unsigned)(-1)) {\n        //        /* Very unlikely, but possible on 16 bit machine if\n        //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n        //         */\n        //        more--;\n        //    }\n        // }\n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n          s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n          s.match_start -= _w_size;\n          s.strstart -= _w_size;\n          /* we now have strstart >= MAX_DIST */\n          s.block_start -= _w_size;\n          /* Slide the hash table (could be avoided with 32 bit values\n          at the expense of memory usage). We slide even when level == 0\n          to keep the hash table consistent if we switch back to level > 0\n          later. (Using level 0 permanently is not an optimal usage of\n          zlib, so we don't care about this pathological case.)\n          */\n          n = s.hash_size;\n          p = n;\n          do {\n            m = s.head[--p];\n            s.head[p] = m >= _w_size ? m - _w_size : 0;\n          } while (--n);\n          n = _w_size;\n          p = n;\n          do {\n            m = s.prev[--p];\n            s.prev[p] = m >= _w_size ? m - _w_size : 0;\n            /* If n is not on any hash chain, prev[n] is garbage but\n             * its value will never be used.\n             */\n          } while (--n);\n          more += _w_size;\n        }\n        if (s.strm.avail_in === 0) {\n          break;\n        }\n        /* If there was no sliding:\n         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n         *    more == window_size - lookahead - strstart\n         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * => more >= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  &&\n         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more >= 2.\n         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n         */\n        // Assert(more >= 2, \"more < 2\");\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n        s.lookahead += n;\n        /* Initialize the hash value now that we have some input: */\n        if (s.lookahead + s.insert >= MIN_MATCH$1) {\n          str = s.strstart - s.insert;\n          s.ins_h = s.window[str];\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]); // #if MIN_MATCH != 3\n          //        Call update_hash() MIN_MATCH-3 more times\n          // #endif\n          while (s.insert) {\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n            s.insert--;\n            if (s.lookahead + s.insert < MIN_MATCH$1) {\n              break;\n            }\n          }\n        }\n        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         */\n      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n      /* If the WIN_INIT bytes after the end of the current data have never been\n       * written, then zero those bytes in order to avoid memory check reports of\n       * the use of uninitialized (or uninitialised as Julian writes) bytes by\n       * the longest match routines.  Update the high water mark for the next\n       * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n       * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n       */\n      //  if (s.high_water < s.window_size) {\n      //    const curr = s.strstart + s.lookahead;\n      //    let init = 0;\n      //\n      //    if (s.high_water < curr) {\n      //      /* Previous high water mark below current data -- zero WIN_INIT\n      //       * bytes or up to end of window, whichever is less.\n      //       */\n      //      init = s.window_size - curr;\n      //      if (init > WIN_INIT)\n      //        init = WIN_INIT;\n      //      zmemzero(s->window + curr, (unsigned)init);\n      //      s->high_water = curr + init;\n      //    }\n      //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n      //      /* High water mark at or above current data, but below current data\n      //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n      //       * to end of window, whichever is less.\n      //       */\n      //      init = (ulg)curr + WIN_INIT - s->high_water;\n      //      if (init > s->window_size - s->high_water)\n      //        init = s->window_size - s->high_water;\n      //      zmemzero(s->window + s->high_water, (unsigned)init);\n      //      s->high_water += init;\n      //    }\n      //  }\n      //\n      //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n      //    \"not enough room for search\");\n    };\n    /* ===========================================================================\n     * Copy without compression as much as possible from the input stream, return\n     * the current block state.\n     * This function does not insert new strings in the dictionary since\n     * uncompressible data is probably not useful. This function is used\n     * only for the level=0 compression option.\n     * NOTE: this function should be optimized to avoid extra copying from\n     * window to pending_buf.\n     */\n    var deflate_stored = function deflate_stored(s, flush) {\n      /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n       * to pending_buf_size, and each stored block has a 5 byte header:\n       */\n      var max_block_size = 0xffff;\n      if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5;\n      }\n      /* Copy as much as possible from input to output: */\n      for (;;) {\n        /* Fill the window as much as possible: */\n        if (s.lookahead <= 1) {\n          // Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n          //  s->block_start >= (long)s->w_size, \"slide too late\");\n          //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n          //        s.block_start >= s.w_size)) {\n          //        throw  new Error(\"slide too late\");\n          //      }\n          fill_window(s);\n          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n          /* flush the current block */\n        } // Assert(s->block_start >= 0L, \"block gone\");\n        //    if (s.block_start < 0) throw new Error(\"block gone\");\n        s.strstart += s.lookahead;\n        s.lookahead = 0;\n        /* Emit a stored block if pending_buf will be full: */\n        var max_start = s.block_start + max_block_size;\n        if (s.strstart === 0 || s.strstart >= max_start) {\n          /* strstart == 0 is possible when wraparound on 16-bit machine */\n          s.lookahead = s.strstart - max_start;\n          s.strstart = max_start;\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n        /* Flush if we may have to slide, otherwise block_start may become\n         * negative and the data will be gone:\n         */\n        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n      }\n\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n        return BS_FINISH_DONE;\n      }\n      if (s.strstart > s.block_start) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n      return BS_NEED_MORE;\n    };\n    /* ===========================================================================\n     * Compress as much as possible from the input stream, return the current\n     * block state.\n     * This function does not perform lazy evaluation of matches and inserts\n     * new strings in the dictionary only for unmatched strings or for short\n     * matches. It is used only for the fast compression options.\n     */\n    var deflate_fast = function deflate_fast(s, flush) {\n      var hash_head;\n      /* head of the hash chain */\n      var bflush;\n      /* set if current block must be flushed */\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n            /* flush the current block */\n          }\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        hash_head = 0;\n        /* NIL */\n        if (s.lookahead >= MIN_MATCH$1) {\n          /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n        if (hash_head !== 0 && /* NIL */\n        s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n          /* To simplify the code, we prevent matches with the string\n           * of window index 0 (in particular we have to avoid a match\n           * of the string with itself at the start of the input file).\n           */\n          s.match_length = longest_match(s, hash_head);\n          /* longest_match() sets match_start */\n        }\n\n        if (s.match_length >= MIN_MATCH$1) {\n          // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n          /** * _tr_tally_dist(s, s.strstart - s.match_start,\n                       s.match_length - MIN_MATCH, bflush); ** */\n          bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);\n          s.lookahead -= s.match_length;\n          /* Insert new strings in the hash table only if the match length\n           * is not too large. This saves time but degrades compression.\n           */\n          if (s.match_length <= s.max_lazy_match && /* max_insert_length */\n          s.lookahead >= MIN_MATCH$1) {\n            s.match_length--;\n            /* string at strstart already in table */\n            do {\n              s.strstart++;\n              /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n              /***/\n              /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n               * always MIN_MATCH bytes ahead.\n               */\n            } while (--s.match_length !== 0);\n            s.strstart++;\n          } else {\n            s.strstart += s.match_length;\n            s.match_length = 0;\n            s.ins_h = s.window[s.strstart];\n            /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]); // #if MIN_MATCH != 3\n            //                Call UPDATE_HASH() MIN_MATCH-3 more times\n            // #endif\n            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n             * matter since it will be recomputed at next deflate call.\n             */\n          }\n        } else {\n          /* No match, output a literal byte */\n          // Tracevv((stderr,\"%c\", s.window[s.strstart]));\n          /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n        }\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n      }\n\n      s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE;\n    };\n    /* ===========================================================================\n     * Same as above, but achieves better compression. We use a lazy\n     * evaluation for matches: a match is finally adopted only if there is\n     * no better match at the next window position.\n     */\n    var deflate_slow = function deflate_slow(s, flush) {\n      var hash_head;\n      /* head of hash chain */\n      var bflush;\n      /* set if current block must be flushed */\n      var max_insert;\n      /* Process the input block. */\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n          /* flush the current block */\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        hash_head = 0;\n        /* NIL */\n        if (s.lookahead >= MIN_MATCH$1) {\n          /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n        /* Find the longest match, discarding those <= prev_length.\n         */\n        s.prev_length = s.match_length;\n        s.prev_match = s.match_start;\n        s.match_length = MIN_MATCH$1 - 1;\n        if (hash_head !== 0 && /* NIL */\n        s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n        /* MAX_DIST(s) */) {\n          /* To simplify the code, we prevent matches with the string\n           * of window index 0 (in particular we have to avoid a match\n           * of the string with itself at the start of the input file).\n           */\n          s.match_length = longest_match(s, hash_head);\n          /* longest_match() sets match_start */\n          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096)\n          /* TOO_FAR */) {\n            /* If prev_match is also MIN_MATCH, match_start is garbage\n             * but we will ignore the current match anyway.\n             */\n            s.match_length = MIN_MATCH$1 - 1;\n          }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n        if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {\n          max_insert = s.strstart + s.lookahead - MIN_MATCH$1;\n          /* Do not insert strings in hash table beyond this. */\n          // check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n          /** *_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                       s.prev_length - MIN_MATCH, bflush);** */\n          bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);\n          /* Insert in hash table all strings up to the end of the match.\n           * strstart-1 and strstart are already inserted. If there is not\n           * enough lookahead, the last two strings are not inserted in\n           * the hash table.\n           */\n          s.lookahead -= s.prev_length - 1;\n          s.prev_length -= 2;\n          do {\n            if (++s.strstart <= max_insert) {\n              /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n              /***/\n            }\n          } while (--s.prev_length !== 0);\n          s.match_available = 0;\n          s.match_length = MIN_MATCH$1 - 1;\n          s.strstart++;\n          if (bflush) {\n            /** * FLUSH_BLOCK(s, 0); ** */\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n          }\n        } else if (s.match_available) {\n          /* If there was no match at the previous position, output a\n           * single literal. If there was a match but the current match\n           * is longer, truncate the previous match to a single literal.\n           */\n          // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n          /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);\n          if (bflush) {\n            /** * FLUSH_BLOCK_ONLY(s, 0) ** */\n            flush_block_only(s, false);\n            /***/\n          }\n\n          s.strstart++;\n          s.lookahead--;\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        } else {\n          /* There is no previous match to compare with, wait for\n           * the next step to decide.\n           */\n          s.match_available = 1;\n          s.strstart++;\n          s.lookahead--;\n        }\n      } // Assert (flush != Z_NO_FLUSH, \"no flush?\");\n      if (s.match_available) {\n        // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n        /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n        bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);\n        s.match_available = 0;\n      }\n      s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE;\n    };\n    /* ===========================================================================\n     * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n     * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n     * deflate switches away from Z_RLE.)\n     */\n    var deflate_rle = function deflate_rle(s, flush) {\n      var bflush;\n      /* set if current block must be flushed */\n      var prev;\n      /* byte at distance one to match */\n      var scan;\n      var strend;\n      /* scan goes up to strend for length of run */\n      var _win = s.window;\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the longest run, plus one for the unrolled loop.\n         */\n        if (s.lookahead <= MAX_MATCH$1) {\n          fill_window(s);\n          if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n          /* flush the current block */\n        }\n        /* See how many times the previous byte repeats */\n        s.match_length = 0;\n        if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {\n          scan = s.strstart - 1;\n          prev = _win[scan];\n          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n            strend = s.strstart + MAX_MATCH$1;\n            do {\n              /* jshint noempty:false */\n            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n            s.match_length = MAX_MATCH$1 - (strend - scan);\n            if (s.match_length > s.lookahead) {\n              s.match_length = s.lookahead;\n            }\n          } // Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n        }\n        /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n        if (s.match_length >= MIN_MATCH$1) {\n          // check_match(s, s.strstart, s.strstart - 1, s.match_length);\n          /** * _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ** */\n          bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1);\n          s.lookahead -= s.match_length;\n          s.strstart += s.match_length;\n          s.match_length = 0;\n        } else {\n          /* No match, output a literal byte */\n          // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n          /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n        }\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n      }\n\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE;\n    };\n    /* ===========================================================================\n     * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n     * (It will be regenerated if this run of deflate switches away from Huffman.)\n     */\n    var deflate_huff = function deflate_huff(s, flush) {\n      var bflush;\n      /* set if current block must be flushed */\n      for (;;) {\n        /* Make sure that we have a literal to write. */\n        if (s.lookahead === 0) {\n          fill_window(s);\n          if (s.lookahead === 0) {\n            if (flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n            break;\n            /* flush the current block */\n          }\n        }\n        /* Output a literal byte */\n        s.match_length = 0; // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n        bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n        s.lookahead--;\n        s.strstart++;\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n      }\n\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE;\n    };\n    /* Values for max_lazy_match, good_match and max_chain_length, depending on\n     * the desired pack level (0..9). The values given below have been tuned to\n     * exclude worst case performance for pathological files. Better values may be\n     * found for specific files.\n     */\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n      this.good_length = good_length;\n      this.max_lazy = max_lazy;\n      this.nice_length = nice_length;\n      this.max_chain = max_chain;\n      this.func = func;\n    }\n    var configuration_table = [/*      good lazy nice chain */\n    new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */\n    new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */\n    new Config(4, 5, 16, 8, deflate_fast), /* 2 */\n    new Config(4, 6, 32, 32, deflate_fast), /* 3 */\n    new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */\n    new Config(8, 16, 32, 32, deflate_slow), /* 5 */\n    new Config(8, 16, 128, 128, deflate_slow), /* 6 */\n    new Config(8, 32, 128, 256, deflate_slow), /* 7 */\n    new Config(32, 128, 258, 1024, deflate_slow), /* 8 */\n    new Config(32, 258, 258, 4096, deflate_slow)\n    /* 9 max compression */];\n    /* ===========================================================================\n     * Initialize the \"longest match\" routines for a new zlib stream\n     */\n    var lm_init = function lm_init(s) {\n      s.window_size = 2 * s.w_size;\n      /** * CLEAR_HASH(s); ** */\n      zero$1(s.head); // Fill with NIL (= 0);\n      /* Set the default configuration parameters:\n       */\n      s.max_lazy_match = configuration_table[s.level].max_lazy;\n      s.good_match = configuration_table[s.level].good_length;\n      s.nice_match = configuration_table[s.level].nice_length;\n      s.max_chain_length = configuration_table[s.level].max_chain;\n      s.strstart = 0;\n      s.block_start = 0;\n      s.lookahead = 0;\n      s.insert = 0;\n      s.match_length = s.prev_length = MIN_MATCH$1 - 1;\n      s.match_available = 0;\n      s.ins_h = 0;\n    };\n    function DeflateState() {\n      this.strm = null;\n      /* pointer back to this zlib stream */\n      this.status = 0;\n      /* as the name implies */\n      this.pending_buf = null;\n      /* output still pending */\n      this.pending_buf_size = 0;\n      /* size of pending_buf */\n      this.pending_out = 0;\n      /* next pending byte to output to the stream */\n      this.pending = 0;\n      /* nb of bytes in the pending buffer */\n      this.wrap = 0;\n      /* bit 0 true for zlib, bit 1 true for gzip */\n      this.gzhead = null;\n      /* gzip header information to write */\n      this.gzindex = 0;\n      /* where in extra, name, or comment */\n      this.method = Z_DEFLATED;\n      /* can only be DEFLATED */\n      this.last_flush = -1;\n      /* value of flush param for previous deflate call */\n      this.w_size = 0;\n      /* LZ77 window size (32K by default) */\n      this.w_bits = 0;\n      /* log2(w_size)  (8..16) */\n      this.w_mask = 0;\n      /* w_size - 1 */\n      this.window = null;\n      /* Sliding window. Input bytes are read into the second half of the window,\n       * and move to the first half later to keep a dictionary of at least wSize\n       * bytes. With this organization, matches are limited to a distance of\n       * wSize-MAX_MATCH bytes, but this ensures that IO is always\n       * performed with a length multiple of the block size.\n       */\n      this.window_size = 0;\n      /* Actual size of window: 2*wSize, except when the user input buffer\n       * is directly used as sliding window.\n       */\n      this.prev = null;\n      /* Link to older string with same hash index. To limit the size of this\n       * array to 64K, this link is maintained only for the last 32K strings.\n       * An index in this array is thus a window index modulo 32K.\n       */\n      this.head = null;\n      /* Heads of the hash chains or NIL. */\n      this.ins_h = 0;\n      /* hash index of string to be inserted */\n      this.hash_size = 0;\n      /* number of elements in hash table */\n      this.hash_bits = 0;\n      /* log2(hash_size) */\n      this.hash_mask = 0;\n      /* hash_size-1 */\n      this.hash_shift = 0;\n      /* Number of bits by which ins_h must be shifted at each input\n       * step. It must be such that after MIN_MATCH steps, the oldest\n       * byte no longer takes part in the hash key, that is:\n       *   hash_shift * MIN_MATCH >= hash_bits\n       */\n      this.block_start = 0;\n      /* Window position at the beginning of the current output block. Gets\n       * negative when the window is moved backwards.\n       */\n      this.match_length = 0;\n      /* length of best match */\n      this.prev_match = 0;\n      /* previous match */\n      this.match_available = 0;\n      /* set if previous match exists */\n      this.strstart = 0;\n      /* start of string to insert */\n      this.match_start = 0;\n      /* start of matching string */\n      this.lookahead = 0;\n      /* number of valid bytes ahead in window */\n      this.prev_length = 0;\n      /* Length of the best match at previous step. Matches not greater than this\n       * are discarded. This is used in the lazy match evaluation.\n       */\n      this.max_chain_length = 0;\n      /* To speed up deflation, hash chains are never searched beyond this\n       * length.  A higher limit improves compression ratio but degrades the\n       * speed.\n       */\n      this.max_lazy_match = 0;\n      /* Attempt to find a better match only when the current match is strictly\n       * smaller than this value. This mechanism is used only for compression\n       * levels >= 4.\n       */\n      // That's alias to max_lazy_match, don't use directly\n      // this.max_insert_length = 0;\n      /* Insert new strings in the hash table only if the match length is not\n       * greater than this length. This saves time but degrades compression.\n       * max_insert_length is used only for compression levels <= 3.\n       */\n      this.level = 0;\n      /* compression level (1..9) */\n      this.strategy = 0;\n      /* favor or force Huffman coding */\n      this.good_match = 0;\n      /* Use a faster search when the previous match is longer than this */\n      this.nice_match = 0;\n      /* Stop searching when current match exceeds this */\n      /* used by trees.c: */\n      /* Didn't use ct_data typedef below to suppress compiler warning */\n      // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n      // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n      // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n      // Use flat array of DOUBLE size, with interleaved fata,\n      // because JS does not support effective\n      this.dyn_ltree = new Uint16Array(HEAP_SIZE$1 * 2);\n      this.dyn_dtree = new Uint16Array((2 * D_CODES$1 + 1) * 2);\n      this.bl_tree = new Uint16Array((2 * BL_CODES$1 + 1) * 2);\n      zero$1(this.dyn_ltree);\n      zero$1(this.dyn_dtree);\n      zero$1(this.bl_tree);\n      this.l_desc = null;\n      /* desc. for literal tree */\n      this.d_desc = null;\n      /* desc. for distance tree */\n      this.bl_desc = null;\n      /* desc. for bit length tree */\n      // ush bl_count[MAX_BITS+1];\n      this.bl_count = new Uint16Array(MAX_BITS$1 + 1);\n      /* number of codes at each bit length for an optimal tree */\n      // int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n      this.heap = new Uint16Array(2 * L_CODES$1 + 1);\n      /* heap used to build the Huffman trees */\n      zero$1(this.heap);\n      this.heap_len = 0;\n      /* number of elements in the heap */\n      this.heap_max = 0;\n      /* element of largest frequency */\n      /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n       * The same heap array is used to build all trees.\n       */\n      this.depth = new Uint16Array(2 * L_CODES$1 + 1); // uch depth[2*L_CODES+1];\n      zero$1(this.depth);\n      /* Depth of each subtree used as tie breaker for trees of equal frequency\n       */\n      this.l_buf = 0;\n      /* buffer index for literals or lengths */\n      this.lit_bufsize = 0;\n      /* Size of match buffer for literals/lengths.  There are 4 reasons for\n       * limiting lit_bufsize to 64K:\n       *   - frequencies can be kept in 16 bit counters\n       *   - if compression is not successful for the first block, all input\n       *     data is still in the window so we can still emit a stored block even\n       *     when input comes from standard input.  (This can also be done for\n       *     all blocks if lit_bufsize is not greater than 32K.)\n       *   - if compression is not successful for a file smaller than 64K, we can\n       *     even emit a stored file instead of a stored block (saving 5 bytes).\n       *     This is applicable only for zip (not gzip or zlib).\n       *   - creating new Huffman trees less frequently may not provide fast\n       *     adaptation to changes in the input data statistics. (Take for\n       *     example a binary file with poorly compressible code followed by\n       *     a highly compressible string table.) Smaller buffer sizes give\n       *     fast adaptation but have of course the overhead of transmitting\n       *     trees more frequently.\n       *   - I can't count above 4\n       */\n      this.last_lit = 0;\n      /* running index in l_buf */\n      this.d_buf = 0;\n      /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n       * the same number of elements. To use different lengths, an extra flag\n       * array would be necessary.\n       */\n      this.opt_len = 0;\n      /* bit length of current block with optimal trees */\n      this.static_len = 0;\n      /* bit length of current block with static trees */\n      this.matches = 0;\n      /* number of string matches in current block */\n      this.insert = 0;\n      /* bytes at end of window left to insert */\n      this.bi_buf = 0;\n      /* Output buffer. bits are inserted starting at the bottom (least\n       * significant bits).\n       */\n      this.bi_valid = 0;\n      /* Number of valid bits in bi_buf.  All bits above the last valid bit\n       * are always zero.\n       */\n      // Used for window memory init. We safely ignore it for JS. That makes\n      // sense only for pointers and memory check tools.\n      // this.high_water = 0;\n      /* High water mark offset in window for initialized bytes -- bytes above\n       * this are set to zero in order to avoid memory check warnings when\n       * longest match routines access bytes past the input.  This is then\n       * updated to the new high water mark.\n       */\n    }\n\n    var deflateResetKeep = function deflateResetKeep(strm) {\n      if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n      strm.total_in = strm.total_out = 0;\n      strm.data_type = Z_UNKNOWN$1;\n      var s = strm.state;\n      s.pending = 0;\n      s.pending_out = 0;\n      if (s.wrap < 0) {\n        s.wrap = -s.wrap;\n        /* was made negative by deflate(..., Z_FINISH); */\n      }\n\n      s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n      strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)\n      : 1; // adler32(0, Z_NULL, 0)\n      s.last_flush = Z_NO_FLUSH;\n      _tr_init$1(s);\n      return Z_OK;\n    };\n    var deflateReset = function deflateReset(strm) {\n      var ret = deflateResetKeep(strm);\n      if (ret === Z_OK) {\n        lm_init(strm.state);\n      }\n      return ret;\n    };\n    var deflateSetHeader = function deflateSetHeader(strm, head) {\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      if (strm.state.wrap !== 2) {\n        return Z_STREAM_ERROR;\n      }\n      strm.state.gzhead = head;\n      return Z_OK;\n    };\n    var deflateInit2 = function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n      if (!strm) {\n        // === Z_NULL\n        return Z_STREAM_ERROR;\n      }\n      var wrap = 1;\n      if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6;\n      }\n      if (windowBits < 0) {\n        /* suppress zlib wrapper */\n        wrap = 0;\n        windowBits = -windowBits;\n      } else if (windowBits > 15) {\n        wrap = 2;\n        /* write gzip wrapper instead */\n        windowBits -= 16;\n      }\n      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED$1) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n      if (windowBits === 8) {\n        windowBits = 9;\n      }\n      /* until 256-byte window bug fixed */\n      var s = new DeflateState();\n      strm.state = s;\n      s.strm = strm;\n      s.wrap = wrap;\n      s.gzhead = null;\n      s.w_bits = windowBits;\n      s.w_size = 1 << s.w_bits;\n      s.w_mask = s.w_size - 1;\n      s.hash_bits = memLevel + 7;\n      s.hash_size = 1 << s.hash_bits;\n      s.hash_mask = s.hash_size - 1;\n      s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);\n      s.window = new Uint8Array(s.w_size * 2);\n      s.head = new Uint16Array(s.hash_size);\n      s.prev = new Uint16Array(s.w_size); // Don't need mem init magic for JS.\n      // s.high_water = 0;  /* nothing written to s->window yet */\n      s.lit_bufsize = 1 << memLevel + 6;\n      /* 16K elements by default */\n      s.pending_buf_size = s.lit_bufsize * 4;\n      // overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n      // s->pending_buf = (uchf *) overlay;\n      // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n      s.pending_buf = new Uint8Array(s.pending_buf_size);\n      // s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n      s.d_buf = 1 * s.lit_bufsize; // s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n      s.l_buf = (1 + 2) * s.lit_bufsize;\n      s.level = level;\n      s.strategy = strategy;\n      s.method = method;\n      return deflateReset(strm);\n    };\n    var deflateInit = function deflateInit(strm, level) {\n      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n    };\n    var deflate = function deflate(strm, flush) {\n      var beg;\n      var val; // for gzip header write only\n      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n      }\n      var s = strm.state;\n      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {\n        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n      }\n      s.strm = strm;\n      /* just in case */\n      var old_flush = s.last_flush;\n      s.last_flush = flush;\n      /* Write the header */\n      if (s.status === INIT_STATE) {\n        if (s.wrap === 2) {\n          // GZIP header\n          strm.adler = 0; // crc32(0L, Z_NULL, 0);\n          put_byte(s, 31);\n          put_byte(s, 139);\n          put_byte(s, 8);\n          if (!s.gzhead) {\n            // s->gzhead == Z_NULL\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n            put_byte(s, OS_CODE);\n            s.status = BUSY_STATE;\n          } else {\n            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n            put_byte(s, s.gzhead.time & 0xff);\n            put_byte(s, s.gzhead.time >> 8 & 0xff);\n            put_byte(s, s.gzhead.time >> 16 & 0xff);\n            put_byte(s, s.gzhead.time >> 24 & 0xff);\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n            put_byte(s, s.gzhead.os & 0xff);\n            if (s.gzhead.extra && s.gzhead.extra.length) {\n              put_byte(s, s.gzhead.extra.length & 0xff);\n              put_byte(s, s.gzhead.extra.length >> 8 & 0xff);\n            }\n            if (s.gzhead.hcrc) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n            }\n            s.gzindex = 0;\n            s.status = EXTRA_STATE;\n          }\n        } // DEFLATE header\n        else {\n          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n          var level_flags = -1;\n          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n            level_flags = 0;\n          } else if (s.level < 6) {\n            level_flags = 1;\n          } else if (s.level === 6) {\n            level_flags = 2;\n          } else {\n            level_flags = 3;\n          }\n          header |= level_flags << 6;\n          if (s.strstart !== 0) {\n            header |= PRESET_DICT;\n          }\n          header += 31 - header % 31;\n          s.status = BUSY_STATE;\n          putShortMSB(s, header);\n          /* Save the adler32 of the preset dictionary: */\n          if (s.strstart !== 0) {\n            putShortMSB(s, strm.adler >>> 16);\n            putShortMSB(s, strm.adler & 0xffff);\n          }\n          strm.adler = 1; // adler32(0L, Z_NULL, 0);\n        }\n      } // #ifdef GZIP\n      if (s.status === EXTRA_STATE) {\n        if (s.gzhead.extra\n        /* != Z_NULL */) {\n          beg = s.pending;\n          /* start of bytes to update crc */\n          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                break;\n              }\n            }\n            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n            s.gzindex++;\n          }\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (s.gzindex === s.gzhead.extra.length) {\n            s.gzindex = 0;\n            s.status = NAME_STATE;\n          }\n        } else {\n          s.status = NAME_STATE;\n        }\n      }\n      if (s.status === NAME_STATE) {\n        if (s.gzhead.name\n        /* != Z_NULL */) {\n          beg = s.pending;\n          /* start of bytes to update crc */\n          // int val;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            } // JS specific: little magic to add zero terminator to end of string\n            if (s.gzindex < s.gzhead.name.length) {\n              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n            } else {\n              val = 0;\n            }\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (val === 0) {\n            s.gzindex = 0;\n            s.status = COMMENT_STATE;\n          }\n        } else {\n          s.status = COMMENT_STATE;\n        }\n      }\n      if (s.status === COMMENT_STATE) {\n        if (s.gzhead.comment\n        /* != Z_NULL */) {\n          beg = s.pending;\n          /* start of bytes to update crc */\n          // int val;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            } // JS specific: little magic to add zero terminator to end of string\n            if (s.gzindex < s.gzhead.comment.length) {\n              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n            } else {\n              val = 0;\n            }\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (val === 0) {\n            s.status = HCRC_STATE;\n          }\n        } else {\n          s.status = HCRC_STATE;\n        }\n      }\n      if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n          if (s.pending + 2 > s.pending_buf_size) {\n            flush_pending(strm);\n          }\n          if (s.pending + 2 <= s.pending_buf_size) {\n            put_byte(s, strm.adler & 0xff);\n            put_byte(s, strm.adler >> 8 & 0xff);\n            strm.adler = 0; // crc32(0L, Z_NULL, 0);\n            s.status = BUSY_STATE;\n          }\n        } else {\n          s.status = BUSY_STATE;\n        }\n      } // #endif\n      /* Flush as much pending output as possible */\n      if (s.pending !== 0) {\n        flush_pending(strm);\n        if (strm.avail_out === 0) {\n          /* Since avail_out is 0, deflate will be called again with\n           * more output space, but possibly with both pending and\n           * avail_in equal to zero. There won't be anything to do,\n           * but this is not an error situation so make sure we\n           * return OK instead of BUF_ERROR at next call of deflate:\n           */\n          s.last_flush = -1;\n          return Z_OK;\n        }\n        /* Make sure there is something to do and avoid duplicate consecutive\n         * flushes. For repeated and useless calls with Z_FINISH, we keep\n         * returning Z_STREAM_END instead of Z_BUF_ERROR.\n         */\n      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR);\n      }\n      /* User must not provide more input after the first FINISH: */\n      if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR);\n      }\n      /* Start a new block or continue the current one.\n       */\n      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n          s.status = FINISH_STATE;\n        }\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n            /* avoid BUF_ERROR next call, see above */\n          }\n\n          return Z_OK;\n          /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n           * of deflate should use the same flush parameter to make sure\n           * that the flush is complete. So we don't have to output an\n           * empty block here, this will be done at next call. This also\n           * ensures that for a very small output buffer, we emit at most\n           * one empty block.\n           */\n        }\n\n        if (bstate === BS_BLOCK_DONE) {\n          if (flush === Z_PARTIAL_FLUSH) {\n            _tr_align$1(s);\n          } else if (flush !== Z_BLOCK) {\n            /* FULL_FLUSH or SYNC_FLUSH */\n            _tr_stored_block$1(s, 0, 0, false);\n            /* For a full flush, this empty block will be recognized\n             * as a special marker by inflate_sync().\n             */\n            if (flush === Z_FULL_FLUSH) {\n              /** * CLEAR_HASH(s); ** */\n              /* forget history */\n              zero$1(s.head); // Fill with NIL (= 0);\n              if (s.lookahead === 0) {\n                s.strstart = 0;\n                s.block_start = 0;\n                s.insert = 0;\n              }\n            }\n          }\n          flush_pending(strm);\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n            /* avoid BUF_ERROR at next call, see above */\n            return Z_OK;\n          }\n        }\n      } // Assert(strm->avail_out > 0, \"bug2\");\n      // if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n      if (flush !== Z_FINISH) {\n        return Z_OK;\n      }\n      if (s.wrap <= 0) {\n        return Z_STREAM_END;\n      }\n      /* Write the trailer */\n      if (s.wrap === 2) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, strm.adler >> 8 & 0xff);\n        put_byte(s, strm.adler >> 16 & 0xff);\n        put_byte(s, strm.adler >> 24 & 0xff);\n        put_byte(s, strm.total_in & 0xff);\n        put_byte(s, strm.total_in >> 8 & 0xff);\n        put_byte(s, strm.total_in >> 16 & 0xff);\n        put_byte(s, strm.total_in >> 24 & 0xff);\n      } else {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      flush_pending(strm);\n      /* If avail_out is zero, the application will call deflate again\n       * to flush the rest.\n       */\n      if (s.wrap > 0) {\n        s.wrap = -s.wrap;\n      }\n      /* write the trailer only once! */\n      return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n    };\n    var deflateEnd = function deflateEnd(strm) {\n      if (!strm || /* == Z_NULL */\n      !strm.state\n      /* == Z_NULL */) {\n        return Z_STREAM_ERROR;\n      }\n      var status = strm.state.status;\n      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n      strm.state = null;\n      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n    };\n    /* =========================================================================\n     * Initializes the compression dictionary from the given byte\n     * sequence without producing any compressed output.\n     */\n    var deflateSetDictionary = function deflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length;\n      if (!strm || /* == Z_NULL */\n      !strm.state\n      /* == Z_NULL */) {\n        return Z_STREAM_ERROR;\n      }\n      var s = strm.state;\n      var wrap = s.wrap;\n      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n        return Z_STREAM_ERROR;\n      }\n      /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n      if (wrap === 1) {\n        /* adler32(strm->adler, dictionary, dictLength); */\n        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n      }\n      s.wrap = 0;\n      /* avoid computing Adler-32 in read_buf */\n      /* if dictionary would fill window, just replace the history */\n      if (dictLength >= s.w_size) {\n        if (wrap === 0) {\n          /* already empty otherwise */\n          /** * CLEAR_HASH(s); ** */\n          zero$1(s.head); // Fill with NIL (= 0);\n          s.strstart = 0;\n          s.block_start = 0;\n          s.insert = 0;\n        }\n        /* use the tail */\n        // dictionary = dictionary.slice(dictLength - s.w_size);\n        var tmpDict = new Uint8Array(s.w_size);\n        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n        dictionary = tmpDict;\n        dictLength = s.w_size;\n      }\n      /* insert dictionary into window and hash */\n      var avail = strm.avail_in;\n      var next = strm.next_in;\n      var input = strm.input;\n      strm.avail_in = dictLength;\n      strm.next_in = 0;\n      strm.input = dictionary;\n      fill_window(s);\n      while (s.lookahead >= MIN_MATCH$1) {\n        var str = s.strstart;\n        var n = s.lookahead - (MIN_MATCH$1 - 1);\n        do {\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);\n          s.prev[str & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = str;\n          str++;\n        } while (--n);\n        s.strstart = str;\n        s.lookahead = MIN_MATCH$1 - 1;\n        fill_window(s);\n      }\n      s.strstart += s.lookahead;\n      s.block_start = s.strstart;\n      s.insert = s.lookahead;\n      s.lookahead = 0;\n      s.match_length = s.prev_length = MIN_MATCH$1 - 1;\n      s.match_available = 0;\n      strm.next_in = next;\n      strm.input = input;\n      strm.avail_in = avail;\n      s.wrap = wrap;\n      return Z_OK;\n    };\n    var deflateInit_1 = deflateInit;\n    var deflateInit2_1 = deflateInit2;\n    var deflateReset_1 = deflateReset;\n    var deflateResetKeep_1 = deflateResetKeep;\n    var deflateSetHeader_1 = deflateSetHeader;\n    var deflate_2 = deflate;\n    var deflateEnd_1 = deflateEnd;\n    var deflateSetDictionary_1 = deflateSetDictionary;\n    var deflateInfo = 'pako deflate (from Nodeca project)';\n    /* Not implemented\n    module.exports.deflateBound = deflateBound;\n    module.exports.deflateCopy = deflateCopy;\n    module.exports.deflateParams = deflateParams;\n    module.exports.deflatePending = deflatePending;\n    module.exports.deflatePrime = deflatePrime;\n    module.exports.deflateTune = deflateTune;\n    */\n    var deflate_1 = {\n      deflateInit: deflateInit_1,\n      deflateInit2: deflateInit2_1,\n      deflateReset: deflateReset_1,\n      deflateResetKeep: deflateResetKeep_1,\n      deflateSetHeader: deflateSetHeader_1,\n      deflate: deflate_2,\n      deflateEnd: deflateEnd_1,\n      deflateSetDictionary: deflateSetDictionary_1,\n      deflateInfo: deflateInfo\n    };\n    // Join array of chunks to single array.\n    function flattenChunks(chunks) {\n      // calculate data length\n      var len = 0;\n      for (var i = 0, l = chunks.length; i < l; i++) {\n        len += chunks[i].length;\n      } // join chunks\n      var result = new Uint8Array(len);\n      for (var _i = 0, pos = 0, _l = chunks.length; _i < _l; _i++) {\n        var chunk = chunks[_i];\n        result.set(chunk, pos);\n        pos += chunk.length;\n      }\n      return result;\n    }\n    // String encode/decode helpers\n    //\n    // - apply(Array) can fail on Android 2.2\n    // - apply(Uint8Array) can fail on iOS 5.1 Safari\n    //\n    // Table with utf8 lengths (calculated by first byte of sequence)\n    // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n    // because max possible codepoint is 0x10ffff\n    var _utf8len = new Uint8Array(256);\n    for (var q = 0; q < 256; q++) {\n      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n    }\n    _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n    // convert string to array (typed, when possible)\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n    function ZStream() {\n      /* next input byte */\n      this.input = null; // JS specific, because we have no pointers\n      this.next_in = 0;\n      /* number of bytes available at input */\n      this.avail_in = 0;\n      /* total number of input bytes read so far */\n      this.total_in = 0;\n      /* next output byte should be put there */\n      this.output = null; // JS specific, because we have no pointers\n      this.next_out = 0;\n      /* remaining free space at output */\n      this.avail_out = 0;\n      /* total number of bytes output so far */\n      this.total_out = 0;\n      /* last error message, NULL if no error */\n      this.msg = '';\n      /* Z_NULL */\n      /* not visible by applications */\n      this.state = null;\n      /* best guess about the data type: binary or text */\n      this.data_type = 2;\n      /* Z_UNKNOWN */\n      /* adler32 value of the uncompressed data */\n      this.adler = 0;\n    }\n    var zstream = ZStream;\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    var toString = Object.prototype.toString;\n    /* Public constants ========================================================== */\n    /* =========================================================================== */\n    var Z_NO_FLUSH$1 = constants.Z_NO_FLUSH;\n    var Z_SYNC_FLUSH = constants.Z_SYNC_FLUSH;\n    var Z_FULL_FLUSH$1 = constants.Z_FULL_FLUSH;\n    var Z_FINISH$1 = constants.Z_FINISH;\n    var Z_OK$1 = constants.Z_OK;\n    var Z_STREAM_END$1 = constants.Z_STREAM_END;\n    var Z_DEFAULT_COMPRESSION$1 = constants.Z_DEFAULT_COMPRESSION;\n    var Z_DEFAULT_STRATEGY$1 = constants.Z_DEFAULT_STRATEGY;\n    var Z_DEFLATED$1 = constants.Z_DEFLATED;\n    /* =========================================================================== */\n    /**\n     * class Deflate\n     *\n     * Generic JS-style wrapper for zlib calls. If you don't need\n     * streaming behaviour - use more simple functions: [[deflate]],\n     * [[deflateRaw]] and [[gzip]].\n     * */\n    /* internal\n     * Deflate.chunks -> Array\n     *\n     * Chunks of output data, if [[Deflate#onData]] not overridden.\n     * */\n    /**\n     * Deflate.result -> Uint8Array\n     *\n     * Compressed result, generated by default [[Deflate#onData]]\n     * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n     * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n     * */\n    /**\n     * Deflate.err -> Number\n     *\n     * Error code after deflate finished. 0 (Z_OK) on success.\n     * You will not need it in real life, because deflate errors\n     * are possible only on wrong options or bad `onData` / `onEnd`\n     * custom handlers.\n     * */\n    /**\n     * Deflate.msg -> String\n     *\n     * Error message, if [[Deflate.err]] != 0\n     * */\n    /**\n     * new Deflate(options)\n     * - options (Object): zlib deflate options.\n     *\n     * Creates new deflator instance with specified params. Throws exception\n     * on bad params. Supported options:\n     *\n     * - `level`\n     * - `windowBits`\n     * - `memLevel`\n     * - `strategy`\n     * - `dictionary`\n     *\n     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n     * for more information on these.\n     *\n     * Additional options, for internal needs:\n     *\n     * * `chunkSize` - size of generated data chunks (16K by default)\n     * * `raw` (Boolean) - do raw deflate\n     * * `gzip` (Boolean) - create gzip wrapper\n     * * `header` (Object) - custom header for gzip\n     * ** `text` (Boolean) - true if compressed data believed to be text\n     * ** `time` (Number) - modification time, unix timestamp\n     * ** `os` (Number) - operation system code\n     * ** `extra` (Array) - array of bytes with extra data (max 65536)\n     * ** `name` (String) - file name (binary string)\n     * ** `comment` (String) - comment (binary string)\n     * ** `hcrc` (Boolean) - true if header crc should be added\n     *\n     * ##### Example:\n     *\n     * ```javascript\n     * const pako = require('pako')\n     *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n     *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n     *\n     * const deflate = new pako.Deflate({ level: 3});\n     *\n     * deflate.push(chunk1, false);\n     * deflate.push(chunk2, true);  // true -> last chunk\n     *\n     * if (deflate.err) { throw new Error(deflate.err); }\n     *\n     * console.log(deflate.result);\n     * ```\n     * */\n    function Deflate() {\n      this.options = {\n        level: Z_DEFAULT_COMPRESSION$1,\n        method: Z_DEFLATED$1,\n        chunkSize: 16384,\n        windowBits: 15,\n        memLevel: 8,\n        strategy: Z_DEFAULT_STRATEGY$1\n      };\n      var opt = this.options;\n      if (opt.raw && opt.windowBits > 0) {\n        opt.windowBits = -opt.windowBits;\n      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n        opt.windowBits += 16;\n      }\n      this.err = 0; // error code, if happens (0 = Z_OK)\n      this.msg = ''; // error message\n      this.ended = false; // used to avoid multiple onEnd() calls\n      this.chunks = []; // chunks of compressed data\n      this.strm = new zstream();\n      this.strm.avail_out = 0;\n      var status = deflate_1.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n      if (status !== Z_OK$1) {\n        throw new Error(messages[status]);\n      }\n      if (opt.header) {\n        deflate_1.deflateSetHeader(this.strm, opt.header);\n      }\n      if (opt.dictionary) {\n        var dict; // Convert data if needed\n        if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n          dict = new Uint8Array(opt.dictionary);\n        } else {\n          dict = opt.dictionary;\n        }\n        status = deflate_1.deflateSetDictionary(this.strm, dict);\n        if (status !== Z_OK$1) {\n          throw new Error(messages[status]);\n        }\n        this._dict_set = true;\n      }\n    }\n    /**\n     * Deflate#push(data[, flush_mode]) -> Boolean\n     * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n     * converted to utf8 byte sequence.\n     * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n     * See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n     *\n     * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n     * new compressed chunks. Returns `true` on success. The last data block must\n     * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n     * buffers and call [[Deflate#onEnd]].\n     *\n     * On fail call [[Deflate#onEnd]] with error code and return false.\n     *\n     * ##### Example\n     *\n     * ```javascript\n     * push(chunk, false); // push one of data chunks\n     * ...\n     * push(chunk, true);  // push last chunk\n     * ```\n     * */\n    Deflate.prototype.push = function (data, flush_mode) {\n      var strm = this.strm;\n      var chunkSize = this.options.chunkSize;\n      var status;\n      var _flush_mode;\n      if (this.ended) {\n        return false;\n      }\n      if (flush_mode === ~~flush_mode) {\n        _flush_mode = flush_mode;\n      } else {\n        _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1;\n      } // Convert data if needed\n      if (toString.call(data) === '[object ArrayBuffer]') {\n        strm.input = new Uint8Array(data);\n      } else {\n        strm.input = data;\n      }\n      strm.next_in = 0;\n      strm.avail_in = strm.input.length;\n      for (;;) {\n        if (strm.avail_out === 0) {\n          strm.output = new Uint8Array(chunkSize);\n          strm.next_out = 0;\n          strm.avail_out = chunkSize;\n        } // Make sure avail_out > 6 to avoid repeating markers\n        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {\n          this.onData(strm.output.subarray(0, strm.next_out));\n          strm.avail_out = 0;\n          continue;\n        }\n        status = deflate_1.deflate(strm, _flush_mode); // Ended => flush and finish\n        if (status === Z_STREAM_END$1) {\n          if (strm.next_out > 0) {\n            this.onData(strm.output.subarray(0, strm.next_out));\n          }\n          status = deflate_1.deflateEnd(this.strm);\n          this.onEnd(status);\n          this.ended = true;\n          return status === Z_OK$1;\n        } // Flush if out buffer full\n        if (strm.avail_out === 0) {\n          this.onData(strm.output);\n          continue;\n        } // Flush if requested and has data\n        if (_flush_mode > 0 && strm.next_out > 0) {\n          this.onData(strm.output.subarray(0, strm.next_out));\n          strm.avail_out = 0;\n          continue;\n        }\n        if (strm.avail_in === 0) {\n          break;\n        }\n      }\n      return true;\n    };\n    /**\n     * Deflate#onData(chunk) -> Void\n     * - chunk (Uint8Array): output data.\n     *\n     * By default, stores data blocks in `chunks[]` property and glue\n     * those in `onEnd`. Override this handler, if you need another behaviour.\n     * */\n    Deflate.prototype.onData = function (chunk) {\n      this.chunks.push(chunk);\n    };\n    /**\n     * Deflate#onEnd(status) -> Void\n     * - status (Number): deflate status. 0 (Z_OK) on success,\n     * other if not.\n     *\n     * Called once after you tell deflate that the input stream is\n     * complete (Z_FINISH). By default - join collected chunks,\n     * free memory and fill `results` / `err` properties.\n     * */\n    Deflate.prototype.onEnd = function (status) {\n      // On success - join\n      if (status === Z_OK$1) {\n        this.result = flattenChunks(this.chunks);\n      }\n      this.chunks = [];\n      this.err = status;\n      this.msg = this.strm.msg;\n    };\n    // https://github.com/nodeca/pako/blob/26dff4fb3472c5532b3bd8856421146d35ab7592/lib/utils/strings.js#L26\n    function string2buf(str) {\n      if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n        return new TextEncoder().encode(str);\n      }\n      var buf;\n      var c;\n      var c2;\n      var m_pos;\n      var i;\n      var str_len = str.length;\n      var buf_len = 0;\n      // count binary size\n      for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n          c2 = str.charCodeAt(m_pos + 1);\n          if ((c2 & 0xfc00) === 0xdc00) {\n            c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n            m_pos++;\n          }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n      }\n      // allocate buffer\n      buf = new Uint8Array(buf_len);\n      // convert\n      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n          c2 = str.charCodeAt(m_pos + 1);\n          if ((c2 & 0xfc00) === 0xdc00) {\n            c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n            m_pos++;\n          }\n        }\n        if (c < 0x80) {\n          /* one byte */\n          buf[i++] = c;\n        } else if (c < 0x800) {\n          /* two bytes */\n          buf[i++] = 0xc0 | c >>> 6;\n          buf[i++] = 0x80 | c & 0x3f;\n        } else if (c < 0x10000) {\n          /* three bytes */\n          buf[i++] = 0xe0 | c >>> 12;\n          buf[i++] = 0x80 | c >>> 6 & 0x3f;\n          buf[i++] = 0x80 | c & 0x3f;\n        } else {\n          /* four bytes */\n          buf[i++] = 0xf0 | c >>> 18;\n          buf[i++] = 0x80 | c >>> 12 & 0x3f;\n          buf[i++] = 0x80 | c >>> 6 & 0x3f;\n          buf[i++] = 0x80 | c & 0x3f;\n        }\n      }\n      return buf;\n    }\n    return {\n      Deflate: Deflate,\n      constants: constants,\n      string2buf: string2buf\n    };\n  }\n}","map":{"version":3,"names":["workerURL","createDeflateWorker","URL","createObjectURL","Blob","concat","workerCodeFn","Worker","monitor","_a","makePakoDeflate","Deflate","constants","string2buf","deflate","rawBytesCount","self","addEventListener","event","data","action","postMessage","type","additionalBytesCount","pushData","id","compressedBytesCount","chunks","reduce","total","chunk","length","push","Z_FINISH","result","binaryData","Z_SYNC_FLUSH","fn","apply","arguments","e","error","_","Z_FIXED","Z_BINARY","Z_TEXT","Z_UNKNOWN","zero","buf","len","STORED_BLOCK","STATIC_TREES","DYN_TREES","MIN_MATCH","MAX_MATCH","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","Buf_size","MAX_BL_BITS","END_BLOCK","REP_3_6","REPZ_3_10","REPZ_11_138","extra_lbits","Uint8Array","extra_dbits","extra_blbits","bl_order","DIST_CODE_LEN","static_ltree","Array","static_dtree","_dist_code","_length_code","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","bi_flush","gen_bitlen","desc","stree","extra","base","h","n","m","bits","xbits","f","overflow","bl_count","heap","heap_max","opt_len","static_len","gen_codes","next_code","tr_static_init","init_block","dyn_ltree","dyn_dtree","bl_tree","last_lit","matches","bi_windup","copy_block","header","set","window","subarray","smaller","depth","_n2","_m2","pqdownheap","k","v","j","heap_len","compress_block","ltree","dtree","lc","lx","d_buf","l_buf","build_tree","node","scan_tree","prevlen","curlen","nextlen","count","max_count","min_count","send_tree","build_bl_tree","max_blindex","l_desc","d_desc","bl_desc","send_all_trees","lcodes","dcodes","blcodes","rank","detect_data_type","black_mask","static_init_done","_tr_init","_tr_stored_block","stored_len","last","_tr_align","_tr_flush_block","opt_lenb","static_lenb","level","strm","data_type","strategy","_tr_tally","lit_bufsize","_tr_init_1","_tr_stored_block_1","_tr_flush_block_1","_tr_tally_1","_tr_align_1","trees","adler32","adler","pos","s1","s2","adler32_1","makeTable","table","crcTable","Uint32Array","crc32","crc","t","end","i","crc32_1","messages","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_FULL_FLUSH","Z_BLOCK","Z_TREES","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_NO_COMPRESSION","Z_BEST_SPEED","Z_BEST_COMPRESSION","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_DEFAULT_STRATEGY","Z_DEFLATED","_tr_init$1","_tr_stored_block$1","_tr_flush_block$1","_tr_tally$1","_tr_align$1","Z_FIXED$1","Z_UNKNOWN$1","MAX_MEM_LEVEL","MAX_WBITS","DEF_MEM_LEVEL","LENGTH_CODES$1","LITERALS$1","L_CODES$1","D_CODES$1","BL_CODES$1","HEAP_SIZE$1","MAX_BITS$1","MIN_MATCH$1","MAX_MATCH$1","MIN_LOOKAHEAD","PRESET_DICT","INIT_STATE","EXTRA_STATE","NAME_STATE","COMMENT_STATE","HCRC_STATE","BUSY_STATE","FINISH_STATE","BS_NEED_MORE","BS_BLOCK_DONE","BS_FINISH_STARTED","BS_FINISH_DONE","OS_CODE","err","errorCode","msg","zero$1","HASH_ZLIB","prev","hash_shift","hash_mask","HASH","flush_pending","state","avail_out","output","pending_out","next_out","total_out","flush_block_only","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","total_in","longest_match","cur_match","chain_length","max_chain_length","scan","match","best_len","prev_length","nice_match","limit","w_size","_win","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","p","more","str","window_size","hash_size","head","insert","ins_h","deflate_stored","flush","max_block_size","pending_buf_size","max_start","deflate_fast","hash_head","bflush","match_length","max_lazy_match","deflate_slow","max_insert","prev_match","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","lm_init","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","Uint16Array","deflateResetKeep","deflateReset","ret","deflateSetHeader","deflateInit2","windowBits","memLevel","deflateInit","beg","val","old_flush","text","hcrc","name","comment","time","os","level_flags","charCodeAt","bstate","deflateEnd","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","next","deflateInit_1","deflateInit2_1","deflateReset_1","deflateResetKeep_1","deflateSetHeader_1","deflate_2","deflateEnd_1","deflateSetDictionary_1","deflateInfo","deflate_1","flattenChunks","l","_i","_l","_utf8len","q","ZStream","zstream","toString","Object","prototype","Z_NO_FLUSH$1","Z_FULL_FLUSH$1","Z_FINISH$1","Z_OK$1","Z_STREAM_END$1","Z_DEFAULT_COMPRESSION$1","Z_DEFAULT_STRATEGY$1","Z_DEFLATED$1","options","chunkSize","opt","raw","gzip","ended","Error","dict","call","_dict_set","flush_mode","_flush_mode","onData","onEnd","TextEncoder","encode","c2","m_pos","str_len","buf_len"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/rum_and_trace_correlation/rum_app/node_modules/@datadog/browser-rum/src/domain/segmentCollection/deflateWorker.js"],"sourcesContent":["let workerURL\n\nexport function createDeflateWorker() {\n  // Lazily compute the worker URL to allow importing the SDK in NodeJS\n  if (!workerURL) {\n    workerURL = URL.createObjectURL(new Blob([`(${workerCodeFn})(self)`]))\n  }\n  return new Worker(workerURL)\n}\n\nfunction workerCodeFn() {\n  monitor(function () {\n    const { Deflate, constants, string2buf } = makePakoDeflate()\n\n    let deflate = new Deflate()\n    let rawBytesCount = 0\n    self.addEventListener(\n      'message',\n      monitor((event) => {\n        const data = event.data\n        switch (data.action) {\n          case 'init':\n            self.postMessage({\n              type: 'initialized',\n            })\n            break\n          case 'write': {\n            const additionalBytesCount = pushData(data.data)\n            self.postMessage({\n              type: 'wrote',\n              id: data.id,\n              compressedBytesCount: deflate.chunks.reduce((total, chunk) => total + chunk.length, 0),\n              additionalBytesCount,\n            })\n            break\n          }\n          case 'flush': {\n            const additionalBytesCount = data.data ? pushData(data.data) : 0\n            deflate.push('', constants.Z_FINISH)\n            self.postMessage({\n              type: 'flushed',\n              id: data.id,\n              result: deflate.result,\n              additionalBytesCount,\n              rawBytesCount,\n            })\n            deflate = new Deflate()\n            rawBytesCount = 0\n            break\n          }\n        }\n      })\n    )\n\n    function pushData(data) {\n      // TextEncoder is not supported on old browser version like Edge 18, therefore we use string2buf\n      const binaryData = string2buf(data)\n      deflate.push(binaryData, constants.Z_SYNC_FLUSH)\n      rawBytesCount += binaryData.length\n      return binaryData.length\n    }\n  })()\n\n  function monitor(fn) {\n    return function () {\n      try {\n        return fn.apply(this, arguments)\n      } catch (e) {\n        try {\n          self.postMessage({\n            type: 'errored',\n            error: e,\n          })\n        } catch (_) {\n          // DATA_CLONE_ERR, cf https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n          self.postMessage({\n            type: 'errored',\n            error: `${e}`,\n          })\n        }\n      }\n    }\n  }\n\n  // https://github.com/nodeca/pako/blob/034669ba0f1a4c0590e45f7c2820128200f972b3/dist/pako_deflate.es5.js\n  function makePakoDeflate() {\n    /* eslint-disable camelcase, no-bitwise */\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    /* Public constants ========================================================== */\n\n    /* =========================================================================== */\n    // const Z_FILTERED          = 1;\n    // const Z_HUFFMAN_ONLY      = 2;\n    // const Z_RLE               = 3;\n\n    var Z_FIXED = 4 // const Z_DEFAULT_STRATEGY  = 0;\n\n    /* Possible values of the data_type field (though see inflate()) */\n\n    var Z_BINARY = 0\n    var Z_TEXT = 1 // const Z_ASCII             = 1; // = Z_TEXT\n\n    var Z_UNKNOWN = 2\n    /* ============================================================================ */\n\n    function zero(buf) {\n      var len = buf.length\n\n      while (--len >= 0) {\n        buf[len] = 0\n      }\n    } // From zutil.h\n\n    var STORED_BLOCK = 0\n    var STATIC_TREES = 1\n    var DYN_TREES = 2\n    /* The three kinds of block type */\n\n    var MIN_MATCH = 3\n    var MAX_MATCH = 258\n    /* The minimum and maximum match lengths */\n    // From deflate.h\n\n    /* ===========================================================================\n     * Internal compression state.\n     */\n\n    var LENGTH_CODES = 29\n    /* number of length codes, not counting the special END_BLOCK code */\n\n    var LITERALS = 256\n    /* number of literal bytes 0..255 */\n\n    var L_CODES = LITERALS + 1 + LENGTH_CODES\n    /* number of Literal or Length codes, including the END_BLOCK code */\n\n    var D_CODES = 30\n    /* number of distance codes */\n\n    var BL_CODES = 19\n    /* number of codes used to transfer the bit lengths */\n\n    var HEAP_SIZE = 2 * L_CODES + 1\n    /* maximum heap size */\n\n    var MAX_BITS = 15\n    /* All codes must not exceed MAX_BITS bits */\n\n    var Buf_size = 16\n    /* size of bit buffer in bi_buf */\n\n    /* ===========================================================================\n     * Constants\n     */\n\n    var MAX_BL_BITS = 7\n    /* Bit length codes must not exceed MAX_BL_BITS bits */\n\n    var END_BLOCK = 256\n    /* end of block literal code */\n\n    var REP_3_6 = 16\n    /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n    var REPZ_3_10 = 17\n    /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n    var REPZ_11_138 = 18\n    /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n    var extra_lbits =\n      /* extra bits for each length code */\n      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])\n    var extra_dbits =\n      /* extra bits for each distance code */\n      new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])\n    var extra_blbits =\n      /* extra bits for each bit length code */\n      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])\n    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])\n    /* eslint-enable comma-spacing,array-bracket-spacing */\n\n    /* The lengths of the bit length codes are sent in order of decreasing\n     * probability, to avoid transmitting the lengths for unused bit length codes.\n     */\n\n    /* ===========================================================================\n     * Local data. These are initialized only once.\n     */\n    // We pre-fill arrays with 0 to avoid uninitialized gaps\n\n    var DIST_CODE_LEN = 512\n    /* see definition of array dist_code below */\n    // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n\n    var static_ltree = new Array((L_CODES + 2) * 2)\n    zero(static_ltree)\n    /* The static literal tree. Since the bit lengths are imposed, there is no\n     * need for the L_CODES extra codes used during heap construction. However\n     * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n     * below).\n     */\n\n    var static_dtree = new Array(D_CODES * 2)\n    zero(static_dtree)\n    /* The static distance tree. (Actually a trivial tree since all codes use\n     * 5 bits.)\n     */\n\n    var _dist_code = new Array(DIST_CODE_LEN)\n\n    zero(_dist_code)\n    /* Distance codes. The first 256 values correspond to the distances\n     * 3 .. 258, the last 256 values correspond to the top 8 bits of\n     * the 15 bit distances.\n     */\n\n    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1)\n\n    zero(_length_code)\n    /* length code for each normalized match length (0 == MIN_MATCH) */\n\n    var base_length = new Array(LENGTH_CODES)\n    zero(base_length)\n    /* First normalized length for each code (0 = MIN_MATCH) */\n\n    var base_dist = new Array(D_CODES)\n    zero(base_dist)\n    /* First normalized distance for each code (0 = distance of 1) */\n\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n      this.static_tree = static_tree\n      /* static tree or NULL */\n\n      this.extra_bits = extra_bits\n      /* extra bits for each code or NULL */\n\n      this.extra_base = extra_base\n      /* base index for extra_bits */\n\n      this.elems = elems\n      /* max number of elements in the tree */\n\n      this.max_length = max_length\n      /* max bit length for the codes */\n      // show if `static_tree` has data or dummy - needed for monomorphic objects\n\n      this.has_stree = static_tree && static_tree.length\n    }\n\n    var static_l_desc\n    var static_d_desc\n    var static_bl_desc\n\n    function TreeDesc(dyn_tree, stat_desc) {\n      this.dyn_tree = dyn_tree\n      /* the dynamic tree */\n\n      this.max_code = 0\n      /* largest code with non zero frequency */\n\n      this.stat_desc = stat_desc\n      /* the corresponding static tree */\n    }\n\n    var d_code = function d_code(dist) {\n      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]\n    }\n    /* ===========================================================================\n     * Output a short LSB first on the stream.\n     * IN assertion: there is enough room in pendingBuf.\n     */\n\n    var put_short = function put_short(s, w) {\n      //    put_byte(s, (uch)((w) & 0xff));\n      //    put_byte(s, (uch)((ush)(w) >> 8));\n      s.pending_buf[s.pending++] = w & 0xff\n      s.pending_buf[s.pending++] = (w >>> 8) & 0xff\n    }\n    /* ===========================================================================\n     * Send a value on a given number of bits.\n     * IN assertion: length <= 16 and value fits in length bits.\n     */\n\n    var send_bits = function send_bits(s, value, length) {\n      if (s.bi_valid > Buf_size - length) {\n        s.bi_buf |= (value << s.bi_valid) & 0xffff\n        put_short(s, s.bi_buf)\n        s.bi_buf = value >> (Buf_size - s.bi_valid)\n        s.bi_valid += length - Buf_size\n      } else {\n        s.bi_buf |= (value << s.bi_valid) & 0xffff\n        s.bi_valid += length\n      }\n    }\n\n    var send_code = function send_code(s, c, tree) {\n      send_bits(\n        s,\n        tree[c * 2],\n        /* .Code */\n        tree[c * 2 + 1]\n        /* .Len */\n      )\n    }\n    /* ===========================================================================\n     * Reverse the first len bits of a code, using straightforward code (a faster\n     * method would use a table)\n     * IN assertion: 1 <= len <= 15\n     */\n\n    var bi_reverse = function bi_reverse(code, len) {\n      var res = 0\n\n      do {\n        res |= code & 1\n        code >>>= 1\n        res <<= 1\n      } while (--len > 0)\n\n      return res >>> 1\n    }\n    /* ===========================================================================\n     * Flush the bit buffer, keeping at most 7 bits in it.\n     */\n\n    var bi_flush = function bi_flush(s) {\n      if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf)\n        s.bi_buf = 0\n        s.bi_valid = 0\n      } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 0xff\n        s.bi_buf >>= 8\n        s.bi_valid -= 8\n      }\n    }\n    /* ===========================================================================\n     * Compute the optimal bit lengths for a tree and update the total bit length\n     * for the current block.\n     * IN assertion: the fields freq and dad are set, heap[heap_max] and\n     *    above are the tree nodes sorted by increasing frequency.\n     * OUT assertions: the field len is set to the optimal bit length, the\n     *     array bl_count contains the frequencies for each bit length.\n     *     The length opt_len is updated; static_len is also updated if stree is\n     *     not null.\n     */\n\n    var gen_bitlen = function gen_bitlen(\n      s,\n      desc //    deflate_state *s; //    tree_desc *desc;    /* the tree descriptor */\n    ) {\n      var tree = desc.dyn_tree\n      var max_code = desc.max_code\n      var stree = desc.stat_desc.static_tree\n      var has_stree = desc.stat_desc.has_stree\n      var extra = desc.stat_desc.extra_bits\n      var base = desc.stat_desc.extra_base\n      var max_length = desc.stat_desc.max_length\n      var h\n      /* heap index */\n\n      var n\n      var m\n      /* iterate over the tree elements */\n\n      var bits\n      /* bit length */\n\n      var xbits\n      /* extra bits */\n\n      var f\n      /* frequency */\n\n      var overflow = 0\n      /* number of elements with bit length too large */\n\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        s.bl_count[bits] = 0\n      }\n      /* In a first pass, compute the optimal bit lengths (which may\n       * overflow in the case of the bit length tree).\n       */\n\n      tree[s.heap[s.heap_max] * 2 + 1] =\n        /* .Len */\n        0\n      /* root of the heap */\n\n      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s.heap[h]\n        bits =\n          tree[\n            tree[n * 2 + 1] *\n              /* .Dad */\n              2 +\n              1\n          ] +\n          /* .Len */\n          1\n\n        if (bits > max_length) {\n          bits = max_length\n          overflow++\n        }\n\n        tree[n * 2 + 1] =\n          /* .Len */\n          bits\n        /* We overwrite tree[n].Dad which is no longer needed */\n\n        if (n > max_code) {\n          continue\n        }\n        /* not a leaf node */\n\n        s.bl_count[bits]++\n        xbits = 0\n\n        if (n >= base) {\n          xbits = extra[n - base]\n        }\n\n        f = tree[n * 2]\n        /* .Freq */\n        s.opt_len += f * (bits + xbits)\n\n        if (has_stree) {\n          s.static_len +=\n            f *\n            (stree[n * 2 + 1] +\n              /* .Len */\n              xbits)\n        }\n      }\n\n      if (overflow === 0) {\n        return\n      } // Trace((stderr,\"\\nbit length overflow\\n\"));\n\n      /* This happens for example on obj2 and pic of the Calgary corpus */\n\n      /* Find the first bit length which could increase: */\n\n      do {\n        bits = max_length - 1\n\n        while (s.bl_count[bits] === 0) {\n          bits--\n        }\n\n        s.bl_count[bits]--\n        /* move one leaf down the tree */\n\n        s.bl_count[bits + 1] += 2\n        /* move one overflow item as its brother */\n\n        s.bl_count[max_length]--\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count[max_length]\n         */\n\n        overflow -= 2\n      } while (overflow > 0)\n      /* Now recompute all bit lengths, scanning in increasing frequency.\n       * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n       * lengths instead of fixing only the wrong ones. This idea is taken\n       * from 'ar' written by Haruhiko Okumura.)\n       */\n\n      for (bits = max_length; bits !== 0; bits--) {\n        n = s.bl_count[bits]\n\n        while (n !== 0) {\n          m = s.heap[--h]\n\n          if (m > max_code) {\n            continue\n          }\n\n          if (\n            tree[m * 2 + 1] !==\n            /* .Len */\n            bits\n          ) {\n            // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n            s.opt_len +=\n              (bits - tree[m * 2 + 1]) *\n              /* .Len */\n              tree[m * 2]\n            /* .Freq */\n            tree[m * 2 + 1] =\n              /* .Len */\n              bits\n          }\n\n          n--\n        }\n      }\n    }\n    /* ===========================================================================\n     * Generate the codes for a given tree and bit counts (which need not be\n     * optimal).\n     * IN assertion: the array bl_count contains the bit length statistics for\n     * the given tree and the field len is set for all tree elements.\n     * OUT assertion: the field code is set for all tree elements of non\n     *     zero code length.\n     */\n\n    var gen_codes = function gen_codes(\n      tree,\n      max_code,\n      bl_count\n      //    ct_data *tree;             /* the tree to decorate */\n      //    int max_code;              /* largest code with non zero frequency */\n      //    ushf *bl_count;            /* number of codes at each bit length */\n    ) {\n      var next_code = new Array(MAX_BITS + 1)\n      /* next code value for each bit length */\n\n      var code = 0\n      /* running code value */\n\n      var bits\n      /* bit index */\n\n      var n\n      /* code index */\n\n      /* The distribution counts are first used to generate the code values\n       * without bit reversal.\n       */\n\n      for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code[bits] = code = (code + bl_count[bits - 1]) << 1\n      }\n      /* Check that the bit counts in bl_count are consistent. The last code\n       * must be all ones.\n       */\n      // Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n      //        \"inconsistent bit counts\");\n      // Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n      for (n = 0; n <= max_code; n++) {\n        var len = tree[n * 2 + 1]\n        /* .Len */\n        if (len === 0) {\n          continue\n        }\n        /* Now reverse the bits */\n\n        tree[n * 2] =\n          /* .Code */\n          bi_reverse(next_code[len]++, len) // Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n        //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n      }\n    }\n    /* ===========================================================================\n     * Initialize the various 'constant' tables.\n     */\n\n    var tr_static_init = function tr_static_init() {\n      var n\n      /* iterates over tree elements */\n\n      var bits\n      /* bit counter */\n\n      var length\n      /* length value */\n\n      var code\n      /* code value */\n\n      var dist\n      /* distance index */\n\n      var bl_count = new Array(MAX_BITS + 1)\n      /* number of codes at each bit length for an optimal tree */\n      // do check in _tr_init()\n      // if (static_init_done) return;\n\n      /* For some embedded targets, global variables are not initialized: */\n\n      /* #ifdef NO_INIT_GLOBAL_POINTERS\n      static_l_desc.static_tree = static_ltree;\n      static_l_desc.extra_bits = extra_lbits;\n      static_d_desc.static_tree = static_dtree;\n      static_d_desc.extra_bits = extra_dbits;\n      static_bl_desc.extra_bits = extra_blbits;\n    #endif */\n\n      /* Initialize the mapping length (0..255) -> length code (0..28) */\n\n      length = 0\n\n      for (code = 0; code < LENGTH_CODES - 1; code++) {\n        base_length[code] = length\n\n        for (n = 0; n < 1 << extra_lbits[code]; n++) {\n          _length_code[length++] = code\n        }\n      } // Assert (length == 256, \"tr_static_init: length != 256\");\n\n      /* Note that the length 255 (match length 258) can be represented\n       * in two different ways: code 284 + 5 bits or code 285, so we\n       * overwrite length_code[255] to use the best encoding:\n       */\n\n      _length_code[length - 1] = code\n      /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\n      dist = 0\n\n      for (code = 0; code < 16; code++) {\n        base_dist[code] = dist\n\n        for (n = 0; n < 1 << extra_dbits[code]; n++) {\n          _dist_code[dist++] = code\n        }\n      } // Assert (dist == 256, \"tr_static_init: dist != 256\");\n\n      dist >>= 7\n      /* from now on, all distances are divided by 128 */\n\n      for (; code < D_CODES; code++) {\n        base_dist[code] = dist << 7\n\n        for (n = 0; n < 1 << (extra_dbits[code] - 7); n++) {\n          _dist_code[256 + dist++] = code\n        }\n      } // Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n      /* Construct the codes of the static literal tree */\n\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        bl_count[bits] = 0\n      }\n\n      n = 0\n\n      while (n <= 143) {\n        static_ltree[n * 2 + 1] =\n          /* .Len */\n          8\n        n++\n        bl_count[8]++\n      }\n\n      while (n <= 255) {\n        static_ltree[n * 2 + 1] =\n          /* .Len */\n          9\n        n++\n        bl_count[9]++\n      }\n\n      while (n <= 279) {\n        static_ltree[n * 2 + 1] =\n          /* .Len */\n          7\n        n++\n        bl_count[7]++\n      }\n\n      while (n <= 287) {\n        static_ltree[n * 2 + 1] =\n          /* .Len */\n          8\n        n++\n        bl_count[8]++\n      }\n      /* Codes 286 and 287 do not exist, but we must include them in the\n       * tree construction to get a canonical Huffman tree (longest code\n       * all ones)\n       */\n\n      gen_codes(static_ltree, L_CODES + 1, bl_count)\n      /* The static distance tree is trivial: */\n\n      for (n = 0; n < D_CODES; n++) {\n        static_dtree[n * 2 + 1] =\n          /* .Len */\n          5\n        static_dtree[n * 2] =\n          /* .Code */\n          bi_reverse(n, 5)\n      } // Now data ready and we can init static trees\n\n      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS)\n      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS)\n      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS)\n      // static_init_done = true;\n    }\n    /* ===========================================================================\n     * Initialize a new block.\n     */\n\n    var init_block = function init_block(s) {\n      var n\n      /* iterates over tree elements */\n\n      /* Initialize the trees. */\n\n      for (n = 0; n < L_CODES; n++) {\n        s.dyn_ltree[n * 2] =\n          /* .Freq */\n          0\n      }\n\n      for (n = 0; n < D_CODES; n++) {\n        s.dyn_dtree[n * 2] =\n          /* .Freq */\n          0\n      }\n\n      for (n = 0; n < BL_CODES; n++) {\n        s.bl_tree[n * 2] =\n          /* .Freq */\n          0\n      }\n\n      s.dyn_ltree[END_BLOCK * 2] =\n        /* .Freq */\n        1\n      s.opt_len = s.static_len = 0\n      s.last_lit = s.matches = 0\n    }\n    /* ===========================================================================\n     * Flush the bit buffer and align the output on a byte boundary\n     */\n\n    var bi_windup = function bi_windup(s) {\n      if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf)\n      } else if (s.bi_valid > 0) {\n        // put_byte(s, (Byte)s->bi_buf);\n        s.pending_buf[s.pending++] = s.bi_buf\n      }\n\n      s.bi_buf = 0\n      s.bi_valid = 0\n    }\n    /* ===========================================================================\n     * Copy a stored block, storing first the length and its\n     * one's complement if requested.\n     */\n\n    var copy_block = function copy_block(\n      s,\n      buf,\n      len,\n      header\n      // DeflateState *s;\n      // charf    *buf;    /* the input data */\n      // unsigned len;     /* its length */\n      // int      header;  /* true if block header must be written */\n    ) {\n      bi_windup(s)\n      /* align on byte boundary */\n\n      if (header) {\n        put_short(s, len)\n        put_short(s, ~len)\n      }\n      //  while (len--) {\n      //    put_byte(s, *buf++);\n      //  }\n\n      s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending)\n      s.pending += len\n    }\n    /* ===========================================================================\n     * Compares to subtrees, using the tree depth as tie breaker when\n     * the subtrees have equal frequency. This minimizes the worst case length.\n     */\n\n    var smaller = function smaller(tree, n, m, depth) {\n      var _n2 = n * 2\n\n      var _m2 = m * 2\n\n      return (\n        tree[_n2] <\n          /* .Freq */\n          tree[_m2] ||\n        /* .Freq */\n        (tree[_n2] ===\n          /* .Freq */\n          tree[_m2] &&\n          /* .Freq */\n          depth[n] <= depth[m])\n      )\n    }\n    /* ===========================================================================\n     * Restore the heap property by moving down the tree starting at node k,\n     * exchanging a node with the smallest of its two sons if necessary, stopping\n     * when the heap property is re-established (each father smaller than its\n     * two sons).\n     */\n\n    var pqdownheap = function pqdownheap(\n      s,\n      tree,\n      k\n      //    deflate_state *s;\n      //    ct_data *tree;  /* the tree to restore */\n      //    int k;               /* node to move down */\n    ) {\n      var v = s.heap[k]\n      var j = k << 1\n      /* left son of k */\n\n      while (j <= s.heap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n          j++\n        }\n        /* Exit if v is smaller than both sons */\n\n        if (smaller(tree, v, s.heap[j], s.depth)) {\n          break\n        }\n        /* Exchange v with the smallest son */\n\n        s.heap[k] = s.heap[j]\n        k = j\n        /* And continue down the tree, setting j to the left son of k */\n\n        j <<= 1\n      }\n\n      s.heap[k] = v\n    } // inlined manually\n    // const SMALLEST = 1;\n\n    /* ===========================================================================\n     * Send the block data compressed using the given Huffman trees\n     */\n\n    var compress_block = function compress_block(\n      s,\n      ltree,\n      dtree\n      //    deflate_state *s;\n      //    const ct_data *ltree; /* literal tree */\n      //    const ct_data *dtree; /* distance tree */\n    ) {\n      var dist\n      /* distance of matched string */\n\n      var lc\n      /* match length or unmatched char (if dist == 0) */\n\n      var lx = 0\n      /* running index in l_buf */\n\n      var code\n      /* the code to send */\n\n      var extra\n      /* number of extra bits to send */\n\n      if (s.last_lit !== 0) {\n        do {\n          dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | s.pending_buf[s.d_buf + lx * 2 + 1]\n          lc = s.pending_buf[s.l_buf + lx]\n          lx++\n\n          if (dist === 0) {\n            send_code(s, lc, ltree)\n            /* send a literal byte */\n            // Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n          } else {\n            /* Here, lc is the match length - MIN_MATCH */\n            code = _length_code[lc]\n            send_code(s, code + LITERALS + 1, ltree)\n            /* send the length code */\n\n            extra = extra_lbits[code]\n\n            if (extra !== 0) {\n              lc -= base_length[code]\n              send_bits(s, lc, extra)\n              /* send the extra length bits */\n            }\n\n            dist--\n            /* dist is now the match distance - 1 */\n\n            code = d_code(dist) // Assert (code < D_CODES, \"bad d_code\");\n\n            send_code(s, code, dtree)\n            /* send the distance code */\n\n            extra = extra_dbits[code]\n\n            if (extra !== 0) {\n              dist -= base_dist[code]\n              send_bits(s, dist, extra)\n              /* send the extra distance bits */\n            }\n          }\n          /* literal or match pair ? */\n\n          /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n          // Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n          //       \"pendingBuf overflow\");\n        } while (lx < s.last_lit)\n      }\n\n      send_code(s, END_BLOCK, ltree)\n    }\n    /* ===========================================================================\n     * Construct one Huffman tree and assigns the code bit strings and lengths.\n     * Update the total bit length for the current block.\n     * IN assertion: the field freq is set for all tree elements.\n     * OUT assertions: the fields len and code are set to the optimal bit length\n     *     and corresponding code. The length opt_len is updated; static_len is\n     *     also updated if stree is not null. The field max_code is set.\n     */\n\n    var build_tree = function build_tree(\n      s,\n      desc //    deflate_state *s; //    tree_desc *desc; /* the tree descriptor */\n    ) {\n      var tree = desc.dyn_tree\n      var stree = desc.stat_desc.static_tree\n      var has_stree = desc.stat_desc.has_stree\n      var elems = desc.stat_desc.elems\n      var n\n      var m\n      /* iterate over heap elements */\n\n      var max_code = -1\n      /* largest code with non zero frequency */\n\n      var node\n      /* new node being created */\n\n      /* Construct the initial heap, with least frequent element in\n       * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n       * heap[0] is not used.\n       */\n\n      s.heap_len = 0\n      s.heap_max = HEAP_SIZE\n\n      for (n = 0; n < elems; n++) {\n        if (\n          tree[n * 2] !==\n          /* .Freq */\n          0\n        ) {\n          s.heap[++s.heap_len] = max_code = n\n          s.depth[n] = 0\n        } else {\n          tree[n * 2 + 1] =\n            /* .Len */\n            0\n        }\n      }\n      /* The pkzip format requires that at least one distance code exists,\n       * and that at least one bit should be sent even if there is only one\n       * possible code. So to avoid special checks later on we force at least\n       * two codes of non zero frequency.\n       */\n\n      while (s.heap_len < 2) {\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0\n        tree[node * 2] =\n          /* .Freq */\n          1\n        s.depth[node] = 0\n        s.opt_len--\n\n        if (has_stree) {\n          s.static_len -= stree[node * 2 + 1]\n          /* .Len */\n        }\n        /* node is 0 or 1 so it does not have extra bits */\n      }\n\n      desc.max_code = max_code\n      /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n       * establish sub-heaps of increasing lengths:\n       */\n\n      for (\n        n = s.heap_len >> 1;\n        /* int /2 */\n        n >= 1;\n        n--\n      ) {\n        pqdownheap(s, tree, n)\n      }\n      /* Construct the Huffman tree by repeatedly combining the least two\n       * frequent nodes.\n       */\n\n      node = elems\n      /* next internal node of the tree */\n\n      do {\n        // pqremove(s, tree, n);  /* n = node of least frequency */\n\n        /** * pqremove ** */\n        n = s.heap[1]\n        /* SMALLEST */\n        s.heap[1] = s.heap[s.heap_len--]\n        /* SMALLEST */\n        pqdownheap(\n          s,\n          tree,\n          1\n          /* SMALLEST */\n        )\n        /***/\n\n        m = s.heap[1]\n        /* SMALLEST */\n        /* m = node of next least frequency */\n\n        s.heap[--s.heap_max] = n\n        /* keep the nodes sorted by frequency */\n\n        s.heap[--s.heap_max] = m\n        /* Create a new node father of n and m */\n\n        tree[node * 2] =\n          /* .Freq */\n          tree[n * 2] +\n          /* .Freq */\n          tree[m * 2]\n        /* .Freq */\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1\n        tree[n * 2 + 1] =\n          /* .Dad */\n          tree[m * 2 + 1] =\n            /* .Dad */\n            node\n        /* and insert the new node in the heap */\n\n        s.heap[1] = node++\n        /* SMALLEST */\n        pqdownheap(\n          s,\n          tree,\n          1\n          /* SMALLEST */\n        )\n      } while (s.heap_len >= 2)\n\n      s.heap[--s.heap_max] = s.heap[1]\n      /* SMALLEST */\n      /* At this point, the fields freq and dad are set. We can now\n       * generate the bit lengths.\n       */\n\n      gen_bitlen(s, desc)\n      /* The field len is now set, we can generate the bit codes */\n\n      gen_codes(tree, max_code, s.bl_count)\n    }\n    /* ===========================================================================\n     * Scan a literal or distance tree to determine the frequencies of the codes\n     * in the bit length tree.\n     */\n\n    var scan_tree = function scan_tree(\n      s,\n      tree,\n      max_code\n      //    deflate_state *s;\n      //    ct_data *tree;   /* the tree to be scanned */\n      //    int max_code;    /* and its largest code of non zero frequency */\n    ) {\n      var n\n      /* iterates over all tree elements */\n\n      var prevlen = -1\n      /* last emitted length */\n\n      var curlen\n      /* length of current code */\n\n      var nextlen = tree[0 * 2 + 1]\n      /* .Len */\n      /* length of next code */\n\n      var count = 0\n      /* repeat count of the current code */\n\n      var max_count = 7\n      /* max repeat count */\n\n      var min_count = 4\n      /* min repeat count */\n\n      if (nextlen === 0) {\n        max_count = 138\n        min_count = 3\n      }\n\n      tree[(max_code + 1) * 2 + 1] =\n        /* .Len */\n        0xffff\n      /* guard */\n\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen\n        nextlen = tree[(n + 1) * 2 + 1]\n        /* .Len */\n\n        if (++count < max_count && curlen === nextlen) {\n          continue\n        } else if (count < min_count) {\n          s.bl_tree[curlen * 2] +=\n            /* .Freq */\n            count\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            s.bl_tree[curlen * 2] /* .Freq */++\n          }\n\n          s.bl_tree[REP_3_6 * 2] /* .Freq */++\n        } else if (count <= 10) {\n          s.bl_tree[REPZ_3_10 * 2] /* .Freq */++\n        } else {\n          s.bl_tree[REPZ_11_138 * 2] /* .Freq */++\n        }\n\n        count = 0\n        prevlen = curlen\n\n        if (nextlen === 0) {\n          max_count = 138\n          min_count = 3\n        } else if (curlen === nextlen) {\n          max_count = 6\n          min_count = 3\n        } else {\n          max_count = 7\n          min_count = 4\n        }\n      }\n    }\n    /* ===========================================================================\n     * Send a literal or distance tree in compressed form, using the codes in\n     * bl_tree.\n     */\n\n    var send_tree = function send_tree(\n      s,\n      tree,\n      max_code\n      //    deflate_state *s;\n      //    ct_data *tree; /* the tree to be scanned */\n      //    int max_code;       /* and its largest code of non zero frequency */\n    ) {\n      var n\n      /* iterates over all tree elements */\n\n      var prevlen = -1\n      /* last emitted length */\n\n      var curlen\n      /* length of current code */\n\n      var nextlen = tree[0 * 2 + 1]\n      /* .Len */\n      /* length of next code */\n\n      var count = 0\n      /* repeat count of the current code */\n\n      var max_count = 7\n      /* max repeat count */\n\n      var min_count = 4\n      /* min repeat count */\n\n      /* tree[max_code+1].Len = -1; */\n\n      /* guard already set */\n\n      if (nextlen === 0) {\n        max_count = 138\n        min_count = 3\n      }\n\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen\n        nextlen = tree[(n + 1) * 2 + 1]\n        /* .Len */\n\n        if (++count < max_count && curlen === nextlen) {\n          continue\n        } else if (count < min_count) {\n          do {\n            send_code(s, curlen, s.bl_tree)\n          } while (--count !== 0)\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            send_code(s, curlen, s.bl_tree)\n            count--\n          } // Assert(count >= 3 && count <= 6, \" 3_6?\");\n\n          send_code(s, REP_3_6, s.bl_tree)\n          send_bits(s, count - 3, 2)\n        } else if (count <= 10) {\n          send_code(s, REPZ_3_10, s.bl_tree)\n          send_bits(s, count - 3, 3)\n        } else {\n          send_code(s, REPZ_11_138, s.bl_tree)\n          send_bits(s, count - 11, 7)\n        }\n\n        count = 0\n        prevlen = curlen\n\n        if (nextlen === 0) {\n          max_count = 138\n          min_count = 3\n        } else if (curlen === nextlen) {\n          max_count = 6\n          min_count = 3\n        } else {\n          max_count = 7\n          min_count = 4\n        }\n      }\n    }\n    /* ===========================================================================\n     * Construct the Huffman tree for the bit lengths and return the index in\n     * bl_order of the last bit length code to send.\n     */\n\n    var build_bl_tree = function build_bl_tree(s) {\n      var max_blindex\n      /* index of last bit length code of non zero freq */\n\n      /* Determine the bit length frequencies for literal and distance trees */\n\n      scan_tree(s, s.dyn_ltree, s.l_desc.max_code)\n      scan_tree(s, s.dyn_dtree, s.d_desc.max_code)\n      /* Build the bit length tree: */\n\n      build_tree(s, s.bl_desc)\n      /* opt_len now includes the length of the tree representations, except\n       * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n       */\n\n      /* Determine the number of bit length codes to send. The pkzip format\n       * requires that at least 4 bit length codes be sent. (appnote.txt says\n       * 3 but the actual value used is 4.)\n       */\n\n      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n        if (\n          s.bl_tree[bl_order[max_blindex] * 2 + 1] !==\n          /* .Len */\n          0\n        ) {\n          break\n        }\n      }\n      /* Update opt_len to include the bit length tree and counts */\n\n      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4 // Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n      //        s->opt_len, s->static_len));\n\n      return max_blindex\n    }\n    /* ===========================================================================\n     * Send the header for a block using dynamic Huffman trees: the counts, the\n     * lengths of the bit length codes, the literal tree and the distance tree.\n     * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n     */\n\n    var send_all_trees = function send_all_trees(\n      s,\n      lcodes,\n      dcodes,\n      blcodes //    deflate_state *s; //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n    ) {\n      var rank\n      /* index in bl_order */\n      // Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n      // Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n      //        \"too many codes\");\n      // Tracev((stderr, \"\\nbl counts: \"));\n\n      send_bits(s, lcodes - 257, 5)\n      /* not +255 as stated in appnote.txt */\n\n      send_bits(s, dcodes - 1, 5)\n      send_bits(s, blcodes - 4, 4)\n      /* not -3 as stated in appnote.txt */\n\n      for (rank = 0; rank < blcodes; rank++) {\n        // Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(\n          s,\n          s.bl_tree[bl_order[rank] * 2 + 1],\n          /* .Len */\n          3\n        )\n      } // Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n      send_tree(s, s.dyn_ltree, lcodes - 1)\n      /* literal tree */\n      // Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n      send_tree(s, s.dyn_dtree, dcodes - 1)\n      /* distance tree */\n      // Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n    }\n    /* ===========================================================================\n     * Check if the data type is TEXT or BINARY, using the following algorithm:\n     * - TEXT if the two conditions below are satisfied:\n     *    a) There are no non-portable control characters belonging to the\n     *       \"black list\" (0..6, 14..25, 28..31).\n     *    b) There is at least one printable character belonging to the\n     *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n     * - BINARY otherwise.\n     * - The following partially-portable control characters form a\n     *   \"gray list\" that is ignored in this detection algorithm:\n     *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n     * IN assertion: the fields Freq of dyn_ltree are set.\n     */\n\n    var detect_data_type = function detect_data_type(s) {\n      /* black_mask is the bit mask of black-listed bytes\n       * set bits 0..6, 14..25, and 28..31\n       * 0xf3ffc07f = binary 11110011111111111100000001111111\n       */\n      var black_mask = 0xf3ffc07f\n      var n\n      /* Check for non-textual (\"black-listed\") bytes. */\n\n      for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n        if (\n          black_mask & 1 &&\n          s.dyn_ltree[n * 2] !==\n            /* .Freq */\n            0\n        ) {\n          return Z_BINARY\n        }\n      }\n      /* Check for textual (\"white-listed\") bytes. */\n\n      if (\n        s.dyn_ltree[9 * 2] !==\n          /* .Freq */\n          0 ||\n        s.dyn_ltree[10 * 2] !==\n          /* .Freq */\n          0 ||\n        s.dyn_ltree[13 * 2] !==\n          /* .Freq */\n          0\n      ) {\n        return Z_TEXT\n      }\n\n      for (n = 32; n < LITERALS; n++) {\n        if (\n          s.dyn_ltree[n * 2] !==\n          /* .Freq */\n          0\n        ) {\n          return Z_TEXT\n        }\n      }\n      /* There are no \"black-listed\" or \"white-listed\" bytes:\n       * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n       */\n\n      return Z_BINARY\n    }\n\n    var static_init_done = false\n    /* ===========================================================================\n     * Initialize the tree data structures for a new zlib stream.\n     */\n\n    var _tr_init = function _tr_init(s) {\n      if (!static_init_done) {\n        tr_static_init()\n        static_init_done = true\n      }\n\n      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc)\n      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc)\n      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc)\n      s.bi_buf = 0\n      s.bi_valid = 0\n      /* Initialize the first block of the first file: */\n\n      init_block(s)\n    }\n    /* ===========================================================================\n     * Send a stored block\n     */\n\n    var _tr_stored_block = function _tr_stored_block(\n      s,\n      buf,\n      stored_len,\n      last\n      // DeflateState *s;\n      // charf *buf;       /* input block */\n      // ulg stored_len;   /* length of input block */\n      // int last;         /* one if this is the last block for a file */\n    ) {\n      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3)\n      /* send block type */\n\n      copy_block(s, buf, stored_len, true)\n      /* with header */\n    }\n    /* ===========================================================================\n     * Send one empty static block to give enough lookahead for inflate.\n     * This takes 10 bits, of which 7 may remain in the bit buffer.\n     */\n\n    var _tr_align = function _tr_align(s) {\n      send_bits(s, STATIC_TREES << 1, 3)\n      send_code(s, END_BLOCK, static_ltree)\n      bi_flush(s)\n    }\n    /* ===========================================================================\n     * Determine the best encoding for the current block: dynamic trees, static\n     * trees or store, and output the encoded block to the zip file.\n     */\n\n    var _tr_flush_block = function _tr_flush_block(\n      s,\n      buf,\n      stored_len,\n      last\n      // DeflateState *s;\n      // charf *buf;       /* input block, or NULL if too old */\n      // ulg stored_len;   /* length of input block */\n      // int last;         /* one if this is the last block for a file */\n    ) {\n      var opt_lenb\n      var static_lenb\n      /* opt_len and static_len in bytes */\n\n      var max_blindex = 0\n      /* index of last bit length code of non zero freq */\n\n      /* Build the Huffman trees unless a stored block is forced */\n\n      if (s.level > 0) {\n        /* Check if the file is binary or text */\n        if (s.strm.data_type === Z_UNKNOWN) {\n          s.strm.data_type = detect_data_type(s)\n        }\n        /* Construct the literal and distance trees */\n\n        build_tree(s, s.l_desc) // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n\n        build_tree(s, s.d_desc) // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n\n        /* At this point, opt_len and static_len are the total bit lengths of\n         * the compressed block data, excluding the tree representations.\n         */\n\n        /* Build the bit length tree for the above two trees, and get the index\n         * in bl_order of the last bit length code to send.\n         */\n\n        max_blindex = build_bl_tree(s)\n        /* Determine the best encoding. Compute the block lengths in bytes. */\n\n        opt_lenb = (s.opt_len + 3 + 7) >>> 3\n        static_lenb = (s.static_len + 3 + 7) >>> 3 // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n        //        s->last_lit));\n\n        if (static_lenb <= opt_lenb) {\n          opt_lenb = static_lenb\n        }\n      } else {\n        // Assert(buf != (char*)0, \"lost buf\");\n        opt_lenb = static_lenb = stored_len + 5\n        /* force a stored block */\n      }\n\n      if (stored_len + 4 <= opt_lenb && buf !== -1) {\n        /* 4: two words for the lengths */\n\n        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         */\n        _tr_stored_block(s, buf, stored_len, last)\n      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3)\n        compress_block(s, static_ltree, static_dtree)\n      } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3)\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1)\n        compress_block(s, s.dyn_ltree, s.dyn_dtree)\n      } // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n\n      /* The above check is made mod 2^32, for files larger than 512 MB\n       * and uLong implemented on 32 bits.\n       */\n\n      init_block(s)\n\n      if (last) {\n        bi_windup(s)\n      } // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n      //       s->compressed_len-7*last));\n    }\n    /* ===========================================================================\n     * Save the match info and tally the frequency counts. Return true if\n     * the current block must be flushed.\n     */\n\n    var _tr_tally = function _tr_tally(\n      s,\n      dist,\n      lc\n      //    deflate_state *s;\n      //    unsigned dist;  /* distance of matched string */\n      //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n    ) {\n      // let out_length, in_length, dcode;\n      s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff\n      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff\n      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff\n      s.last_lit++\n\n      if (dist === 0) {\n        /* lc is the unmatched char */\n        s.dyn_ltree[lc * 2] /* .Freq */++\n      } else {\n        s.matches++\n        /* Here, lc is the match length - MIN_MATCH */\n\n        dist--\n        /* dist = match distance - 1 */\n        // Assert((ush)dist < (ush)MAX_DIST(s) &&\n        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n        //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /* .Freq */++\n        s.dyn_dtree[d_code(dist) * 2] /* .Freq */++\n      } // (!) This block is disabled in zlib defaults,\n      // don't enable it for binary compatibility\n      // #ifdef TRUNCATE_BLOCK\n      //  /* Try to guess if it is profitable to stop the current block here */\n      //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n      //    /* Compute an upper bound for the compressed length */\n      //    out_length = s.last_lit*8;\n      //    in_length = s.strstart - s.block_start;\n      //\n      //    for (dcode = 0; dcode < D_CODES; dcode++) {\n      //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n      //    }\n      //    out_length >>>= 3;\n      //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n      //    //       s->last_lit, in_length, out_length,\n      //    //       100L - out_length*100L/in_length));\n      //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n      //      return true;\n      //    }\n      //  }\n      // #endif\n\n      return s.last_lit === s.lit_bufsize - 1\n      /* We avoid equality with lit_bufsize because of wraparound at 64K\n       * on 16 bit machines and because stored blocks are restricted to\n       * 64K-1 bytes.\n       */\n    }\n\n    var _tr_init_1 = _tr_init\n    var _tr_stored_block_1 = _tr_stored_block\n    var _tr_flush_block_1 = _tr_flush_block\n    var _tr_tally_1 = _tr_tally\n    var _tr_align_1 = _tr_align\n    var trees = {\n      _tr_init: _tr_init_1,\n      _tr_stored_block: _tr_stored_block_1,\n      _tr_flush_block: _tr_flush_block_1,\n      _tr_tally: _tr_tally_1,\n      _tr_align: _tr_align_1,\n    }\n\n    // It isn't worth it to make additional optimizations as in original.\n    // Small size is preferable.\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var adler32 = function adler32(adler, buf, len, pos) {\n      var s1 = (adler & 0xffff) | 0\n      var s2 = ((adler >>> 16) & 0xffff) | 0\n      var n = 0\n\n      while (len !== 0) {\n        // Set limit ~ twice less than 5552, to keep\n        // s2 in 31-bits, because we force signed ints.\n        // in other case %= will fail.\n        n = len > 2000 ? 2000 : len\n        len -= n\n\n        do {\n          s1 = (s1 + buf[pos++]) | 0\n          s2 = (s2 + s1) | 0\n        } while (--n)\n\n        s1 %= 65521\n        s2 %= 65521\n      }\n\n      return s1 | (s2 << 16) | 0\n    }\n\n    var adler32_1 = adler32\n\n    // So write code to minimize size - no pregenerated tables\n    // and array tools dependencies.\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n    // Use ordinary array, since untyped makes no boost here\n\n    var makeTable = function makeTable() {\n      var c\n      var table = []\n\n      for (var n = 0; n < 256; n++) {\n        c = n\n\n        for (var k = 0; k < 8; k++) {\n          c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1\n        }\n\n        table[n] = c\n      }\n\n      return table\n    } // Create table on load. Just 255 signed longs. Not a problem.\n\n    var crcTable = new Uint32Array(makeTable())\n\n    var crc32 = function crc32(crc, buf, len, pos) {\n      var t = crcTable\n      var end = pos + len\n      crc ^= -1\n\n      for (var i = pos; i < end; i++) {\n        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xff]\n      }\n\n      return crc ^ -1 // >>> 0;\n    }\n\n    var crc32_1 = crc32\n\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var messages = {\n      2: 'need dictionary',\n\n      /* Z_NEED_DICT       2  */\n      1: 'stream end',\n\n      /* Z_STREAM_END      1  */\n      0: '',\n\n      /* Z_OK              0  */\n      '-1': 'file error',\n\n      /* Z_ERRNO         (-1) */\n      '-2': 'stream error',\n\n      /* Z_STREAM_ERROR  (-2) */\n      '-3': 'data error',\n\n      /* Z_DATA_ERROR    (-3) */\n      '-4': 'insufficient memory',\n\n      /* Z_MEM_ERROR     (-4) */\n      '-5': 'buffer error',\n\n      /* Z_BUF_ERROR     (-5) */\n      '-6': 'incompatible version',\n      /* Z_VERSION_ERROR (-6) */\n    }\n\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var constants = {\n      /* Allowed flush values; see deflate() and inflate() below for details */\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_TREES: 6,\n\n      /* Return codes for the compression/decompression functions. Negative values\n       * are errors, positive values are used for special but normal events.\n       */\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_MEM_ERROR: -4,\n      Z_BUF_ERROR: -5,\n      // Z_VERSION_ERROR: -6,\n\n      /* compression levels */\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n\n      /* Possible values of the data_type field (though see inflate()) */\n      Z_BINARY: 0,\n      Z_TEXT: 1,\n      // Z_ASCII:                1, // = Z_TEXT (deprecated)\n      Z_UNKNOWN: 2,\n\n      /* The deflate compression method */\n      Z_DEFLATED: 8, // Z_NULL:                 null // Use -1 or null inline, depending on var type\n    }\n\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var _tr_init$1 = trees._tr_init\n    var _tr_stored_block$1 = trees._tr_stored_block\n    var _tr_flush_block$1 = trees._tr_flush_block\n    var _tr_tally$1 = trees._tr_tally\n    var _tr_align$1 = trees._tr_align\n    /* Public constants ========================================================== */\n\n    /* =========================================================================== */\n\n    var Z_NO_FLUSH = constants.Z_NO_FLUSH\n    var Z_PARTIAL_FLUSH = constants.Z_PARTIAL_FLUSH\n    var Z_FULL_FLUSH = constants.Z_FULL_FLUSH\n    var Z_FINISH = constants.Z_FINISH\n    var Z_BLOCK = constants.Z_BLOCK\n    var Z_OK = constants.Z_OK\n    var Z_STREAM_END = constants.Z_STREAM_END\n    var Z_STREAM_ERROR = constants.Z_STREAM_ERROR\n    var Z_DATA_ERROR = constants.Z_DATA_ERROR\n    var Z_BUF_ERROR = constants.Z_BUF_ERROR\n    var Z_DEFAULT_COMPRESSION = constants.Z_DEFAULT_COMPRESSION\n    var Z_FILTERED = constants.Z_FILTERED\n    var Z_HUFFMAN_ONLY = constants.Z_HUFFMAN_ONLY\n    var Z_RLE = constants.Z_RLE\n    var Z_FIXED$1 = constants.Z_FIXED\n    var Z_DEFAULT_STRATEGY = constants.Z_DEFAULT_STRATEGY\n    var Z_UNKNOWN$1 = constants.Z_UNKNOWN\n    var Z_DEFLATED = constants.Z_DEFLATED\n    /* ============================================================================ */\n\n    var MAX_MEM_LEVEL = 9\n    /* Maximum value for memLevel in deflateInit2 */\n\n    var MAX_WBITS = 15\n    /* 32K LZ77 window */\n\n    var DEF_MEM_LEVEL = 8\n    var LENGTH_CODES$1 = 29\n    /* number of length codes, not counting the special END_BLOCK code */\n\n    var LITERALS$1 = 256\n    /* number of literal bytes 0..255 */\n\n    var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1\n    /* number of Literal or Length codes, including the END_BLOCK code */\n\n    var D_CODES$1 = 30\n    /* number of distance codes */\n\n    var BL_CODES$1 = 19\n    /* number of codes used to transfer the bit lengths */\n\n    var HEAP_SIZE$1 = 2 * L_CODES$1 + 1\n    /* maximum heap size */\n\n    var MAX_BITS$1 = 15\n    /* All codes must not exceed MAX_BITS bits */\n\n    var MIN_MATCH$1 = 3\n    var MAX_MATCH$1 = 258\n    var MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1\n    var PRESET_DICT = 0x20\n    var INIT_STATE = 42\n    var EXTRA_STATE = 69\n    var NAME_STATE = 73\n    var COMMENT_STATE = 91\n    var HCRC_STATE = 103\n    var BUSY_STATE = 113\n    var FINISH_STATE = 666\n    var BS_NEED_MORE = 1\n    /* block not completed, need more input or more output */\n\n    var BS_BLOCK_DONE = 2\n    /* block flush performed */\n\n    var BS_FINISH_STARTED = 3\n    /* finish started, need only more output at next deflate */\n\n    var BS_FINISH_DONE = 4\n    /* finish done, accept no more input or output */\n\n    var OS_CODE = 0x03 // Unix :) . Don't detect, use this default.\n\n    var err = function err(strm, errorCode) {\n      strm.msg = messages[errorCode]\n      return errorCode\n    }\n\n    var rank = function rank(f) {\n      return (f << 1) - (f > 4 ? 9 : 0)\n    }\n\n    var zero$1 = function zero(buf) {\n      var len = buf.length\n\n      while (--len >= 0) {\n        buf[len] = 0\n      }\n    }\n\n    var HASH_ZLIB = function HASH_ZLIB(s, prev, data) {\n      return ((prev << s.hash_shift) ^ data) & s.hash_mask\n    } // This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n    // But breaks binary compatibility\n    // let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n\n    var HASH = HASH_ZLIB\n    /* =========================================================================\n     * Flush as much pending output as possible. All deflate() output goes\n     * through this function so some applications may wish to modify it\n     * to avoid allocating a large strm->output buffer and copying into it.\n     * (See also read_buf()).\n     */\n\n    var flush_pending = function flush_pending(strm) {\n      var s = strm.state // _tr_flush_bits(s);\n\n      var len = s.pending\n\n      if (len > strm.avail_out) {\n        len = strm.avail_out\n      }\n\n      if (len === 0) {\n        return\n      }\n\n      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out)\n      strm.next_out += len\n      s.pending_out += len\n      strm.total_out += len\n      strm.avail_out -= len\n      s.pending -= len\n\n      if (s.pending === 0) {\n        s.pending_out = 0\n      }\n    }\n\n    var flush_block_only = function flush_block_only(s, last) {\n      _tr_flush_block$1(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last)\n\n      s.block_start = s.strstart\n      flush_pending(s.strm)\n    }\n\n    var put_byte = function put_byte(s, b) {\n      s.pending_buf[s.pending++] = b\n    }\n    /* =========================================================================\n     * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n     * IN assertion: the stream state is correct and there is enough room in\n     * pending_buf.\n     */\n\n    var putShortMSB = function putShortMSB(s, b) {\n      //  put_byte(s, (Byte)(b >> 8));\n      //  put_byte(s, (Byte)(b & 0xff));\n      s.pending_buf[s.pending++] = (b >>> 8) & 0xff\n      s.pending_buf[s.pending++] = b & 0xff\n    }\n    /* ===========================================================================\n     * Read a new buffer from the current input stream, update the adler32\n     * and total number of bytes read.  All deflate() input goes through\n     * this function so some applications may wish to modify it to avoid\n     * allocating a large strm->input buffer and copying from it.\n     * (See also flush_pending()).\n     */\n\n    var read_buf = function read_buf(strm, buf, start, size) {\n      var len = strm.avail_in\n\n      if (len > size) {\n        len = size\n      }\n\n      if (len === 0) {\n        return 0\n      }\n\n      strm.avail_in -= len // zmemcpy(buf, strm->next_in, len);\n\n      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start)\n\n      if (strm.state.wrap === 1) {\n        strm.adler = adler32_1(strm.adler, buf, len, start)\n      } else if (strm.state.wrap === 2) {\n        strm.adler = crc32_1(strm.adler, buf, len, start)\n      }\n\n      strm.next_in += len\n      strm.total_in += len\n      return len\n    }\n    /* ===========================================================================\n     * Set match_start to the longest match starting at the given string and\n     * return its length. Matches shorter or equal to prev_length are discarded,\n     * in which case the result is equal to prev_length and match_start is\n     * garbage.\n     * IN assertions: cur_match is the head of the hash chain for the current\n     *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n     * OUT assertion: the match length is not greater than s->lookahead.\n     */\n\n    var longest_match = function longest_match(s, cur_match) {\n      var chain_length = s.max_chain_length\n      /* max hash chain length */\n\n      var scan = s.strstart\n      /* current string */\n\n      var match\n      /* matched string */\n\n      var len\n      /* length of current match */\n\n      var best_len = s.prev_length\n      /* best match length so far */\n\n      var nice_match = s.nice_match\n      /* stop if match long enough */\n\n      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0\n      /* NIL */\n      var _win = s.window // shortcut\n\n      var wmask = s.w_mask\n      var prev = s.prev\n      /* Stop when cur_match becomes <= limit. To simplify the code,\n       * we prevent matches with the string of window index 0.\n       */\n\n      var strend = s.strstart + MAX_MATCH$1\n      var scan_end1 = _win[scan + best_len - 1]\n      var scan_end = _win[scan + best_len]\n      /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n       * It is easy to get rid of this optimization if necessary.\n       */\n      // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n      /* Do not waste too much time if we already have a good match: */\n\n      if (s.prev_length >= s.good_match) {\n        chain_length >>= 2\n      }\n      /* Do not look for matches beyond the end of the input. This is necessary\n       * to make deflate deterministic.\n       */\n\n      if (nice_match > s.lookahead) {\n        nice_match = s.lookahead\n      } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n      do {\n        // Assert(cur_match < s->strstart, \"no future\");\n        match = cur_match\n        /* Skip to next match if the match length cannot increase\n         * or if the match length is less than 2.  Note that the checks below\n         * for insufficient lookahead only occur occasionally for performance\n         * reasons.  Therefore uninitialized memory will be accessed, and\n         * conditional jumps will be made that depend on those values.\n         * However the length of the match is limited to the lookahead, so\n         * the output of deflate is not affected by the uninitialized values.\n         */\n\n        if (\n          _win[match + best_len] !== scan_end ||\n          _win[match + best_len - 1] !== scan_end1 ||\n          _win[match] !== _win[scan] ||\n          _win[++match] !== _win[scan + 1]\n        ) {\n          continue\n        }\n        /* The check at best_len-1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan[2] and match[2] since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         */\n\n        scan += 2\n        match++ // Assert(*scan == *match, \"match[2]?\");\n\n        /* We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart+258.\n         */\n\n        do {\n          /* jshint noempty:false */\n        } while (\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          scan < strend\n        ) // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n        len = MAX_MATCH$1 - (strend - scan)\n        scan = strend - MAX_MATCH$1\n\n        if (len > best_len) {\n          s.match_start = cur_match\n          best_len = len\n\n          if (len >= nice_match) {\n            break\n          }\n\n          scan_end1 = _win[scan + best_len - 1]\n          scan_end = _win[scan + best_len]\n        }\n      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0)\n\n      if (best_len <= s.lookahead) {\n        return best_len\n      }\n\n      return s.lookahead\n    }\n    /* ===========================================================================\n     * Fill the window when the lookahead becomes insufficient.\n     * Updates strstart and lookahead.\n     *\n     * IN assertion: lookahead < MIN_LOOKAHEAD\n     * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n     *    At least one byte has been read, or avail_in == 0; reads are\n     *    performed for at least two bytes (required for the zip translate_eol\n     *    option -- not supported here).\n     */\n\n    var fill_window = function fill_window(s) {\n      var _w_size = s.w_size\n      var p\n      var n\n      var m\n      var more\n      var str // Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n      do {\n        more = s.window_size - s.lookahead - s.strstart // JS ints have 32 bit, block below not needed\n\n        /* Deal with !@#$% 64K limit: */\n        // if (sizeof(int) <= 2) {\n        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n        //        more = wsize;\n        //\n        //  } else if (more == (unsigned)(-1)) {\n        //        /* Very unlikely, but possible on 16 bit machine if\n        //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n        //         */\n        //        more--;\n        //    }\n        // }\n\n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n\n        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n          s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0)\n          s.match_start -= _w_size\n          s.strstart -= _w_size\n          /* we now have strstart >= MAX_DIST */\n\n          s.block_start -= _w_size\n          /* Slide the hash table (could be avoided with 32 bit values\n         at the expense of memory usage). We slide even when level == 0\n         to keep the hash table consistent if we switch back to level > 0\n         later. (Using level 0 permanently is not an optimal usage of\n         zlib, so we don't care about this pathological case.)\n         */\n\n          n = s.hash_size\n          p = n\n\n          do {\n            m = s.head[--p]\n            s.head[p] = m >= _w_size ? m - _w_size : 0\n          } while (--n)\n\n          n = _w_size\n          p = n\n\n          do {\n            m = s.prev[--p]\n            s.prev[p] = m >= _w_size ? m - _w_size : 0\n            /* If n is not on any hash chain, prev[n] is garbage but\n             * its value will never be used.\n             */\n          } while (--n)\n\n          more += _w_size\n        }\n\n        if (s.strm.avail_in === 0) {\n          break\n        }\n        /* If there was no sliding:\n         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n         *    more == window_size - lookahead - strstart\n         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * => more >= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  &&\n         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more >= 2.\n         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n         */\n        // Assert(more >= 2, \"more < 2\");\n\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more)\n        s.lookahead += n\n        /* Initialize the hash value now that we have some input: */\n\n        if (s.lookahead + s.insert >= MIN_MATCH$1) {\n          str = s.strstart - s.insert\n          s.ins_h = s.window[str]\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n\n          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]) // #if MIN_MATCH != 3\n          //        Call update_hash() MIN_MATCH-3 more times\n          // #endif\n\n          while (s.insert) {\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1])\n            s.prev[str & s.w_mask] = s.head[s.ins_h]\n            s.head[s.ins_h] = str\n            str++\n            s.insert--\n\n            if (s.lookahead + s.insert < MIN_MATCH$1) {\n              break\n            }\n          }\n        }\n        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         */\n      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)\n      /* If the WIN_INIT bytes after the end of the current data have never been\n       * written, then zero those bytes in order to avoid memory check reports of\n       * the use of uninitialized (or uninitialised as Julian writes) bytes by\n       * the longest match routines.  Update the high water mark for the next\n       * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n       * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n       */\n      //  if (s.high_water < s.window_size) {\n      //    const curr = s.strstart + s.lookahead;\n      //    let init = 0;\n      //\n      //    if (s.high_water < curr) {\n      //      /* Previous high water mark below current data -- zero WIN_INIT\n      //       * bytes or up to end of window, whichever is less.\n      //       */\n      //      init = s.window_size - curr;\n      //      if (init > WIN_INIT)\n      //        init = WIN_INIT;\n      //      zmemzero(s->window + curr, (unsigned)init);\n      //      s->high_water = curr + init;\n      //    }\n      //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n      //      /* High water mark at or above current data, but below current data\n      //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n      //       * to end of window, whichever is less.\n      //       */\n      //      init = (ulg)curr + WIN_INIT - s->high_water;\n      //      if (init > s->window_size - s->high_water)\n      //        init = s->window_size - s->high_water;\n      //      zmemzero(s->window + s->high_water, (unsigned)init);\n      //      s->high_water += init;\n      //    }\n      //  }\n      //\n      //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n      //    \"not enough room for search\");\n    }\n    /* ===========================================================================\n     * Copy without compression as much as possible from the input stream, return\n     * the current block state.\n     * This function does not insert new strings in the dictionary since\n     * uncompressible data is probably not useful. This function is used\n     * only for the level=0 compression option.\n     * NOTE: this function should be optimized to avoid extra copying from\n     * window to pending_buf.\n     */\n\n    var deflate_stored = function deflate_stored(s, flush) {\n      /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n       * to pending_buf_size, and each stored block has a 5 byte header:\n       */\n      var max_block_size = 0xffff\n\n      if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5\n      }\n      /* Copy as much as possible from input to output: */\n\n      for (;;) {\n        /* Fill the window as much as possible: */\n        if (s.lookahead <= 1) {\n          // Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n          //  s->block_start >= (long)s->w_size, \"slide too late\");\n          //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n          //        s.block_start >= s.w_size)) {\n          //        throw  new Error(\"slide too late\");\n          //      }\n          fill_window(s)\n\n          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE\n          }\n\n          if (s.lookahead === 0) {\n            break\n          }\n          /* flush the current block */\n        } // Assert(s->block_start >= 0L, \"block gone\");\n        //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n        s.strstart += s.lookahead\n        s.lookahead = 0\n        /* Emit a stored block if pending_buf will be full: */\n\n        var max_start = s.block_start + max_block_size\n\n        if (s.strstart === 0 || s.strstart >= max_start) {\n          /* strstart == 0 is possible when wraparound on 16-bit machine */\n          s.lookahead = s.strstart - max_start\n          s.strstart = max_start\n          /** * FLUSH_BLOCK(s, 0); ** */\n\n          flush_block_only(s, false)\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE\n          }\n          /***/\n        }\n        /* Flush if we may have to slide, otherwise block_start may become\n         * negative and the data will be gone:\n         */\n\n        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false)\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE\n          }\n          /***/\n        }\n      }\n\n      s.insert = 0\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true)\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED\n        }\n        /***/\n\n        return BS_FINISH_DONE\n      }\n\n      if (s.strstart > s.block_start) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false)\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE\n        }\n        /***/\n      }\n\n      return BS_NEED_MORE\n    }\n    /* ===========================================================================\n     * Compress as much as possible from the input stream, return the current\n     * block state.\n     * This function does not perform lazy evaluation of matches and inserts\n     * new strings in the dictionary only for unmatched strings or for short\n     * matches. It is used only for the fast compression options.\n     */\n\n    var deflate_fast = function deflate_fast(s, flush) {\n      var hash_head\n      /* head of the hash chain */\n\n      var bflush\n      /* set if current block must be flushed */\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s)\n\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE\n          }\n\n          if (s.lookahead === 0) {\n            break\n            /* flush the current block */\n          }\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n\n        hash_head = 0\n        /* NIL */\n\n        if (s.lookahead >= MIN_MATCH$1) {\n          /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1])\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n          s.head[s.ins_h] = s.strstart\n          /***/\n        }\n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n\n        if (\n          hash_head !== 0 &&\n          /* NIL */\n          s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n        ) {\n          /* To simplify the code, we prevent matches with the string\n           * of window index 0 (in particular we have to avoid a match\n           * of the string with itself at the start of the input file).\n           */\n          s.match_length = longest_match(s, hash_head)\n          /* longest_match() sets match_start */\n        }\n\n        if (s.match_length >= MIN_MATCH$1) {\n          // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n          /** * _tr_tally_dist(s, s.strstart - s.match_start,\n                       s.match_length - MIN_MATCH, bflush); ** */\n          bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1)\n          s.lookahead -= s.match_length\n          /* Insert new strings in the hash table only if the match length\n           * is not too large. This saves time but degrades compression.\n           */\n\n          if (\n            s.match_length <= s.max_lazy_match &&\n            /* max_insert_length */\n            s.lookahead >= MIN_MATCH$1\n          ) {\n            s.match_length--\n            /* string at strstart already in table */\n\n            do {\n              s.strstart++\n              /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n\n              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1])\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n              s.head[s.ins_h] = s.strstart\n              /***/\n\n              /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n               * always MIN_MATCH bytes ahead.\n               */\n            } while (--s.match_length !== 0)\n\n            s.strstart++\n          } else {\n            s.strstart += s.match_length\n            s.match_length = 0\n            s.ins_h = s.window[s.strstart]\n            /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n\n            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]) // #if MIN_MATCH != 3\n            //                Call UPDATE_HASH() MIN_MATCH-3 more times\n            // #endif\n\n            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n             * matter since it will be recomputed at next deflate call.\n             */\n          }\n        } else {\n          /* No match, output a literal byte */\n          // Tracevv((stderr,\"%c\", s.window[s.strstart]));\n\n          /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart])\n          s.lookahead--\n          s.strstart++\n        }\n\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false)\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE\n          }\n          /***/\n        }\n      }\n\n      s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true)\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED\n        }\n        /***/\n\n        return BS_FINISH_DONE\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false)\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE\n    }\n    /* ===========================================================================\n     * Same as above, but achieves better compression. We use a lazy\n     * evaluation for matches: a match is finally adopted only if there is\n     * no better match at the next window position.\n     */\n\n    var deflate_slow = function deflate_slow(s, flush) {\n      var hash_head\n      /* head of hash chain */\n\n      var bflush\n      /* set if current block must be flushed */\n\n      var max_insert\n      /* Process the input block. */\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s)\n\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE\n          }\n\n          if (s.lookahead === 0) {\n            break\n          }\n          /* flush the current block */\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n\n        hash_head = 0\n        /* NIL */\n\n        if (s.lookahead >= MIN_MATCH$1) {\n          /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1])\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n          s.head[s.ins_h] = s.strstart\n          /***/\n        }\n        /* Find the longest match, discarding those <= prev_length.\n         */\n\n        s.prev_length = s.match_length\n        s.prev_match = s.match_start\n        s.match_length = MIN_MATCH$1 - 1\n\n        if (\n          hash_head !== 0 &&\n          /* NIL */\n          s.prev_length < s.max_lazy_match &&\n          s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n          /* MAX_DIST(s) */\n        ) {\n          /* To simplify the code, we prevent matches with the string\n           * of window index 0 (in particular we have to avoid a match\n           * of the string with itself at the start of the input file).\n           */\n          s.match_length = longest_match(s, hash_head)\n          /* longest_match() sets match_start */\n\n          if (\n            s.match_length <= 5 &&\n            (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096))\n            /* TOO_FAR */\n          ) {\n            /* If prev_match is also MIN_MATCH, match_start is garbage\n             * but we will ignore the current match anyway.\n             */\n            s.match_length = MIN_MATCH$1 - 1\n          }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n\n        if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {\n          max_insert = s.strstart + s.lookahead - MIN_MATCH$1\n          /* Do not insert strings in hash table beyond this. */\n          // check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n          /** *_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                       s.prev_length - MIN_MATCH, bflush);** */\n\n          bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1)\n          /* Insert in hash table all strings up to the end of the match.\n           * strstart-1 and strstart are already inserted. If there is not\n           * enough lookahead, the last two strings are not inserted in\n           * the hash table.\n           */\n\n          s.lookahead -= s.prev_length - 1\n          s.prev_length -= 2\n\n          do {\n            if (++s.strstart <= max_insert) {\n              /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1])\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n              s.head[s.ins_h] = s.strstart\n              /***/\n            }\n          } while (--s.prev_length !== 0)\n\n          s.match_available = 0\n          s.match_length = MIN_MATCH$1 - 1\n          s.strstart++\n\n          if (bflush) {\n            /** * FLUSH_BLOCK(s, 0); ** */\n            flush_block_only(s, false)\n\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE\n            }\n            /***/\n          }\n        } else if (s.match_available) {\n          /* If there was no match at the previous position, output a\n           * single literal. If there was a match but the current match\n           * is longer, truncate the previous match to a single literal.\n           */\n          // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n          /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1])\n\n          if (bflush) {\n            /** * FLUSH_BLOCK_ONLY(s, 0) ** */\n            flush_block_only(s, false)\n            /***/\n          }\n\n          s.strstart++\n          s.lookahead--\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE\n          }\n        } else {\n          /* There is no previous match to compare with, wait for\n           * the next step to decide.\n           */\n          s.match_available = 1\n          s.strstart++\n          s.lookahead--\n        }\n      } // Assert (flush != Z_NO_FLUSH, \"no flush?\");\n\n      if (s.match_available) {\n        // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n        /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n        bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1])\n        s.match_available = 0\n      }\n\n      s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true)\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED\n        }\n        /***/\n\n        return BS_FINISH_DONE\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false)\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE\n    }\n    /* ===========================================================================\n     * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n     * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n     * deflate switches away from Z_RLE.)\n     */\n\n    var deflate_rle = function deflate_rle(s, flush) {\n      var bflush\n      /* set if current block must be flushed */\n\n      var prev\n      /* byte at distance one to match */\n\n      var scan\n      var strend\n      /* scan goes up to strend for length of run */\n\n      var _win = s.window\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the longest run, plus one for the unrolled loop.\n         */\n        if (s.lookahead <= MAX_MATCH$1) {\n          fill_window(s)\n\n          if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE\n          }\n\n          if (s.lookahead === 0) {\n            break\n          }\n          /* flush the current block */\n        }\n        /* See how many times the previous byte repeats */\n\n        s.match_length = 0\n\n        if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {\n          scan = s.strstart - 1\n          prev = _win[scan]\n\n          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n            strend = s.strstart + MAX_MATCH$1\n\n            do {\n              /* jshint noempty:false */\n            } while (\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              scan < strend\n            )\n\n            s.match_length = MAX_MATCH$1 - (strend - scan)\n\n            if (s.match_length > s.lookahead) {\n              s.match_length = s.lookahead\n            }\n          } // Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n        }\n        /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n\n        if (s.match_length >= MIN_MATCH$1) {\n          // check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n          /** * _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ** */\n          bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1)\n          s.lookahead -= s.match_length\n          s.strstart += s.match_length\n          s.match_length = 0\n        } else {\n          /* No match, output a literal byte */\n          // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n          /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart])\n          s.lookahead--\n          s.strstart++\n        }\n\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false)\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE\n          }\n          /***/\n        }\n      }\n\n      s.insert = 0\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true)\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED\n        }\n        /***/\n\n        return BS_FINISH_DONE\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false)\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE\n    }\n    /* ===========================================================================\n     * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n     * (It will be regenerated if this run of deflate switches away from Huffman.)\n     */\n\n    var deflate_huff = function deflate_huff(s, flush) {\n      var bflush\n      /* set if current block must be flushed */\n\n      for (;;) {\n        /* Make sure that we have a literal to write. */\n        if (s.lookahead === 0) {\n          fill_window(s)\n\n          if (s.lookahead === 0) {\n            if (flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE\n            }\n\n            break\n            /* flush the current block */\n          }\n        }\n        /* Output a literal byte */\n\n        s.match_length = 0 // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n        /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n\n        bflush = _tr_tally$1(s, 0, s.window[s.strstart])\n        s.lookahead--\n        s.strstart++\n\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false)\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE\n          }\n          /***/\n        }\n      }\n\n      s.insert = 0\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true)\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED\n        }\n        /***/\n\n        return BS_FINISH_DONE\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false)\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE\n    }\n    /* Values for max_lazy_match, good_match and max_chain_length, depending on\n     * the desired pack level (0..9). The values given below have been tuned to\n     * exclude worst case performance for pathological files. Better values may be\n     * found for specific files.\n     */\n\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n      this.good_length = good_length\n      this.max_lazy = max_lazy\n      this.nice_length = nice_length\n      this.max_chain = max_chain\n      this.func = func\n    }\n\n    var configuration_table = [\n      /*      good lazy nice chain */\n      new Config(0, 0, 0, 0, deflate_stored),\n      /* 0 store only */\n      new Config(4, 4, 8, 4, deflate_fast),\n      /* 1 max speed, no lazy matches */\n      new Config(4, 5, 16, 8, deflate_fast),\n      /* 2 */\n      new Config(4, 6, 32, 32, deflate_fast),\n      /* 3 */\n      new Config(4, 4, 16, 16, deflate_slow),\n      /* 4 lazy matches */\n      new Config(8, 16, 32, 32, deflate_slow),\n      /* 5 */\n      new Config(8, 16, 128, 128, deflate_slow),\n      /* 6 */\n      new Config(8, 32, 128, 256, deflate_slow),\n      /* 7 */\n      new Config(32, 128, 258, 1024, deflate_slow),\n      /* 8 */\n      new Config(32, 258, 258, 4096, deflate_slow),\n      /* 9 max compression */\n    ]\n    /* ===========================================================================\n     * Initialize the \"longest match\" routines for a new zlib stream\n     */\n\n    var lm_init = function lm_init(s) {\n      s.window_size = 2 * s.w_size\n      /** * CLEAR_HASH(s); ** */\n\n      zero$1(s.head) // Fill with NIL (= 0);\n\n      /* Set the default configuration parameters:\n       */\n\n      s.max_lazy_match = configuration_table[s.level].max_lazy\n      s.good_match = configuration_table[s.level].good_length\n      s.nice_match = configuration_table[s.level].nice_length\n      s.max_chain_length = configuration_table[s.level].max_chain\n      s.strstart = 0\n      s.block_start = 0\n      s.lookahead = 0\n      s.insert = 0\n      s.match_length = s.prev_length = MIN_MATCH$1 - 1\n      s.match_available = 0\n      s.ins_h = 0\n    }\n\n    function DeflateState() {\n      this.strm = null\n      /* pointer back to this zlib stream */\n\n      this.status = 0\n      /* as the name implies */\n\n      this.pending_buf = null\n      /* output still pending */\n\n      this.pending_buf_size = 0\n      /* size of pending_buf */\n\n      this.pending_out = 0\n      /* next pending byte to output to the stream */\n\n      this.pending = 0\n      /* nb of bytes in the pending buffer */\n\n      this.wrap = 0\n      /* bit 0 true for zlib, bit 1 true for gzip */\n\n      this.gzhead = null\n      /* gzip header information to write */\n\n      this.gzindex = 0\n      /* where in extra, name, or comment */\n\n      this.method = Z_DEFLATED\n      /* can only be DEFLATED */\n\n      this.last_flush = -1\n      /* value of flush param for previous deflate call */\n\n      this.w_size = 0\n      /* LZ77 window size (32K by default) */\n\n      this.w_bits = 0\n      /* log2(w_size)  (8..16) */\n\n      this.w_mask = 0\n      /* w_size - 1 */\n\n      this.window = null\n      /* Sliding window. Input bytes are read into the second half of the window,\n       * and move to the first half later to keep a dictionary of at least wSize\n       * bytes. With this organization, matches are limited to a distance of\n       * wSize-MAX_MATCH bytes, but this ensures that IO is always\n       * performed with a length multiple of the block size.\n       */\n\n      this.window_size = 0\n      /* Actual size of window: 2*wSize, except when the user input buffer\n       * is directly used as sliding window.\n       */\n\n      this.prev = null\n      /* Link to older string with same hash index. To limit the size of this\n       * array to 64K, this link is maintained only for the last 32K strings.\n       * An index in this array is thus a window index modulo 32K.\n       */\n\n      this.head = null\n      /* Heads of the hash chains or NIL. */\n\n      this.ins_h = 0\n      /* hash index of string to be inserted */\n\n      this.hash_size = 0\n      /* number of elements in hash table */\n\n      this.hash_bits = 0\n      /* log2(hash_size) */\n\n      this.hash_mask = 0\n      /* hash_size-1 */\n\n      this.hash_shift = 0\n      /* Number of bits by which ins_h must be shifted at each input\n       * step. It must be such that after MIN_MATCH steps, the oldest\n       * byte no longer takes part in the hash key, that is:\n       *   hash_shift * MIN_MATCH >= hash_bits\n       */\n\n      this.block_start = 0\n      /* Window position at the beginning of the current output block. Gets\n       * negative when the window is moved backwards.\n       */\n\n      this.match_length = 0\n      /* length of best match */\n\n      this.prev_match = 0\n      /* previous match */\n\n      this.match_available = 0\n      /* set if previous match exists */\n\n      this.strstart = 0\n      /* start of string to insert */\n\n      this.match_start = 0\n      /* start of matching string */\n\n      this.lookahead = 0\n      /* number of valid bytes ahead in window */\n\n      this.prev_length = 0\n      /* Length of the best match at previous step. Matches not greater than this\n       * are discarded. This is used in the lazy match evaluation.\n       */\n\n      this.max_chain_length = 0\n      /* To speed up deflation, hash chains are never searched beyond this\n       * length.  A higher limit improves compression ratio but degrades the\n       * speed.\n       */\n\n      this.max_lazy_match = 0\n      /* Attempt to find a better match only when the current match is strictly\n       * smaller than this value. This mechanism is used only for compression\n       * levels >= 4.\n       */\n      // That's alias to max_lazy_match, don't use directly\n      // this.max_insert_length = 0;\n\n      /* Insert new strings in the hash table only if the match length is not\n       * greater than this length. This saves time but degrades compression.\n       * max_insert_length is used only for compression levels <= 3.\n       */\n\n      this.level = 0\n      /* compression level (1..9) */\n\n      this.strategy = 0\n      /* favor or force Huffman coding */\n\n      this.good_match = 0\n      /* Use a faster search when the previous match is longer than this */\n\n      this.nice_match = 0\n      /* Stop searching when current match exceeds this */\n\n      /* used by trees.c: */\n\n      /* Didn't use ct_data typedef below to suppress compiler warning */\n      // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n      // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n      // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n      // Use flat array of DOUBLE size, with interleaved fata,\n      // because JS does not support effective\n\n      this.dyn_ltree = new Uint16Array(HEAP_SIZE$1 * 2)\n      this.dyn_dtree = new Uint16Array((2 * D_CODES$1 + 1) * 2)\n      this.bl_tree = new Uint16Array((2 * BL_CODES$1 + 1) * 2)\n      zero$1(this.dyn_ltree)\n      zero$1(this.dyn_dtree)\n      zero$1(this.bl_tree)\n      this.l_desc = null\n      /* desc. for literal tree */\n\n      this.d_desc = null\n      /* desc. for distance tree */\n\n      this.bl_desc = null\n      /* desc. for bit length tree */\n      // ush bl_count[MAX_BITS+1];\n\n      this.bl_count = new Uint16Array(MAX_BITS$1 + 1)\n      /* number of codes at each bit length for an optimal tree */\n      // int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n\n      this.heap = new Uint16Array(2 * L_CODES$1 + 1)\n      /* heap used to build the Huffman trees */\n\n      zero$1(this.heap)\n      this.heap_len = 0\n      /* number of elements in the heap */\n\n      this.heap_max = 0\n      /* element of largest frequency */\n\n      /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n       * The same heap array is used to build all trees.\n       */\n\n      this.depth = new Uint16Array(2 * L_CODES$1 + 1) // uch depth[2*L_CODES+1];\n\n      zero$1(this.depth)\n      /* Depth of each subtree used as tie breaker for trees of equal frequency\n       */\n\n      this.l_buf = 0\n      /* buffer index for literals or lengths */\n\n      this.lit_bufsize = 0\n      /* Size of match buffer for literals/lengths.  There are 4 reasons for\n       * limiting lit_bufsize to 64K:\n       *   - frequencies can be kept in 16 bit counters\n       *   - if compression is not successful for the first block, all input\n       *     data is still in the window so we can still emit a stored block even\n       *     when input comes from standard input.  (This can also be done for\n       *     all blocks if lit_bufsize is not greater than 32K.)\n       *   - if compression is not successful for a file smaller than 64K, we can\n       *     even emit a stored file instead of a stored block (saving 5 bytes).\n       *     This is applicable only for zip (not gzip or zlib).\n       *   - creating new Huffman trees less frequently may not provide fast\n       *     adaptation to changes in the input data statistics. (Take for\n       *     example a binary file with poorly compressible code followed by\n       *     a highly compressible string table.) Smaller buffer sizes give\n       *     fast adaptation but have of course the overhead of transmitting\n       *     trees more frequently.\n       *   - I can't count above 4\n       */\n\n      this.last_lit = 0\n      /* running index in l_buf */\n\n      this.d_buf = 0\n      /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n       * the same number of elements. To use different lengths, an extra flag\n       * array would be necessary.\n       */\n\n      this.opt_len = 0\n      /* bit length of current block with optimal trees */\n\n      this.static_len = 0\n      /* bit length of current block with static trees */\n\n      this.matches = 0\n      /* number of string matches in current block */\n\n      this.insert = 0\n      /* bytes at end of window left to insert */\n\n      this.bi_buf = 0\n      /* Output buffer. bits are inserted starting at the bottom (least\n       * significant bits).\n       */\n\n      this.bi_valid = 0\n      /* Number of valid bits in bi_buf.  All bits above the last valid bit\n       * are always zero.\n       */\n      // Used for window memory init. We safely ignore it for JS. That makes\n      // sense only for pointers and memory check tools.\n      // this.high_water = 0;\n\n      /* High water mark offset in window for initialized bytes -- bytes above\n       * this are set to zero in order to avoid memory check warnings when\n       * longest match routines access bytes past the input.  This is then\n       * updated to the new high water mark.\n       */\n    }\n\n    var deflateResetKeep = function deflateResetKeep(strm) {\n      if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR)\n      }\n\n      strm.total_in = strm.total_out = 0\n      strm.data_type = Z_UNKNOWN$1\n      var s = strm.state\n      s.pending = 0\n      s.pending_out = 0\n\n      if (s.wrap < 0) {\n        s.wrap = -s.wrap\n        /* was made negative by deflate(..., Z_FINISH); */\n      }\n\n      s.status = s.wrap ? INIT_STATE : BUSY_STATE\n      strm.adler =\n        s.wrap === 2\n          ? 0 // crc32(0, Z_NULL, 0)\n          : 1 // adler32(0, Z_NULL, 0)\n\n      s.last_flush = Z_NO_FLUSH\n\n      _tr_init$1(s)\n\n      return Z_OK\n    }\n\n    var deflateReset = function deflateReset(strm) {\n      var ret = deflateResetKeep(strm)\n\n      if (ret === Z_OK) {\n        lm_init(strm.state)\n      }\n\n      return ret\n    }\n\n    var deflateSetHeader = function deflateSetHeader(strm, head) {\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR\n      }\n\n      if (strm.state.wrap !== 2) {\n        return Z_STREAM_ERROR\n      }\n\n      strm.state.gzhead = head\n      return Z_OK\n    }\n\n    var deflateInit2 = function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n      if (!strm) {\n        // === Z_NULL\n        return Z_STREAM_ERROR\n      }\n\n      var wrap = 1\n\n      if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6\n      }\n\n      if (windowBits < 0) {\n        /* suppress zlib wrapper */\n        wrap = 0\n        windowBits = -windowBits\n      } else if (windowBits > 15) {\n        wrap = 2\n        /* write gzip wrapper instead */\n\n        windowBits -= 16\n      }\n\n      if (\n        memLevel < 1 ||\n        memLevel > MAX_MEM_LEVEL ||\n        method !== Z_DEFLATED ||\n        windowBits < 8 ||\n        windowBits > 15 ||\n        level < 0 ||\n        level > 9 ||\n        strategy < 0 ||\n        strategy > Z_FIXED$1\n      ) {\n        return err(strm, Z_STREAM_ERROR)\n      }\n\n      if (windowBits === 8) {\n        windowBits = 9\n      }\n      /* until 256-byte window bug fixed */\n\n      var s = new DeflateState()\n      strm.state = s\n      s.strm = strm\n      s.wrap = wrap\n      s.gzhead = null\n      s.w_bits = windowBits\n      s.w_size = 1 << s.w_bits\n      s.w_mask = s.w_size - 1\n      s.hash_bits = memLevel + 7\n      s.hash_size = 1 << s.hash_bits\n      s.hash_mask = s.hash_size - 1\n      s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1)\n      s.window = new Uint8Array(s.w_size * 2)\n      s.head = new Uint16Array(s.hash_size)\n      s.prev = new Uint16Array(s.w_size) // Don't need mem init magic for JS.\n      // s.high_water = 0;  /* nothing written to s->window yet */\n\n      s.lit_bufsize = 1 << (memLevel + 6)\n      /* 16K elements by default */\n\n      s.pending_buf_size = s.lit_bufsize * 4\n      // overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n      // s->pending_buf = (uchf *) overlay;\n\n      // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n      s.pending_buf = new Uint8Array(s.pending_buf_size)\n      // s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\n      s.d_buf = 1 * s.lit_bufsize // s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\n      s.l_buf = (1 + 2) * s.lit_bufsize\n      s.level = level\n      s.strategy = strategy\n      s.method = method\n      return deflateReset(strm)\n    }\n\n    var deflateInit = function deflateInit(strm, level) {\n      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY)\n    }\n\n    var deflate = function deflate(strm, flush) {\n      var beg\n      var val // for gzip header write only\n\n      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR\n      }\n\n      var s = strm.state\n\n      if (!strm.output || (!strm.input && strm.avail_in !== 0) || (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR)\n      }\n\n      s.strm = strm\n      /* just in case */\n\n      var old_flush = s.last_flush\n      s.last_flush = flush\n      /* Write the header */\n\n      if (s.status === INIT_STATE) {\n        if (s.wrap === 2) {\n          // GZIP header\n          strm.adler = 0 // crc32(0L, Z_NULL, 0);\n\n          put_byte(s, 31)\n          put_byte(s, 139)\n          put_byte(s, 8)\n\n          if (!s.gzhead) {\n            // s->gzhead == Z_NULL\n            put_byte(s, 0)\n            put_byte(s, 0)\n            put_byte(s, 0)\n            put_byte(s, 0)\n            put_byte(s, 0)\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0)\n            put_byte(s, OS_CODE)\n            s.status = BUSY_STATE\n          } else {\n            put_byte(\n              s,\n              (s.gzhead.text ? 1 : 0) +\n                (s.gzhead.hcrc ? 2 : 0) +\n                (!s.gzhead.extra ? 0 : 4) +\n                (!s.gzhead.name ? 0 : 8) +\n                (!s.gzhead.comment ? 0 : 16)\n            )\n            put_byte(s, s.gzhead.time & 0xff)\n            put_byte(s, (s.gzhead.time >> 8) & 0xff)\n            put_byte(s, (s.gzhead.time >> 16) & 0xff)\n            put_byte(s, (s.gzhead.time >> 24) & 0xff)\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0)\n            put_byte(s, s.gzhead.os & 0xff)\n\n            if (s.gzhead.extra && s.gzhead.extra.length) {\n              put_byte(s, s.gzhead.extra.length & 0xff)\n              put_byte(s, (s.gzhead.extra.length >> 8) & 0xff)\n            }\n\n            if (s.gzhead.hcrc) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0)\n            }\n\n            s.gzindex = 0\n            s.status = EXTRA_STATE\n          }\n        } // DEFLATE header\n        else {\n          var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8\n          var level_flags = -1\n\n          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n            level_flags = 0\n          } else if (s.level < 6) {\n            level_flags = 1\n          } else if (s.level === 6) {\n            level_flags = 2\n          } else {\n            level_flags = 3\n          }\n\n          header |= level_flags << 6\n\n          if (s.strstart !== 0) {\n            header |= PRESET_DICT\n          }\n\n          header += 31 - (header % 31)\n          s.status = BUSY_STATE\n          putShortMSB(s, header)\n          /* Save the adler32 of the preset dictionary: */\n\n          if (s.strstart !== 0) {\n            putShortMSB(s, strm.adler >>> 16)\n            putShortMSB(s, strm.adler & 0xffff)\n          }\n\n          strm.adler = 1 // adler32(0L, Z_NULL, 0);\n        }\n      } // #ifdef GZIP\n\n      if (s.status === EXTRA_STATE) {\n        if (\n          s.gzhead.extra\n          /* != Z_NULL */\n        ) {\n          beg = s.pending\n          /* start of bytes to update crc */\n\n          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n              }\n\n              flush_pending(strm)\n              beg = s.pending\n\n              if (s.pending === s.pending_buf_size) {\n                break\n              }\n            }\n\n            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff)\n            s.gzindex++\n          }\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n          }\n\n          if (s.gzindex === s.gzhead.extra.length) {\n            s.gzindex = 0\n            s.status = NAME_STATE\n          }\n        } else {\n          s.status = NAME_STATE\n        }\n      }\n\n      if (s.status === NAME_STATE) {\n        if (\n          s.gzhead.name\n          /* != Z_NULL */\n        ) {\n          beg = s.pending\n          /* start of bytes to update crc */\n          // int val;\n\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n              }\n\n              flush_pending(strm)\n              beg = s.pending\n\n              if (s.pending === s.pending_buf_size) {\n                val = 1\n                break\n              }\n            } // JS specific: little magic to add zero terminator to end of string\n\n            if (s.gzindex < s.gzhead.name.length) {\n              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff\n            } else {\n              val = 0\n            }\n\n            put_byte(s, val)\n          } while (val !== 0)\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n          }\n\n          if (val === 0) {\n            s.gzindex = 0\n            s.status = COMMENT_STATE\n          }\n        } else {\n          s.status = COMMENT_STATE\n        }\n      }\n\n      if (s.status === COMMENT_STATE) {\n        if (\n          s.gzhead.comment\n          /* != Z_NULL */\n        ) {\n          beg = s.pending\n          /* start of bytes to update crc */\n          // int val;\n\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n              }\n\n              flush_pending(strm)\n              beg = s.pending\n\n              if (s.pending === s.pending_buf_size) {\n                val = 1\n                break\n              }\n            } // JS specific: little magic to add zero terminator to end of string\n\n            if (s.gzindex < s.gzhead.comment.length) {\n              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff\n            } else {\n              val = 0\n            }\n\n            put_byte(s, val)\n          } while (val !== 0)\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n          }\n\n          if (val === 0) {\n            s.status = HCRC_STATE\n          }\n        } else {\n          s.status = HCRC_STATE\n        }\n      }\n\n      if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n          if (s.pending + 2 > s.pending_buf_size) {\n            flush_pending(strm)\n          }\n\n          if (s.pending + 2 <= s.pending_buf_size) {\n            put_byte(s, strm.adler & 0xff)\n            put_byte(s, (strm.adler >> 8) & 0xff)\n            strm.adler = 0 // crc32(0L, Z_NULL, 0);\n\n            s.status = BUSY_STATE\n          }\n        } else {\n          s.status = BUSY_STATE\n        }\n      } // #endif\n\n      /* Flush as much pending output as possible */\n\n      if (s.pending !== 0) {\n        flush_pending(strm)\n\n        if (strm.avail_out === 0) {\n          /* Since avail_out is 0, deflate will be called again with\n           * more output space, but possibly with both pending and\n           * avail_in equal to zero. There won't be anything to do,\n           * but this is not an error situation so make sure we\n           * return OK instead of BUF_ERROR at next call of deflate:\n           */\n          s.last_flush = -1\n          return Z_OK\n        }\n        /* Make sure there is something to do and avoid duplicate consecutive\n         * flushes. For repeated and useless calls with Z_FINISH, we keep\n         * returning Z_STREAM_END instead of Z_BUF_ERROR.\n         */\n      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR)\n      }\n      /* User must not provide more input after the first FINISH: */\n\n      if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR)\n      }\n      /* Start a new block or continue the current one.\n       */\n\n      if (strm.avail_in !== 0 || s.lookahead !== 0 || (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n        var bstate =\n          s.strategy === Z_HUFFMAN_ONLY\n            ? deflate_huff(s, flush)\n            : s.strategy === Z_RLE\n            ? deflate_rle(s, flush)\n            : configuration_table[s.level].func(s, flush)\n\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n          s.status = FINISH_STATE\n        }\n\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n          if (strm.avail_out === 0) {\n            s.last_flush = -1\n            /* avoid BUF_ERROR next call, see above */\n          }\n\n          return Z_OK\n          /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n           * of deflate should use the same flush parameter to make sure\n           * that the flush is complete. So we don't have to output an\n           * empty block here, this will be done at next call. This also\n           * ensures that for a very small output buffer, we emit at most\n           * one empty block.\n           */\n        }\n\n        if (bstate === BS_BLOCK_DONE) {\n          if (flush === Z_PARTIAL_FLUSH) {\n            _tr_align$1(s)\n          } else if (flush !== Z_BLOCK) {\n            /* FULL_FLUSH or SYNC_FLUSH */\n            _tr_stored_block$1(s, 0, 0, false)\n            /* For a full flush, this empty block will be recognized\n             * as a special marker by inflate_sync().\n             */\n\n            if (flush === Z_FULL_FLUSH) {\n              /** * CLEAR_HASH(s); ** */\n\n              /* forget history */\n              zero$1(s.head) // Fill with NIL (= 0);\n\n              if (s.lookahead === 0) {\n                s.strstart = 0\n                s.block_start = 0\n                s.insert = 0\n              }\n            }\n          }\n\n          flush_pending(strm)\n\n          if (strm.avail_out === 0) {\n            s.last_flush = -1\n            /* avoid BUF_ERROR at next call, see above */\n\n            return Z_OK\n          }\n        }\n      } // Assert(strm->avail_out > 0, \"bug2\");\n      // if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n      if (flush !== Z_FINISH) {\n        return Z_OK\n      }\n\n      if (s.wrap <= 0) {\n        return Z_STREAM_END\n      }\n      /* Write the trailer */\n\n      if (s.wrap === 2) {\n        put_byte(s, strm.adler & 0xff)\n        put_byte(s, (strm.adler >> 8) & 0xff)\n        put_byte(s, (strm.adler >> 16) & 0xff)\n        put_byte(s, (strm.adler >> 24) & 0xff)\n        put_byte(s, strm.total_in & 0xff)\n        put_byte(s, (strm.total_in >> 8) & 0xff)\n        put_byte(s, (strm.total_in >> 16) & 0xff)\n        put_byte(s, (strm.total_in >> 24) & 0xff)\n      } else {\n        putShortMSB(s, strm.adler >>> 16)\n        putShortMSB(s, strm.adler & 0xffff)\n      }\n\n      flush_pending(strm)\n      /* If avail_out is zero, the application will call deflate again\n       * to flush the rest.\n       */\n\n      if (s.wrap > 0) {\n        s.wrap = -s.wrap\n      }\n      /* write the trailer only once! */\n\n      return s.pending !== 0 ? Z_OK : Z_STREAM_END\n    }\n\n    var deflateEnd = function deflateEnd(strm) {\n      if (\n        !strm ||\n        /* == Z_NULL */\n        !strm.state\n        /* == Z_NULL */\n      ) {\n        return Z_STREAM_ERROR\n      }\n\n      var status = strm.state.status\n\n      if (\n        status !== INIT_STATE &&\n        status !== EXTRA_STATE &&\n        status !== NAME_STATE &&\n        status !== COMMENT_STATE &&\n        status !== HCRC_STATE &&\n        status !== BUSY_STATE &&\n        status !== FINISH_STATE\n      ) {\n        return err(strm, Z_STREAM_ERROR)\n      }\n\n      strm.state = null\n      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK\n    }\n    /* =========================================================================\n     * Initializes the compression dictionary from the given byte\n     * sequence without producing any compressed output.\n     */\n\n    var deflateSetDictionary = function deflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length\n\n      if (\n        !strm ||\n        /* == Z_NULL */\n        !strm.state\n        /* == Z_NULL */\n      ) {\n        return Z_STREAM_ERROR\n      }\n\n      var s = strm.state\n      var wrap = s.wrap\n\n      if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n        return Z_STREAM_ERROR\n      }\n      /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n\n      if (wrap === 1) {\n        /* adler32(strm->adler, dictionary, dictLength); */\n        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0)\n      }\n\n      s.wrap = 0\n      /* avoid computing Adler-32 in read_buf */\n\n      /* if dictionary would fill window, just replace the history */\n\n      if (dictLength >= s.w_size) {\n        if (wrap === 0) {\n          /* already empty otherwise */\n\n          /** * CLEAR_HASH(s); ** */\n          zero$1(s.head) // Fill with NIL (= 0);\n\n          s.strstart = 0\n          s.block_start = 0\n          s.insert = 0\n        }\n        /* use the tail */\n        // dictionary = dictionary.slice(dictLength - s.w_size);\n\n        var tmpDict = new Uint8Array(s.w_size)\n        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0)\n        dictionary = tmpDict\n        dictLength = s.w_size\n      }\n      /* insert dictionary into window and hash */\n\n      var avail = strm.avail_in\n      var next = strm.next_in\n      var input = strm.input\n      strm.avail_in = dictLength\n      strm.next_in = 0\n      strm.input = dictionary\n      fill_window(s)\n\n      while (s.lookahead >= MIN_MATCH$1) {\n        var str = s.strstart\n        var n = s.lookahead - (MIN_MATCH$1 - 1)\n\n        do {\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1])\n          s.prev[str & s.w_mask] = s.head[s.ins_h]\n          s.head[s.ins_h] = str\n          str++\n        } while (--n)\n\n        s.strstart = str\n        s.lookahead = MIN_MATCH$1 - 1\n        fill_window(s)\n      }\n\n      s.strstart += s.lookahead\n      s.block_start = s.strstart\n      s.insert = s.lookahead\n      s.lookahead = 0\n      s.match_length = s.prev_length = MIN_MATCH$1 - 1\n      s.match_available = 0\n      strm.next_in = next\n      strm.input = input\n      strm.avail_in = avail\n      s.wrap = wrap\n      return Z_OK\n    }\n\n    var deflateInit_1 = deflateInit\n    var deflateInit2_1 = deflateInit2\n    var deflateReset_1 = deflateReset\n    var deflateResetKeep_1 = deflateResetKeep\n    var deflateSetHeader_1 = deflateSetHeader\n    var deflate_2 = deflate\n    var deflateEnd_1 = deflateEnd\n    var deflateSetDictionary_1 = deflateSetDictionary\n    var deflateInfo = 'pako deflate (from Nodeca project)'\n    /* Not implemented\n  module.exports.deflateBound = deflateBound;\n  module.exports.deflateCopy = deflateCopy;\n  module.exports.deflateParams = deflateParams;\n  module.exports.deflatePending = deflatePending;\n  module.exports.deflatePrime = deflatePrime;\n  module.exports.deflateTune = deflateTune;\n  */\n\n    var deflate_1 = {\n      deflateInit: deflateInit_1,\n      deflateInit2: deflateInit2_1,\n      deflateReset: deflateReset_1,\n      deflateResetKeep: deflateResetKeep_1,\n      deflateSetHeader: deflateSetHeader_1,\n      deflate: deflate_2,\n      deflateEnd: deflateEnd_1,\n      deflateSetDictionary: deflateSetDictionary_1,\n      deflateInfo,\n    }\n\n    // Join array of chunks to single array.\n    function flattenChunks(chunks) {\n      // calculate data length\n      var len = 0\n\n      for (var i = 0, l = chunks.length; i < l; i++) {\n        len += chunks[i].length\n      } // join chunks\n\n      var result = new Uint8Array(len)\n\n      for (var _i = 0, pos = 0, _l = chunks.length; _i < _l; _i++) {\n        var chunk = chunks[_i]\n        result.set(chunk, pos)\n        pos += chunk.length\n      }\n\n      return result\n    }\n\n    // String encode/decode helpers\n    //\n    // - apply(Array) can fail on Android 2.2\n    // - apply(Uint8Array) can fail on iOS 5.1 Safari\n    //\n\n    // Table with utf8 lengths (calculated by first byte of sequence)\n    // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n    // because max possible codepoint is 0x10ffff\n\n    var _utf8len = new Uint8Array(256)\n\n    for (var q = 0; q < 256; q++) {\n      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1\n    }\n\n    _utf8len[254] = _utf8len[254] = 1 // Invalid sequence start\n    // convert string to array (typed, when possible)\n\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    function ZStream() {\n      /* next input byte */\n      this.input = null // JS specific, because we have no pointers\n\n      this.next_in = 0\n      /* number of bytes available at input */\n\n      this.avail_in = 0\n      /* total number of input bytes read so far */\n\n      this.total_in = 0\n      /* next output byte should be put there */\n\n      this.output = null // JS specific, because we have no pointers\n\n      this.next_out = 0\n      /* remaining free space at output */\n\n      this.avail_out = 0\n      /* total number of bytes output so far */\n\n      this.total_out = 0\n      /* last error message, NULL if no error */\n\n      this.msg = ''\n      /* Z_NULL */\n      /* not visible by applications */\n\n      this.state = null\n      /* best guess about the data type: binary or text */\n\n      this.data_type = 2\n      /* Z_UNKNOWN */\n      /* adler32 value of the uncompressed data */\n\n      this.adler = 0\n    }\n\n    var zstream = ZStream\n\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    var toString = Object.prototype.toString\n    /* Public constants ========================================================== */\n\n    /* =========================================================================== */\n\n    var Z_NO_FLUSH$1 = constants.Z_NO_FLUSH\n    var Z_SYNC_FLUSH = constants.Z_SYNC_FLUSH\n    var Z_FULL_FLUSH$1 = constants.Z_FULL_FLUSH\n    var Z_FINISH$1 = constants.Z_FINISH\n    var Z_OK$1 = constants.Z_OK\n    var Z_STREAM_END$1 = constants.Z_STREAM_END\n    var Z_DEFAULT_COMPRESSION$1 = constants.Z_DEFAULT_COMPRESSION\n    var Z_DEFAULT_STRATEGY$1 = constants.Z_DEFAULT_STRATEGY\n    var Z_DEFLATED$1 = constants.Z_DEFLATED\n    /* =========================================================================== */\n\n    /**\n     * class Deflate\n     *\n     * Generic JS-style wrapper for zlib calls. If you don't need\n     * streaming behaviour - use more simple functions: [[deflate]],\n     * [[deflateRaw]] and [[gzip]].\n     * */\n\n    /* internal\n     * Deflate.chunks -> Array\n     *\n     * Chunks of output data, if [[Deflate#onData]] not overridden.\n     * */\n\n    /**\n     * Deflate.result -> Uint8Array\n     *\n     * Compressed result, generated by default [[Deflate#onData]]\n     * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n     * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n     * */\n\n    /**\n     * Deflate.err -> Number\n     *\n     * Error code after deflate finished. 0 (Z_OK) on success.\n     * You will not need it in real life, because deflate errors\n     * are possible only on wrong options or bad `onData` / `onEnd`\n     * custom handlers.\n     * */\n\n    /**\n     * Deflate.msg -> String\n     *\n     * Error message, if [[Deflate.err]] != 0\n     * */\n\n    /**\n     * new Deflate(options)\n     * - options (Object): zlib deflate options.\n     *\n     * Creates new deflator instance with specified params. Throws exception\n     * on bad params. Supported options:\n     *\n     * - `level`\n     * - `windowBits`\n     * - `memLevel`\n     * - `strategy`\n     * - `dictionary`\n     *\n     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n     * for more information on these.\n     *\n     * Additional options, for internal needs:\n     *\n     * * `chunkSize` - size of generated data chunks (16K by default)\n     * * `raw` (Boolean) - do raw deflate\n     * * `gzip` (Boolean) - create gzip wrapper\n     * * `header` (Object) - custom header for gzip\n     * ** `text` (Boolean) - true if compressed data believed to be text\n     * ** `time` (Number) - modification time, unix timestamp\n     * ** `os` (Number) - operation system code\n     * ** `extra` (Array) - array of bytes with extra data (max 65536)\n     * ** `name` (String) - file name (binary string)\n     * ** `comment` (String) - comment (binary string)\n     * ** `hcrc` (Boolean) - true if header crc should be added\n     *\n     * ##### Example:\n     *\n     * ```javascript\n     * const pako = require('pako')\n     *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n     *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n     *\n     * const deflate = new pako.Deflate({ level: 3});\n     *\n     * deflate.push(chunk1, false);\n     * deflate.push(chunk2, true);  // true -> last chunk\n     *\n     * if (deflate.err) { throw new Error(deflate.err); }\n     *\n     * console.log(deflate.result);\n     * ```\n     * */\n\n    function Deflate() {\n      this.options = {\n        level: Z_DEFAULT_COMPRESSION$1,\n        method: Z_DEFLATED$1,\n        chunkSize: 16384,\n        windowBits: 15,\n        memLevel: 8,\n        strategy: Z_DEFAULT_STRATEGY$1,\n      }\n      var opt = this.options\n\n      if (opt.raw && opt.windowBits > 0) {\n        opt.windowBits = -opt.windowBits\n      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n        opt.windowBits += 16\n      }\n\n      this.err = 0 // error code, if happens (0 = Z_OK)\n\n      this.msg = '' // error message\n\n      this.ended = false // used to avoid multiple onEnd() calls\n\n      this.chunks = [] // chunks of compressed data\n\n      this.strm = new zstream()\n      this.strm.avail_out = 0\n      var status = deflate_1.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy)\n\n      if (status !== Z_OK$1) {\n        throw new Error(messages[status])\n      }\n\n      if (opt.header) {\n        deflate_1.deflateSetHeader(this.strm, opt.header)\n      }\n\n      if (opt.dictionary) {\n        var dict // Convert data if needed\n\n        if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n          dict = new Uint8Array(opt.dictionary)\n        } else {\n          dict = opt.dictionary\n        }\n\n        status = deflate_1.deflateSetDictionary(this.strm, dict)\n\n        if (status !== Z_OK$1) {\n          throw new Error(messages[status])\n        }\n\n        this._dict_set = true\n      }\n    }\n    /**\n     * Deflate#push(data[, flush_mode]) -> Boolean\n     * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n     * converted to utf8 byte sequence.\n     * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n     * See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n     *\n     * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n     * new compressed chunks. Returns `true` on success. The last data block must\n     * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n     * buffers and call [[Deflate#onEnd]].\n     *\n     * On fail call [[Deflate#onEnd]] with error code and return false.\n     *\n     * ##### Example\n     *\n     * ```javascript\n     * push(chunk, false); // push one of data chunks\n     * ...\n     * push(chunk, true);  // push last chunk\n     * ```\n     * */\n\n    Deflate.prototype.push = function (data, flush_mode) {\n      var strm = this.strm\n      var chunkSize = this.options.chunkSize\n\n      var status\n      var _flush_mode\n\n      if (this.ended) {\n        return false\n      }\n\n      if (flush_mode === ~~flush_mode) {\n        _flush_mode = flush_mode\n      } else {\n        _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1\n      } // Convert data if needed\n\n      if (toString.call(data) === '[object ArrayBuffer]') {\n        strm.input = new Uint8Array(data)\n      } else {\n        strm.input = data\n      }\n\n      strm.next_in = 0\n      strm.avail_in = strm.input.length\n\n      for (;;) {\n        if (strm.avail_out === 0) {\n          strm.output = new Uint8Array(chunkSize)\n          strm.next_out = 0\n          strm.avail_out = chunkSize\n        } // Make sure avail_out > 6 to avoid repeating markers\n\n        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {\n          this.onData(strm.output.subarray(0, strm.next_out))\n          strm.avail_out = 0\n          continue\n        }\n\n        status = deflate_1.deflate(strm, _flush_mode) // Ended => flush and finish\n\n        if (status === Z_STREAM_END$1) {\n          if (strm.next_out > 0) {\n            this.onData(strm.output.subarray(0, strm.next_out))\n          }\n\n          status = deflate_1.deflateEnd(this.strm)\n          this.onEnd(status)\n          this.ended = true\n          return status === Z_OK$1\n        } // Flush if out buffer full\n\n        if (strm.avail_out === 0) {\n          this.onData(strm.output)\n          continue\n        } // Flush if requested and has data\n\n        if (_flush_mode > 0 && strm.next_out > 0) {\n          this.onData(strm.output.subarray(0, strm.next_out))\n          strm.avail_out = 0\n          continue\n        }\n\n        if (strm.avail_in === 0) {\n          break\n        }\n      }\n\n      return true\n    }\n    /**\n     * Deflate#onData(chunk) -> Void\n     * - chunk (Uint8Array): output data.\n     *\n     * By default, stores data blocks in `chunks[]` property and glue\n     * those in `onEnd`. Override this handler, if you need another behaviour.\n     * */\n\n    Deflate.prototype.onData = function (chunk) {\n      this.chunks.push(chunk)\n    }\n    /**\n     * Deflate#onEnd(status) -> Void\n     * - status (Number): deflate status. 0 (Z_OK) on success,\n     * other if not.\n     *\n     * Called once after you tell deflate that the input stream is\n     * complete (Z_FINISH). By default - join collected chunks,\n     * free memory and fill `results` / `err` properties.\n     * */\n\n    Deflate.prototype.onEnd = function (status) {\n      // On success - join\n      if (status === Z_OK$1) {\n        this.result = flattenChunks(this.chunks)\n      }\n\n      this.chunks = []\n      this.err = status\n      this.msg = this.strm.msg\n    }\n\n    // https://github.com/nodeca/pako/blob/26dff4fb3472c5532b3bd8856421146d35ab7592/lib/utils/strings.js#L26\n    function string2buf(str) {\n      if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n        return new TextEncoder().encode(str)\n      }\n\n      let buf\n      let c\n      let c2\n      let m_pos\n      let i\n      let str_len = str.length\n      let buf_len = 0\n\n      // count binary size\n      for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos)\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n          c2 = str.charCodeAt(m_pos + 1)\n          if ((c2 & 0xfc00) === 0xdc00) {\n            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00)\n            m_pos++\n          }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4\n      }\n\n      // allocate buffer\n      buf = new Uint8Array(buf_len)\n\n      // convert\n      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos)\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n          c2 = str.charCodeAt(m_pos + 1)\n          if ((c2 & 0xfc00) === 0xdc00) {\n            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00)\n            m_pos++\n          }\n        }\n        if (c < 0x80) {\n          /* one byte */\n          buf[i++] = c\n        } else if (c < 0x800) {\n          /* two bytes */\n          buf[i++] = 0xc0 | (c >>> 6)\n          buf[i++] = 0x80 | (c & 0x3f)\n        } else if (c < 0x10000) {\n          /* three bytes */\n          buf[i++] = 0xe0 | (c >>> 12)\n          buf[i++] = 0x80 | ((c >>> 6) & 0x3f)\n          buf[i++] = 0x80 | (c & 0x3f)\n        } else {\n          /* four bytes */\n          buf[i++] = 0xf0 | (c >>> 18)\n          buf[i++] = 0x80 | ((c >>> 12) & 0x3f)\n          buf[i++] = 0x80 | ((c >>> 6) & 0x3f)\n          buf[i++] = 0x80 | (c & 0x3f)\n        }\n      }\n\n      return buf\n    }\n\n    return { Deflate, constants, string2buf }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}