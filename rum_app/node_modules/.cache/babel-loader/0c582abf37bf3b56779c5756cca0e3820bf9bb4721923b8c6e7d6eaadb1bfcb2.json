{"ast":null,"code":"import { isElementNode, getParentNode, isTextNode } from '@datadog/browser-rum-core';\nimport { NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_ALLOW, PRIVACY_ATTR_VALUE_MASK, PRIVACY_ATTR_VALUE_MASK_USER_INPUT, PRIVACY_ATTR_VALUE_HIDDEN, PRIVACY_CLASS_ALLOW, PRIVACY_CLASS_MASK, PRIVACY_CLASS_MASK_USER_INPUT, PRIVACY_CLASS_HIDDEN, FORM_PRIVATE_TAG_NAMES, CENSORED_STRING_MARK } from '../../constants';\nexport var MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 100000;\nvar TEXT_MASKING_CHAR = 'x';\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\nexport function getNodePrivacyLevel(node, defaultPrivacyLevel) {\n  var parentNode = getParentNode(node);\n  var parentNodePrivacyLevel = parentNode ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel) : defaultPrivacyLevel;\n  var selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node);\n  return reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel);\n}\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\nexport function reducePrivacyLevel(childPrivacyLevel, parentNodePrivacyLevel) {\n  switch (parentNodePrivacyLevel) {\n    // These values cannot be overridden\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return parentNodePrivacyLevel;\n  }\n  switch (childPrivacyLevel) {\n    case NodePrivacyLevel.ALLOW:\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.MASK_USER_INPUT:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return childPrivacyLevel;\n    default:\n      return parentNodePrivacyLevel;\n  }\n}\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\nexport function getNodeSelfPrivacyLevel(node) {\n  // Only Element types can have a privacy level set\n  if (!isElementNode(node)) {\n    return;\n  }\n  var privAttr = node.getAttribute(PRIVACY_ATTR_NAME);\n  // Overrules for replay purpose\n  if (node.tagName === 'BASE') {\n    return NodePrivacyLevel.ALLOW;\n  }\n  // Overrules to enforce end-user protection\n  if (node.tagName === 'INPUT') {\n    var inputElement = node;\n    if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n      return NodePrivacyLevel.MASK;\n    }\n    if (inputElement.type === 'hidden') {\n      return NodePrivacyLevel.MASK;\n    }\n    var autocomplete = inputElement.getAttribute('autocomplete');\n    // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year]\n    if (autocomplete && autocomplete.indexOf('cc-') === 0) {\n      return NodePrivacyLevel.MASK;\n    }\n  }\n  // Check HTML privacy attributes and classes\n  if (privAttr === PRIVACY_ATTR_VALUE_HIDDEN || node.classList.contains(PRIVACY_CLASS_HIDDEN)) {\n    return NodePrivacyLevel.HIDDEN;\n  }\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK || node.classList.contains(PRIVACY_CLASS_MASK)) {\n    return NodePrivacyLevel.MASK;\n  }\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK_USER_INPUT || node.classList.contains(PRIVACY_CLASS_MASK_USER_INPUT)) {\n    return NodePrivacyLevel.MASK_USER_INPUT;\n  }\n  if (privAttr === PRIVACY_ATTR_VALUE_ALLOW || node.classList.contains(PRIVACY_CLASS_ALLOW)) {\n    return NodePrivacyLevel.ALLOW;\n  }\n  if (shouldIgnoreElement(node)) {\n    return NodePrivacyLevel.IGNORE;\n  }\n}\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\nexport function shouldMaskNode(node, privacyLevel) {\n  switch (privacyLevel) {\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return true;\n    case NodePrivacyLevel.MASK_USER_INPUT:\n      return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node);\n    default:\n      return false;\n  }\n}\nfunction isFormElement(node) {\n  if (!node || node.nodeType !== node.ELEMENT_NODE) {\n    return false;\n  }\n  var element = node;\n  if (element.tagName === 'INPUT') {\n    switch (element.type) {\n      case 'button':\n      case 'color':\n      case 'reset':\n      case 'submit':\n        return false;\n    }\n  }\n  return !!FORM_PRIVATE_TAG_NAMES[element.tagName];\n}\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\nexport var censorText = function (text) {\n  return text.replace(/\\S/g, TEXT_MASKING_CHAR);\n};\nexport function getTextContent(textNode, ignoreWhiteSpace, parentNodePrivacyLevel) {\n  var _a;\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  var parentTagName = (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.tagName;\n  var textContent = textNode.textContent || '';\n  if (ignoreWhiteSpace && !textContent.trim()) {\n    return;\n  }\n  var nodePrivacyLevel = parentNodePrivacyLevel;\n  var isStyle = parentTagName === 'STYLE' ? true : undefined;\n  var isScript = parentTagName === 'SCRIPT';\n  if (isScript) {\n    // For perf reasons, we don't record script (heuristic)\n    textContent = CENSORED_STRING_MARK;\n  } else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // Should never occur, but just in case, we set to CENSORED_MARK.\n    textContent = CENSORED_STRING_MARK;\n  } else if (shouldMaskNode(textNode, nodePrivacyLevel) &&\n  // Style tags are `overruled` (Use `hide` to enforce privacy)\n  !isStyle) {\n    if (\n    // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n    parentTagName === 'DATALIST' || parentTagName === 'SELECT' || parentTagName === 'OPTGROUP') {\n      if (!textContent.trim()) {\n        return;\n      }\n    } else if (parentTagName === 'OPTION') {\n      // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n      textContent = CENSORED_STRING_MARK;\n    } else {\n      textContent = censorText(textContent);\n    }\n  }\n  return textContent;\n}\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\nexport function shouldIgnoreElement(element) {\n  if (element.nodeName === 'SCRIPT') {\n    return true;\n  }\n  if (element.nodeName === 'LINK') {\n    var relAttribute = getLowerCaseAttribute('rel');\n    return (\n      // Link as script - Ignore only when rel=preload, modulepreload or prefetch\n      /preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute('as') === 'script' ||\n      // Favicons\n      relAttribute === 'shortcut icon' || relAttribute === 'icon'\n    );\n  }\n  if (element.nodeName === 'META') {\n    var nameAttribute = getLowerCaseAttribute('name');\n    var relAttribute = getLowerCaseAttribute('rel');\n    var propertyAttribute = getLowerCaseAttribute('property');\n    return (\n      // Favicons\n      /^msapplication-tile(image|color)$/.test(nameAttribute) || nameAttribute === 'application-name' || relAttribute === 'icon' || relAttribute === 'apple-touch-icon' || relAttribute === 'shortcut icon' ||\n      // Description\n      nameAttribute === 'keywords' || nameAttribute === 'description' ||\n      // Social\n      /^(og|twitter|fb):/.test(propertyAttribute) || /^(og|twitter):/.test(nameAttribute) || nameAttribute === 'pinterest' ||\n      // Robots\n      nameAttribute === 'robots' || nameAttribute === 'googlebot' || nameAttribute === 'bingbot' ||\n      // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n      // X-Translated-By\n      element.hasAttribute('http-equiv') ||\n      // Authorship\n      nameAttribute === 'author' || nameAttribute === 'generator' || nameAttribute === 'framework' || nameAttribute === 'publisher' || nameAttribute === 'progid' || /^article:/.test(propertyAttribute) || /^product:/.test(propertyAttribute) ||\n      // Verification\n      nameAttribute === 'google-site-verification' || nameAttribute === 'yandex-verification' || nameAttribute === 'csrf-token' || nameAttribute === 'p:domain_verify' || nameAttribute === 'verify-v1' || nameAttribute === 'verification' || nameAttribute === 'shopify-checkout-api-token'\n    );\n  }\n  function getLowerCaseAttribute(name) {\n    return (element.getAttribute(name) || '').toLowerCase();\n  }\n  return false;\n}","map":{"version":3,"names":["isElementNode","getParentNode","isTextNode","NodePrivacyLevel","PRIVACY_ATTR_NAME","PRIVACY_ATTR_VALUE_ALLOW","PRIVACY_ATTR_VALUE_MASK","PRIVACY_ATTR_VALUE_MASK_USER_INPUT","PRIVACY_ATTR_VALUE_HIDDEN","PRIVACY_CLASS_ALLOW","PRIVACY_CLASS_MASK","PRIVACY_CLASS_MASK_USER_INPUT","PRIVACY_CLASS_HIDDEN","FORM_PRIVATE_TAG_NAMES","CENSORED_STRING_MARK","MAX_ATTRIBUTE_VALUE_CHAR_LENGTH","TEXT_MASKING_CHAR","getNodePrivacyLevel","node","defaultPrivacyLevel","parentNode","parentNodePrivacyLevel","selfNodePrivacyLevel","getNodeSelfPrivacyLevel","reducePrivacyLevel","childPrivacyLevel","HIDDEN","IGNORE","ALLOW","MASK","MASK_USER_INPUT","privAttr","getAttribute","tagName","inputElement","type","autocomplete","indexOf","classList","contains","shouldIgnoreElement","shouldMaskNode","privacyLevel","isFormElement","nodeType","ELEMENT_NODE","element","censorText","text","replace","getTextContent","textNode","ignoreWhiteSpace","parentTagName","_a","parentElement","textContent","trim","nodePrivacyLevel","isStyle","undefined","isScript","nodeName","relAttribute","getLowerCaseAttribute","test","nameAttribute","propertyAttribute","hasAttribute","name","toLowerCase"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/apm-enablement-sessions/rum_and_trace_correlation/react-app/node_modules/@datadog/browser-rum/src/domain/record/privacy.ts"],"sourcesContent":["import { isElementNode, getParentNode, isTextNode } from '@datadog/browser-rum-core'\nimport {\n  NodePrivacyLevel,\n  PRIVACY_ATTR_NAME,\n  PRIVACY_ATTR_VALUE_ALLOW,\n  PRIVACY_ATTR_VALUE_MASK,\n  PRIVACY_ATTR_VALUE_MASK_USER_INPUT,\n  PRIVACY_ATTR_VALUE_HIDDEN,\n  PRIVACY_CLASS_ALLOW,\n  PRIVACY_CLASS_MASK,\n  PRIVACY_CLASS_MASK_USER_INPUT,\n  PRIVACY_CLASS_HIDDEN,\n  FORM_PRIVATE_TAG_NAMES,\n  CENSORED_STRING_MARK,\n} from '../../constants'\n\nexport const MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 100_000\n\nconst TEXT_MASKING_CHAR = 'x'\n\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\nexport function getNodePrivacyLevel(node: Node, defaultPrivacyLevel: NodePrivacyLevel): NodePrivacyLevel {\n  const parentNode = getParentNode(node)\n  const parentNodePrivacyLevel = parentNode ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel) : defaultPrivacyLevel\n  const selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node)\n  return reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel)\n}\n\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\nexport function reducePrivacyLevel(\n  childPrivacyLevel: NodePrivacyLevel | undefined,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): NodePrivacyLevel {\n  switch (parentNodePrivacyLevel) {\n    // These values cannot be overridden\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return parentNodePrivacyLevel\n  }\n  switch (childPrivacyLevel) {\n    case NodePrivacyLevel.ALLOW:\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.MASK_USER_INPUT:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return childPrivacyLevel\n    default:\n      return parentNodePrivacyLevel\n  }\n}\n\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\nexport function getNodeSelfPrivacyLevel(node: Node): NodePrivacyLevel | undefined {\n  // Only Element types can have a privacy level set\n  if (!isElementNode(node)) {\n    return\n  }\n\n  const privAttr = node.getAttribute(PRIVACY_ATTR_NAME)\n\n  // Overrules for replay purpose\n  if (node.tagName === 'BASE') {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  // Overrules to enforce end-user protection\n  if (node.tagName === 'INPUT') {\n    const inputElement = node as HTMLInputElement\n    if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n      return NodePrivacyLevel.MASK\n    }\n    if (inputElement.type === 'hidden') {\n      return NodePrivacyLevel.MASK\n    }\n    const autocomplete = inputElement.getAttribute('autocomplete')\n    // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year]\n    if (autocomplete && autocomplete.indexOf('cc-') === 0) {\n      return NodePrivacyLevel.MASK\n    }\n  }\n\n  // Check HTML privacy attributes and classes\n  if (privAttr === PRIVACY_ATTR_VALUE_HIDDEN || node.classList.contains(PRIVACY_CLASS_HIDDEN)) {\n    return NodePrivacyLevel.HIDDEN\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK || node.classList.contains(PRIVACY_CLASS_MASK)) {\n    return NodePrivacyLevel.MASK\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK_USER_INPUT || node.classList.contains(PRIVACY_CLASS_MASK_USER_INPUT)) {\n    return NodePrivacyLevel.MASK_USER_INPUT\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_ALLOW || node.classList.contains(PRIVACY_CLASS_ALLOW)) {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  if (shouldIgnoreElement(node)) {\n    return NodePrivacyLevel.IGNORE\n  }\n}\n\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\nexport function shouldMaskNode(node: Node, privacyLevel: NodePrivacyLevel) {\n  switch (privacyLevel) {\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return true\n    case NodePrivacyLevel.MASK_USER_INPUT:\n      return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node)\n    default:\n      return false\n  }\n}\n\nfunction isFormElement(node: Node | null): boolean {\n  if (!node || node.nodeType !== node.ELEMENT_NODE) {\n    return false\n  }\n  const element = node as HTMLInputElement\n  if (element.tagName === 'INPUT') {\n    switch (element.type) {\n      case 'button':\n      case 'color':\n      case 'reset':\n      case 'submit':\n        return false\n    }\n  }\n  return !!FORM_PRIVATE_TAG_NAMES[element.tagName]\n}\n\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\nexport const censorText = (text: string) => text.replace(/\\S/g, TEXT_MASKING_CHAR)\n\nexport function getTextContent(\n  textNode: Node,\n  ignoreWhiteSpace: boolean,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): string | undefined {\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = textNode.parentElement?.tagName\n  let textContent = textNode.textContent || ''\n\n  if (ignoreWhiteSpace && !textContent.trim()) {\n    return\n  }\n\n  const nodePrivacyLevel = parentNodePrivacyLevel\n\n  const isStyle = parentTagName === 'STYLE' ? true : undefined\n  const isScript = parentTagName === 'SCRIPT'\n\n  if (isScript) {\n    // For perf reasons, we don't record script (heuristic)\n    textContent = CENSORED_STRING_MARK\n  } else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // Should never occur, but just in case, we set to CENSORED_MARK.\n    textContent = CENSORED_STRING_MARK\n  } else if (\n    shouldMaskNode(textNode, nodePrivacyLevel) &&\n    // Style tags are `overruled` (Use `hide` to enforce privacy)\n    !isStyle\n  ) {\n    if (\n      // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n      parentTagName === 'DATALIST' ||\n      parentTagName === 'SELECT' ||\n      parentTagName === 'OPTGROUP'\n    ) {\n      if (!textContent.trim()) {\n        return\n      }\n    } else if (parentTagName === 'OPTION') {\n      // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n      textContent = CENSORED_STRING_MARK\n    } else {\n      textContent = censorText(textContent)\n    }\n  }\n  return textContent\n}\n\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\nexport function shouldIgnoreElement(element: Element): boolean {\n  if (element.nodeName === 'SCRIPT') {\n    return true\n  }\n\n  if (element.nodeName === 'LINK') {\n    const relAttribute = getLowerCaseAttribute('rel')\n    return (\n      // Link as script - Ignore only when rel=preload, modulepreload or prefetch\n      (/preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute('as') === 'script') ||\n      // Favicons\n      relAttribute === 'shortcut icon' ||\n      relAttribute === 'icon'\n    )\n  }\n\n  if (element.nodeName === 'META') {\n    const nameAttribute = getLowerCaseAttribute('name')\n    const relAttribute = getLowerCaseAttribute('rel')\n    const propertyAttribute = getLowerCaseAttribute('property')\n    return (\n      // Favicons\n      /^msapplication-tile(image|color)$/.test(nameAttribute) ||\n      nameAttribute === 'application-name' ||\n      relAttribute === 'icon' ||\n      relAttribute === 'apple-touch-icon' ||\n      relAttribute === 'shortcut icon' ||\n      // Description\n      nameAttribute === 'keywords' ||\n      nameAttribute === 'description' ||\n      // Social\n      /^(og|twitter|fb):/.test(propertyAttribute) ||\n      /^(og|twitter):/.test(nameAttribute) ||\n      nameAttribute === 'pinterest' ||\n      // Robots\n      nameAttribute === 'robots' ||\n      nameAttribute === 'googlebot' ||\n      nameAttribute === 'bingbot' ||\n      // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n      // X-Translated-By\n      element.hasAttribute('http-equiv') ||\n      // Authorship\n      nameAttribute === 'author' ||\n      nameAttribute === 'generator' ||\n      nameAttribute === 'framework' ||\n      nameAttribute === 'publisher' ||\n      nameAttribute === 'progid' ||\n      /^article:/.test(propertyAttribute) ||\n      /^product:/.test(propertyAttribute) ||\n      // Verification\n      nameAttribute === 'google-site-verification' ||\n      nameAttribute === 'yandex-verification' ||\n      nameAttribute === 'csrf-token' ||\n      nameAttribute === 'p:domain_verify' ||\n      nameAttribute === 'verify-v1' ||\n      nameAttribute === 'verification' ||\n      nameAttribute === 'shopify-checkout-api-token'\n    )\n  }\n\n  function getLowerCaseAttribute(name: string) {\n    return (element.getAttribute(name) || '').toLowerCase()\n  }\n\n  return false\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}