{"ast":null,"code":"import { monitor, noop } from '@datadog/browser-core';\nimport { getChildNodes, isNodeShadowHost, getMutationObserverConstructor, getParentNode } from '@datadog/browser-rum-core';\nimport { NodePrivacyLevel } from '../../constants';\nimport { getNodePrivacyLevel, getTextContent } from './privacy';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode, nodeAndAncestorsHaveSerializedNode } from './serializationUtils';\nimport { serializeNodeWithId, serializeAttribute } from './serialize';\nimport { createMutationBatch } from './mutationBatch';\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function startMutationObserver(mutationCallback, configuration, shadowRootsController, target) {\n  var MutationObserver = getMutationObserverConstructor();\n  if (!MutationObserver) {\n    return {\n      stop: noop,\n      flush: noop\n    };\n  }\n  var mutationBatch = createMutationBatch(function (mutations) {\n    processMutations(mutations.concat(observer.takeRecords()), mutationCallback, configuration, shadowRootsController, target);\n  });\n  var observer = new MutationObserver(monitor(mutationBatch.addMutations));\n  observer.observe(target, {\n    attributeOldValue: true,\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  return {\n    stop: function () {\n      observer.disconnect();\n      mutationBatch.stop();\n    },\n    flush: function () {\n      mutationBatch.flush();\n    }\n  };\n}\nfunction processMutations(mutations, mutationCallback, configuration, shadowRootsController, target) {\n  mutations.filter(function (mutation) {\n    return mutation.type === 'childList';\n  }).forEach(function (mutation) {\n    mutation.removedNodes.forEach(function (removedNode) {\n      traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot);\n    });\n  });\n  // Discard any mutation with a 'target' node that:\n  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n  // part of a mutation occurring in a parent Node\n  // * should be hidden or ignored\n  var filteredMutations = mutations.filter(function (mutation) {\n    return target.contains(mutation.target) && nodeAndAncestorsHaveSerializedNode(mutation.target) && getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel) !== NodePrivacyLevel.HIDDEN;\n  });\n  var _a = processChildListMutations(filteredMutations.filter(function (mutation) {\n      return mutation.type === 'childList';\n    }), configuration, shadowRootsController),\n    adds = _a.adds,\n    removes = _a.removes,\n    hasBeenSerialized = _a.hasBeenSerialized;\n  var texts = processCharacterDataMutations(filteredMutations.filter(function (mutation) {\n    return mutation.type === 'characterData' && !hasBeenSerialized(mutation.target);\n  }), configuration);\n  var attributes = processAttributesMutations(filteredMutations.filter(function (mutation) {\n    return mutation.type === 'attributes' && !hasBeenSerialized(mutation.target);\n  }), configuration);\n  if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n    return;\n  }\n  mutationCallback({\n    adds: adds,\n    removes: removes,\n    texts: texts,\n    attributes: attributes\n  });\n}\nfunction processChildListMutations(mutations, configuration, shadowRootsController) {\n  // First, we iterate over mutations to collect:\n  //\n  // * nodes that have been added in the document and not removed by a subsequent mutation\n  // * nodes that have been removed from the document but were not added in a previous mutation\n  //\n  // For this second category, we also collect their previous parent (mutation.target) because we'll\n  // need it to emit a 'remove' mutation.\n  //\n  // Those two categories may overlap: if a node moved from a position to another, it is reported as\n  // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n  // the node will be in both sets.\n  var addedAndMovedNodes = new Set();\n  var removedNodes = new Map();\n  var _loop_1 = function (mutation) {\n    mutation.addedNodes.forEach(function (node) {\n      addedAndMovedNodes.add(node);\n    });\n    mutation.removedNodes.forEach(function (node) {\n      if (!addedAndMovedNodes.has(node)) {\n        removedNodes.set(node, mutation.target);\n      }\n      addedAndMovedNodes.delete(node);\n    });\n  };\n  for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n    var mutation = mutations_1[_i];\n    _loop_1(mutation);\n  }\n  // Then, we sort nodes that are still in the document by topological order, for two reasons:\n  //\n  // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n  // a precedent node.\n  //\n  // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n  // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n  // already serialized and have an id.\n  var sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes);\n  sortAddedAndMovedNodes(sortedAddedAndMovedNodes);\n  // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n  // node ids in a set to be able to skip subsequent related mutations.\n  var serializedNodeIds = new Set();\n  var addedNodeMutations = [];\n  for (var _a = 0, sortedAddedAndMovedNodes_1 = sortedAddedAndMovedNodes; _a < sortedAddedAndMovedNodes_1.length; _a++) {\n    var node = sortedAddedAndMovedNodes_1[_a];\n    if (hasBeenSerialized(node)) {\n      continue;\n    }\n    var parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode, configuration.defaultPrivacyLevel);\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue;\n    }\n    var serializedNode = serializeNodeWithId(node, {\n      serializedNodeIds: serializedNodeIds,\n      parentNodePrivacyLevel: parentNodePrivacyLevel,\n      serializationContext: {\n        status: 2 /* MUTATION */,\n        shadowRootsController: shadowRootsController\n      },\n      configuration: configuration\n    });\n    if (!serializedNode) {\n      continue;\n    }\n    var parentNode = getParentNode(node);\n    addedNodeMutations.push({\n      nextId: getNextSibling(node),\n      parentId: getSerializedNodeId(parentNode),\n      node: serializedNode\n    });\n  }\n  // Finally, we emit remove mutations.\n  var removedNodeMutations = [];\n  removedNodes.forEach(function (parent, node) {\n    if (hasSerializedNode(node)) {\n      removedNodeMutations.push({\n        parentId: getSerializedNodeId(parent),\n        id: getSerializedNodeId(node)\n      });\n    }\n  });\n  return {\n    adds: addedNodeMutations,\n    removes: removedNodeMutations,\n    hasBeenSerialized: hasBeenSerialized\n  };\n  function hasBeenSerialized(node) {\n    return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node));\n  }\n  function getNextSibling(node) {\n    var nextSibling = node.nextSibling;\n    while (nextSibling) {\n      if (hasSerializedNode(nextSibling)) {\n        return getSerializedNodeId(nextSibling);\n      }\n      nextSibling = nextSibling.nextSibling;\n    }\n    return null;\n  }\n}\nfunction processCharacterDataMutations(mutations, configuration) {\n  var _a;\n  var textMutations = [];\n  // Deduplicate mutations based on their target node\n  var handledNodes = new Set();\n  var filteredMutations = mutations.filter(function (mutation) {\n    if (handledNodes.has(mutation.target)) {\n      return false;\n    }\n    handledNodes.add(mutation.target);\n    return true;\n  });\n  // Emit mutations\n  for (var _i = 0, filteredMutations_1 = filteredMutations; _i < filteredMutations_1.length; _i++) {\n    var mutation = filteredMutations_1[_i];\n    var value = mutation.target.textContent;\n    if (value === mutation.oldValue) {\n      continue;\n    }\n    var parentNodePrivacyLevel = getNodePrivacyLevel(getParentNode(mutation.target), configuration.defaultPrivacyLevel);\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue;\n    }\n    textMutations.push({\n      id: getSerializedNodeId(mutation.target),\n      // TODO: pass a valid \"ignoreWhiteSpace\" argument\n      value: (_a = getTextContent(mutation.target, false, parentNodePrivacyLevel)) !== null && _a !== void 0 ? _a : null\n    });\n  }\n  return textMutations;\n}\nfunction processAttributesMutations(mutations, configuration) {\n  var attributeMutations = [];\n  // Deduplicate mutations based on their target node and changed attribute\n  var handledElements = new Map();\n  var filteredMutations = mutations.filter(function (mutation) {\n    var handledAttributes = handledElements.get(mutation.target);\n    if (handledAttributes === null || handledAttributes === void 0 ? void 0 : handledAttributes.has(mutation.attributeName)) {\n      return false;\n    }\n    if (!handledAttributes) {\n      handledElements.set(mutation.target, new Set([mutation.attributeName]));\n    } else {\n      handledAttributes.add(mutation.attributeName);\n    }\n    return true;\n  });\n  // Emit mutations\n  var emittedMutations = new Map();\n  for (var _i = 0, filteredMutations_2 = filteredMutations; _i < filteredMutations_2.length; _i++) {\n    var mutation = filteredMutations_2[_i];\n    var uncensoredValue = mutation.target.getAttribute(mutation.attributeName);\n    if (uncensoredValue === mutation.oldValue) {\n      continue;\n    }\n    var privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel);\n    var attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName, configuration);\n    var transformedValue = void 0;\n    if (mutation.attributeName === 'value') {\n      var inputValue = getElementInputValue(mutation.target, privacyLevel);\n      if (inputValue === undefined) {\n        continue;\n      }\n      transformedValue = inputValue;\n    } else if (typeof attributeValue === 'string') {\n      transformedValue = attributeValue;\n    } else {\n      transformedValue = null;\n    }\n    var emittedMutation = emittedMutations.get(mutation.target);\n    if (!emittedMutation) {\n      emittedMutation = {\n        id: getSerializedNodeId(mutation.target),\n        attributes: {}\n      };\n      attributeMutations.push(emittedMutation);\n      emittedMutations.set(mutation.target, emittedMutation);\n    }\n    emittedMutation.attributes[mutation.attributeName] = transformedValue;\n  }\n  return attributeMutations;\n}\nexport function sortAddedAndMovedNodes(nodes) {\n  nodes.sort(function (a, b) {\n    var position = a.compareDocumentPosition(b);\n    /* eslint-disable no-bitwise */\n    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1;\n    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1;\n    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return 1;\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return -1;\n    }\n    /* eslint-enable no-bitwise */\n    return 0;\n  });\n}\nfunction traverseRemovedShadowDom(removedNode, shadowDomRemovedCallback) {\n  if (isNodeShadowHost(removedNode)) {\n    shadowDomRemovedCallback(removedNode.shadowRoot);\n  }\n  getChildNodes(removedNode).forEach(function (child) {\n    return traverseRemovedShadowDom(child, shadowDomRemovedCallback);\n  });\n}","map":{"version":3,"names":["monitor","noop","getChildNodes","isNodeShadowHost","getMutationObserverConstructor","getParentNode","NodePrivacyLevel","getNodePrivacyLevel","getTextContent","getElementInputValue","getSerializedNodeId","hasSerializedNode","nodeAndAncestorsHaveSerializedNode","serializeNodeWithId","serializeAttribute","createMutationBatch","startMutationObserver","mutationCallback","configuration","shadowRootsController","target","MutationObserver","stop","flush","mutationBatch","mutations","processMutations","concat","observer","takeRecords","addMutations","observe","attributeOldValue","attributes","characterData","characterDataOldValue","childList","subtree","disconnect","filter","mutation","type","forEach","removedNodes","removedNode","traverseRemovedShadowDom","removeShadowRoot","filteredMutations","contains","defaultPrivacyLevel","HIDDEN","_a","processChildListMutations","adds","removes","hasBeenSerialized","texts","processCharacterDataMutations","processAttributesMutations","length","addedAndMovedNodes","Set","Map","addedNodes","node","add","has","set","delete","_i","mutations_1","sortedAddedAndMovedNodes","Array","from","sortAddedAndMovedNodes","serializedNodeIds","addedNodeMutations","sortedAddedAndMovedNodes_1","parentNodePrivacyLevel","parentNode","IGNORE","serializedNode","serializationContext","status","push","nextId","getNextSibling","parentId","removedNodeMutations","parent","id","nextSibling","textMutations","handledNodes","filteredMutations_1","value","textContent","oldValue","attributeMutations","handledElements","handledAttributes","get","attributeName","emittedMutations","filteredMutations_2","uncensoredValue","getAttribute","privacyLevel","attributeValue","transformedValue","inputValue","undefined","emittedMutation","nodes","sort","a","b","position","compareDocumentPosition","Node","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","shadowDomRemovedCallback","shadowRoot","child"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/apm-enablement-sessions/rum_and_trace_correlation/rum_app/node_modules/@datadog/browser-rum/src/domain/record/mutationObserver.ts"],"sourcesContent":["import { monitor, noop } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport {\n  getChildNodes,\n  isNodeShadowHost,\n  getMutationObserverConstructor,\n  getParentNode,\n} from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel } from '../../constants'\nimport type { AddedNodeMutation, AttributeMutation, RemovedNodeMutation, TextMutation } from '../../types'\nimport { getNodePrivacyLevel, getTextContent } from './privacy'\nimport type { NodeWithSerializedNode } from './serializationUtils'\nimport {\n  getElementInputValue,\n  getSerializedNodeId,\n  hasSerializedNode,\n  nodeAndAncestorsHaveSerializedNode,\n} from './serializationUtils'\nimport { serializeNodeWithId, serializeAttribute, SerializationContextStatus } from './serialize'\nimport { createMutationBatch } from './mutationBatch'\nimport type { MutationCallBack } from './observers'\nimport type { ShadowRootCallBack, ShadowRootsController } from './shadowRootsController'\n\ntype WithSerializedTarget<T> = T & { target: NodeWithSerializedNode }\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\ninterface RumCharacterDataMutationRecord {\n  type: 'characterData'\n  target: Node\n  oldValue: string | null\n}\n\ninterface RumAttributesMutationRecord {\n  type: 'attributes'\n  target: Element\n  oldValue: string | null\n  attributeName: string | null\n}\n\ninterface RumChildListMutationRecord {\n  type: 'childList'\n  target: Node\n  addedNodes: NodeList\n  removedNodes: NodeList\n}\n\nexport type RumMutationRecord =\n  | RumCharacterDataMutationRecord\n  | RumAttributesMutationRecord\n  | RumChildListMutationRecord\n\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function startMutationObserver(\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController,\n  target: Node\n) {\n  const MutationObserver = getMutationObserverConstructor()\n  if (!MutationObserver) {\n    return { stop: noop, flush: noop }\n  }\n\n  const mutationBatch = createMutationBatch((mutations) => {\n    processMutations(\n      mutations.concat(observer.takeRecords() as RumMutationRecord[]),\n      mutationCallback,\n      configuration,\n      shadowRootsController,\n      target\n    )\n  })\n\n  const observer = new MutationObserver(monitor(mutationBatch.addMutations) as (callback: MutationRecord[]) => void)\n\n  observer.observe(target, {\n    attributeOldValue: true,\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  })\n\n  return {\n    stop: () => {\n      observer.disconnect()\n      mutationBatch.stop()\n    },\n    flush: () => {\n      mutationBatch.flush()\n    },\n  }\n}\n\nfunction processMutations(\n  mutations: RumMutationRecord[],\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController,\n  target: Node\n) {\n  mutations\n    .filter((mutation): mutation is RumChildListMutationRecord => mutation.type === 'childList')\n    .forEach((mutation) => {\n      mutation.removedNodes.forEach((removedNode) => {\n        traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot)\n      })\n    })\n\n  // Discard any mutation with a 'target' node that:\n  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n  // part of a mutation occurring in a parent Node\n  // * should be hidden or ignored\n  const filteredMutations = mutations.filter(\n    (mutation): mutation is WithSerializedTarget<RumMutationRecord> =>\n      target.contains(mutation.target) &&\n      nodeAndAncestorsHaveSerializedNode(mutation.target) &&\n      getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel) !== NodePrivacyLevel.HIDDEN\n  )\n\n  const { adds, removes, hasBeenSerialized } = processChildListMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumChildListMutationRecord> => mutation.type === 'childList'\n    ),\n    configuration,\n    shadowRootsController\n  )\n\n  const texts = processCharacterDataMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumCharacterDataMutationRecord> =>\n        mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration\n  )\n\n  const attributes = processAttributesMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumAttributesMutationRecord> =>\n        mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration\n  )\n\n  if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n    return\n  }\n\n  mutationCallback({\n    adds,\n    removes,\n    texts,\n    attributes,\n  })\n}\n\nfunction processChildListMutations(\n  mutations: Array<WithSerializedTarget<RumChildListMutationRecord>>,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController\n) {\n  // First, we iterate over mutations to collect:\n  //\n  // * nodes that have been added in the document and not removed by a subsequent mutation\n  // * nodes that have been removed from the document but were not added in a previous mutation\n  //\n  // For this second category, we also collect their previous parent (mutation.target) because we'll\n  // need it to emit a 'remove' mutation.\n  //\n  // Those two categories may overlap: if a node moved from a position to another, it is reported as\n  // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n  // the node will be in both sets.\n  const addedAndMovedNodes = new Set<Node>()\n  const removedNodes = new Map<Node, NodeWithSerializedNode>()\n  for (const mutation of mutations) {\n    mutation.addedNodes.forEach((node) => {\n      addedAndMovedNodes.add(node)\n    })\n    mutation.removedNodes.forEach((node) => {\n      if (!addedAndMovedNodes.has(node)) {\n        removedNodes.set(node, mutation.target)\n      }\n      addedAndMovedNodes.delete(node)\n    })\n  }\n\n  // Then, we sort nodes that are still in the document by topological order, for two reasons:\n  //\n  // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n  // a precedent node.\n  //\n  // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n  // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n  // already serialized and have an id.\n  const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes)\n  sortAddedAndMovedNodes(sortedAddedAndMovedNodes)\n\n  // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n  // node ids in a set to be able to skip subsequent related mutations.\n  const serializedNodeIds = new Set<number>()\n\n  const addedNodeMutations: AddedNodeMutation[] = []\n  for (const node of sortedAddedAndMovedNodes) {\n    if (hasBeenSerialized(node)) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode!, configuration.defaultPrivacyLevel)\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    const serializedNode = serializeNodeWithId(node, {\n      serializedNodeIds,\n      parentNodePrivacyLevel,\n      serializationContext: { status: SerializationContextStatus.MUTATION, shadowRootsController },\n      configuration,\n    })\n    if (!serializedNode) {\n      continue\n    }\n\n    const parentNode = getParentNode(node)!\n    addedNodeMutations.push({\n      nextId: getNextSibling(node),\n      parentId: getSerializedNodeId(parentNode)!,\n      node: serializedNode,\n    })\n  }\n  // Finally, we emit remove mutations.\n  const removedNodeMutations: RemovedNodeMutation[] = []\n  removedNodes.forEach((parent, node) => {\n    if (hasSerializedNode(node)) {\n      removedNodeMutations.push({\n        parentId: getSerializedNodeId(parent),\n        id: getSerializedNodeId(node),\n      })\n    }\n  })\n\n  return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized }\n\n  function hasBeenSerialized(node: Node) {\n    return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node))\n  }\n\n  function getNextSibling(node: Node): null | number {\n    let nextSibling = node.nextSibling\n    while (nextSibling) {\n      if (hasSerializedNode(nextSibling)) {\n        return getSerializedNodeId(nextSibling)\n      }\n      nextSibling = nextSibling.nextSibling\n    }\n\n    return null\n  }\n}\n\nfunction processCharacterDataMutations(\n  mutations: Array<WithSerializedTarget<RumCharacterDataMutationRecord>>,\n  configuration: RumConfiguration\n) {\n  const textMutations: TextMutation[] = []\n\n  // Deduplicate mutations based on their target node\n  const handledNodes = new Set<Node>()\n  const filteredMutations = mutations.filter((mutation) => {\n    if (handledNodes.has(mutation.target)) {\n      return false\n    }\n    handledNodes.add(mutation.target)\n    return true\n  })\n\n  // Emit mutations\n  for (const mutation of filteredMutations) {\n    const value = mutation.target.textContent\n    if (value === mutation.oldValue) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(\n      getParentNode(mutation.target)!,\n      configuration.defaultPrivacyLevel\n    )\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    textMutations.push({\n      id: getSerializedNodeId(mutation.target),\n      // TODO: pass a valid \"ignoreWhiteSpace\" argument\n      value: getTextContent(mutation.target, false, parentNodePrivacyLevel) ?? null,\n    })\n  }\n\n  return textMutations\n}\n\nfunction processAttributesMutations(\n  mutations: Array<WithSerializedTarget<RumAttributesMutationRecord>>,\n  configuration: RumConfiguration\n) {\n  const attributeMutations: AttributeMutation[] = []\n\n  // Deduplicate mutations based on their target node and changed attribute\n  const handledElements = new Map<Element, Set<string>>()\n  const filteredMutations = mutations.filter((mutation) => {\n    const handledAttributes = handledElements.get(mutation.target)\n    if (handledAttributes?.has(mutation.attributeName!)) {\n      return false\n    }\n    if (!handledAttributes) {\n      handledElements.set(mutation.target, new Set([mutation.attributeName!]))\n    } else {\n      handledAttributes.add(mutation.attributeName!)\n    }\n    return true\n  })\n\n  // Emit mutations\n  const emittedMutations = new Map<Element, AttributeMutation>()\n  for (const mutation of filteredMutations) {\n    const uncensoredValue = mutation.target.getAttribute(mutation.attributeName!)\n    if (uncensoredValue === mutation.oldValue) {\n      continue\n    }\n    const privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel)\n    const attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName!, configuration)\n\n    let transformedValue: string | null\n    if (mutation.attributeName === 'value') {\n      const inputValue = getElementInputValue(mutation.target, privacyLevel)\n      if (inputValue === undefined) {\n        continue\n      }\n      transformedValue = inputValue\n    } else if (typeof attributeValue === 'string') {\n      transformedValue = attributeValue\n    } else {\n      transformedValue = null\n    }\n\n    let emittedMutation = emittedMutations.get(mutation.target)\n    if (!emittedMutation) {\n      emittedMutation = {\n        id: getSerializedNodeId(mutation.target),\n        attributes: {},\n      }\n      attributeMutations.push(emittedMutation)\n      emittedMutations.set(mutation.target, emittedMutation)\n    }\n\n    emittedMutation.attributes[mutation.attributeName!] = transformedValue\n  }\n\n  return attributeMutations\n}\n\nexport function sortAddedAndMovedNodes(nodes: Node[]) {\n  nodes.sort((a, b) => {\n    const position = a.compareDocumentPosition(b)\n    /* eslint-disable no-bitwise */\n    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1\n    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return -1\n    }\n    /* eslint-enable no-bitwise */\n    return 0\n  })\n}\nfunction traverseRemovedShadowDom(removedNode: Node, shadowDomRemovedCallback: ShadowRootCallBack) {\n  if (isNodeShadowHost(removedNode)) {\n    shadowDomRemovedCallback(removedNode.shadowRoot)\n  }\n  getChildNodes(removedNode).forEach((child) => traverseRemovedShadowDom(child, shadowDomRemovedCallback))\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}