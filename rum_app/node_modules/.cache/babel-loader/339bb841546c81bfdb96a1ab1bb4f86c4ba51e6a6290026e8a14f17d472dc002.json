{"ast":null,"code":"import { instrumentMethodAndCallOriginal } from '../tools/instrumentMethod';\nimport { monitor } from '../tools/monitor';\nimport { Observable } from '../tools/observable';\nimport { elapsed, relativeNow, clocksNow, timeStampNow } from '../tools/timeUtils';\nimport { normalizeUrl } from '../tools/urlPolyfill';\nimport { shallowClone } from '../tools/utils';\nvar xhrObservable;\nvar xhrContexts = new WeakMap();\nexport function initXhrObservable() {\n  if (!xhrObservable) {\n    xhrObservable = createXhrObservable();\n  }\n  return xhrObservable;\n}\nfunction createXhrObservable() {\n  var observable = new Observable(function () {\n    var stopInstrumentingStart = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'open', {\n      before: openXhr\n    }).stop;\n    var stopInstrumentingSend = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'send', {\n      before: function () {\n        sendXhr.call(this, observable);\n      }\n    }).stop;\n    var stopInstrumentingAbort = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'abort', {\n      before: abortXhr\n    }).stop;\n    return function () {\n      stopInstrumentingStart();\n      stopInstrumentingSend();\n      stopInstrumentingAbort();\n    };\n  });\n  return observable;\n}\nfunction openXhr(method, url) {\n  xhrContexts.set(this, {\n    state: 'open',\n    method: method,\n    url: normalizeUrl(String(url))\n  });\n}\nfunction sendXhr(observable) {\n  var _this = this;\n  var context = xhrContexts.get(this);\n  if (!context) {\n    return;\n  }\n  var startContext = context;\n  startContext.state = 'start';\n  startContext.startTime = relativeNow();\n  startContext.startClocks = clocksNow();\n  startContext.isAborted = false;\n  startContext.xhr = this;\n  var hasBeenReported = false;\n  var stopInstrumentingOnReadyStateChange = instrumentMethodAndCallOriginal(this, 'onreadystatechange', {\n    before: function () {\n      if (this.readyState === XMLHttpRequest.DONE) {\n        // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n        // application during a future event. For example, Angular is calling .abort() on\n        // completed requests during a onreadystatechange event, so the status becomes '0'\n        // before the request is collected.\n        onEnd();\n      }\n    }\n  }).stop;\n  var onEnd = monitor(function () {\n    _this.removeEventListener('loadend', onEnd);\n    stopInstrumentingOnReadyStateChange();\n    if (hasBeenReported) {\n      return;\n    }\n    hasBeenReported = true;\n    var completeContext = context;\n    completeContext.state = 'complete';\n    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow());\n    completeContext.status = _this.status;\n    observable.notify(shallowClone(completeContext));\n  });\n  this.addEventListener('loadend', onEnd);\n  observable.notify(startContext);\n}\nfunction abortXhr() {\n  var context = xhrContexts.get(this);\n  if (context) {\n    context.isAborted = true;\n  }\n}","map":{"version":3,"names":["instrumentMethodAndCallOriginal","monitor","Observable","elapsed","relativeNow","clocksNow","timeStampNow","normalizeUrl","shallowClone","xhrObservable","xhrContexts","WeakMap","initXhrObservable","createXhrObservable","observable","stopInstrumentingStart","XMLHttpRequest","prototype","before","openXhr","stop","stopInstrumentingSend","sendXhr","call","stopInstrumentingAbort","abortXhr","method","url","set","state","String","_this","context","get","startContext","startTime","startClocks","isAborted","xhr","hasBeenReported","stopInstrumentingOnReadyStateChange","readyState","DONE","onEnd","removeEventListener","completeContext","duration","timeStamp","status","notify","addEventListener"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/rum_and_trace_correlation/rum_app/node_modules/@datadog/browser-core/src/browser/xhrObservable.ts"],"sourcesContent":["import { instrumentMethodAndCallOriginal } from '../tools/instrumentMethod'\nimport { monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { Duration, RelativeTime, ClocksState } from '../tools/timeUtils'\nimport { elapsed, relativeNow, clocksNow, timeStampNow } from '../tools/timeUtils'\nimport { normalizeUrl } from '../tools/urlPolyfill'\nimport { shallowClone } from '../tools/utils'\n\nexport interface XhrOpenContext {\n  state: 'open'\n  method: string\n  url: string\n}\n\nexport interface XhrStartContext extends Omit<XhrOpenContext, 'state'> {\n  state: 'start'\n  startTime: RelativeTime // deprecated\n  startClocks: ClocksState\n  isAborted: boolean\n  xhr: XMLHttpRequest\n}\n\nexport interface XhrCompleteContext extends Omit<XhrStartContext, 'state'> {\n  state: 'complete'\n  duration: Duration\n  status: number\n}\n\nexport type XhrContext = XhrOpenContext | XhrStartContext | XhrCompleteContext\n\nlet xhrObservable: Observable<XhrContext> | undefined\nconst xhrContexts = new WeakMap<XMLHttpRequest, XhrContext>()\n\nexport function initXhrObservable() {\n  if (!xhrObservable) {\n    xhrObservable = createXhrObservable()\n  }\n  return xhrObservable\n}\n\nfunction createXhrObservable() {\n  const observable = new Observable<XhrContext>(() => {\n    const { stop: stopInstrumentingStart } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'open', {\n      before: openXhr,\n    })\n\n    const { stop: stopInstrumentingSend } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'send', {\n      before() {\n        sendXhr.call(this, observable)\n      },\n    })\n\n    const { stop: stopInstrumentingAbort } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'abort', {\n      before: abortXhr,\n    })\n\n    return () => {\n      stopInstrumentingStart()\n      stopInstrumentingSend()\n      stopInstrumentingAbort()\n    }\n  })\n  return observable\n}\n\nfunction openXhr(this: XMLHttpRequest, method: string, url: string | URL | undefined | null) {\n  xhrContexts.set(this, {\n    state: 'open',\n    method,\n    url: normalizeUrl(String(url)),\n  })\n}\n\nfunction sendXhr(this: XMLHttpRequest, observable: Observable<XhrContext>) {\n  const context = xhrContexts.get(this)\n  if (!context) {\n    return\n  }\n\n  const startContext = context as XhrStartContext\n  startContext.state = 'start'\n  startContext.startTime = relativeNow()\n  startContext.startClocks = clocksNow()\n  startContext.isAborted = false\n  startContext.xhr = this\n\n  let hasBeenReported = false\n\n  const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethodAndCallOriginal(this, 'onreadystatechange', {\n    before() {\n      if (this.readyState === XMLHttpRequest.DONE) {\n        // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n        // application during a future event. For example, Angular is calling .abort() on\n        // completed requests during a onreadystatechange event, so the status becomes '0'\n        // before the request is collected.\n        onEnd()\n      }\n    },\n  })\n\n  const onEnd = monitor(() => {\n    this.removeEventListener('loadend', onEnd)\n    stopInstrumentingOnReadyStateChange()\n    if (hasBeenReported) {\n      return\n    }\n    hasBeenReported = true\n\n    const completeContext = context as XhrCompleteContext\n    completeContext.state = 'complete'\n    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow())\n    completeContext.status = this.status\n    observable.notify(shallowClone(completeContext))\n  })\n  this.addEventListener('loadend', onEnd)\n  observable.notify(startContext)\n}\n\nfunction abortXhr(this: XMLHttpRequest) {\n  const context = xhrContexts.get(this) as XhrStartContext | undefined\n  if (context) {\n    context.isAborted = true\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}