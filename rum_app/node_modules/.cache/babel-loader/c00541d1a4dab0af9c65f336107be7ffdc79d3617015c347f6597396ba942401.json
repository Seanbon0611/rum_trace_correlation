{"ast":null,"code":"import { assign, startsWith } from '@datadog/browser-core';\nimport { isNodeShadowHost, isNodeShadowRoot, STABLE_ATTRIBUTES } from '@datadog/browser-rum-core';\nimport { NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN, CENSORED_STRING_MARK, CENSORED_IMG_MARK } from '../../constants';\nimport { NodeType } from '../../types';\nimport { getTextContent, shouldMaskNode, reducePrivacyLevel, getNodeSelfPrivacyLevel, MAX_ATTRIBUTE_VALUE_CHAR_LENGTH } from './privacy';\nimport { getSerializedNodeId, setSerializedNodeId, getElementInputValue, switchToAbsoluteUrl, serializeStyleSheets } from './serializationUtils';\nexport function serializeDocument(document, configuration, serializationContext) {\n  // We are sure that Documents are never ignored, so this function never returns null\n  return serializeNodeWithId(document, {\n    serializationContext: serializationContext,\n    parentNodePrivacyLevel: configuration.defaultPrivacyLevel,\n    configuration: configuration\n  });\n}\nexport function serializeNodeWithId(node, options) {\n  var serializedNode = serializeNode(node, options);\n  if (!serializedNode) {\n    return null;\n  }\n  // Try to reuse the previous id\n  var id = getSerializedNodeId(node) || generateNextId();\n  var serializedNodeWithId = serializedNode;\n  serializedNodeWithId.id = id;\n  setSerializedNodeId(node, id);\n  if (options.serializedNodeIds) {\n    options.serializedNodeIds.add(id);\n  }\n  return serializedNodeWithId;\n}\nfunction serializeNode(node, options) {\n  switch (node.nodeType) {\n    case node.DOCUMENT_NODE:\n      return serializeDocumentNode(node, options);\n    case node.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragmentNode(node, options);\n    case node.DOCUMENT_TYPE_NODE:\n      return serializeDocumentTypeNode(node);\n    case node.ELEMENT_NODE:\n      return serializeElementNode(node, options);\n    case node.TEXT_NODE:\n      return serializeTextNode(node, options);\n    case node.CDATA_SECTION_NODE:\n      return serializeCDataNode();\n  }\n}\nexport function serializeDocumentNode(document, options) {\n  return {\n    type: NodeType.Document,\n    childNodes: serializeChildNodes(document, options),\n    adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets)\n  };\n}\nfunction serializeDocumentTypeNode(documentType) {\n  return {\n    type: NodeType.DocumentType,\n    name: documentType.name,\n    publicId: documentType.publicId,\n    systemId: documentType.systemId\n  };\n}\nfunction serializeDocumentFragmentNode(element, options) {\n  var childNodes = [];\n  if (element.childNodes.length) {\n    childNodes = serializeChildNodes(element, options);\n  }\n  var isShadowRoot = isNodeShadowRoot(element);\n  if (isShadowRoot) {\n    options.serializationContext.shadowRootsController.addShadowRoot(element);\n  }\n  return {\n    type: NodeType.DocumentFragment,\n    childNodes: childNodes,\n    isShadowRoot: isShadowRoot,\n    adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined\n  };\n}\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\nexport function serializeElementNode(element, options) {\n  var _a;\n  var tagName = getValidTagName(element.tagName);\n  var isSVG = isSVGElement(element) || undefined;\n  // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n  // parentNodePrivacyLevel option to avoid iterating over all parents\n  var nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel);\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    var _b = element.getBoundingClientRect(),\n      width = _b.width,\n      height = _b.height;\n    return {\n      type: NodeType.Element,\n      tagName: tagName,\n      attributes: (_a = {\n        rr_width: \"\".concat(width, \"px\"),\n        rr_height: \"\".concat(height, \"px\")\n      }, _a[PRIVACY_ATTR_NAME] = PRIVACY_ATTR_VALUE_HIDDEN, _a),\n      childNodes: [],\n      isSVG: isSVG\n    };\n  }\n  // Ignore Elements like Script and some Link, Metas\n  if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n    return;\n  }\n  var attributes = getAttributesForPrivacyLevel(element, nodePrivacyLevel, options);\n  var childNodes = [];\n  if (element.childNodes.length) {\n    // OBJECT POOLING OPTIMIZATION:\n    // We should not create a new object systematically as it could impact performances. Try to reuse\n    // the same object as much as possible, and clone it only if we need to.\n    var childNodesSerializationOptions = void 0;\n    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n      childNodesSerializationOptions = options;\n    } else {\n      childNodesSerializationOptions = assign({}, options, {\n        parentNodePrivacyLevel: nodePrivacyLevel,\n        ignoreWhiteSpace: tagName === 'head'\n      });\n    }\n    childNodes = serializeChildNodes(element, childNodesSerializationOptions);\n  }\n  if (isNodeShadowHost(element)) {\n    var shadowRoot = serializeNodeWithId(element.shadowRoot, options);\n    if (shadowRoot !== null) {\n      childNodes.push(shadowRoot);\n    }\n  }\n  return {\n    type: NodeType.Element,\n    tagName: tagName,\n    attributes: attributes,\n    childNodes: childNodes,\n    isSVG: isSVG\n  };\n}\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\nfunction serializeTextNode(textNode, options) {\n  var _a;\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  var parentTagName = (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.tagName;\n  var textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel);\n  if (!textContent) {\n    return;\n  }\n  return {\n    type: NodeType.Text,\n    textContent: textContent,\n    isStyle: parentTagName === 'STYLE' ? true : undefined\n  };\n}\nfunction serializeCDataNode() {\n  return {\n    type: NodeType.CDATA,\n    textContent: ''\n  };\n}\nexport function serializeChildNodes(node, options) {\n  var result = [];\n  node.childNodes.forEach(function (childNode) {\n    var serializedChildNode = serializeNodeWithId(childNode, options);\n    if (serializedChildNode) {\n      result.push(serializedChildNode);\n    }\n  });\n  return result;\n}\nexport function serializeAttribute(element, nodePrivacyLevel, attributeName, configuration) {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // dup condition for direct access case\n    return null;\n  }\n  var attributeValue = element.getAttribute(attributeName);\n  if (nodePrivacyLevel === NodePrivacyLevel.MASK && attributeName !== PRIVACY_ATTR_NAME && !STABLE_ATTRIBUTES.includes(attributeName) && attributeName !== configuration.actionNameAttribute) {\n    var tagName = element.tagName;\n    switch (attributeName) {\n      // Mask Attribute text content\n      case 'title':\n      case 'alt':\n      case 'placeholder':\n        return CENSORED_STRING_MARK;\n    }\n    // mask image URLs\n    if (tagName === 'IMG' || tagName === 'SOURCE') {\n      if (attributeName === 'src' || attributeName === 'srcset') {\n        return CENSORED_IMG_MARK;\n      }\n    }\n    // mask <a> URLs\n    if (tagName === 'A' && attributeName === 'href') {\n      return CENSORED_STRING_MARK;\n    }\n    // mask data-* attributes\n    if (attributeValue && startsWith(attributeName, 'data-')) {\n      // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n      return CENSORED_STRING_MARK;\n    }\n  }\n  if (!attributeValue || typeof attributeValue !== 'string') {\n    return attributeValue;\n  }\n  // Minimum Fix for customer.\n  if (attributeValue.length > MAX_ATTRIBUTE_VALUE_CHAR_LENGTH && attributeValue.slice(0, 5) === 'data:') {\n    return 'data:truncated';\n  }\n  return attributeValue;\n}\nvar _nextId = 1;\nfunction generateNextId() {\n  return _nextId++;\n}\nvar TAG_NAME_REGEX = /[^a-z1-6-_]/;\nfunction getValidTagName(tagName) {\n  var processedTagName = tagName.toLowerCase().trim();\n  if (TAG_NAME_REGEX.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n  return processedTagName;\n}\nfunction getCssRulesString(s) {\n  try {\n    var rules = s.rules || s.cssRules;\n    if (rules) {\n      var styleSheetCssText = Array.from(rules, getCssRuleString).join('');\n      return switchToAbsoluteUrl(styleSheetCssText, s.href);\n    }\n    return null;\n  } catch (error) {\n    return null;\n  }\n}\nfunction getCssRuleString(rule) {\n  return isCSSImportRule(rule) ? getCssRulesString(rule.styleSheet) || '' : rule.cssText;\n}\nfunction isCSSImportRule(rule) {\n  return 'styleSheet' in rule;\n}\nfunction isSVGElement(el) {\n  return el.tagName === 'svg' || el instanceof SVGElement;\n}\nfunction getAttributesForPrivacyLevel(element, nodePrivacyLevel, options) {\n  var _a;\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return {};\n  }\n  var safeAttrs = {};\n  var tagName = getValidTagName(element.tagName);\n  var doc = element.ownerDocument;\n  for (var i = 0; i < element.attributes.length; i += 1) {\n    var attribute = element.attributes.item(i);\n    var attributeName = attribute.name;\n    var attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration);\n    if (attributeValue !== null) {\n      safeAttrs[attributeName] = attributeValue;\n    }\n  }\n  if (element.value && (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')) {\n    var formValue = getElementInputValue(element, nodePrivacyLevel);\n    if (formValue !== undefined) {\n      safeAttrs.value = formValue;\n    }\n  }\n  /**\n   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n   */\n  if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n    // For privacy=`MASK`, all the values would be the same, so skip.\n    var optionElement = element;\n    if (optionElement.selected) {\n      safeAttrs.selected = optionElement.selected;\n    }\n  }\n  // remote css\n  if (tagName === 'link') {\n    var stylesheet = Array.from(doc.styleSheets).find(function (s) {\n      return s.href === element.href;\n    });\n    var cssText = getCssRulesString(stylesheet);\n    if (cssText && stylesheet) {\n      safeAttrs._cssText = cssText;\n    }\n  }\n  // dynamic stylesheet\n  if (tagName === 'style' && element.sheet &&\n  // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n  !(element.innerText || element.textContent || '').trim().length) {\n    var cssText = getCssRulesString(element.sheet);\n    if (cssText) {\n      safeAttrs._cssText = cssText;\n    }\n  }\n  /**\n   * Forms: input[type=checkbox,radio]\n   * The `checked` property for <input> is a little bit special:\n   * 1. el.checked is a setter that returns if truthy.\n   * 2. getAttribute returns the string value\n   * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n   */\n  var inputElement = element;\n  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n    if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n      safeAttrs.checked = !!inputElement.checked;\n    } else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n      safeAttrs.checked = CENSORED_STRING_MARK;\n    }\n  }\n  /**\n   * Serialize the media playback state\n   */\n  if (tagName === 'audio' || tagName === 'video') {\n    var mediaElement = element;\n    safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played';\n  }\n  /**\n   * Serialize the scroll state for each element only for full snapshot\n   */\n  var scrollTop;\n  var scrollLeft;\n  var serializationContext = options.serializationContext;\n  switch (serializationContext.status) {\n    case 0 /* INITIAL_FULL_SNAPSHOT */:\n      scrollTop = Math.round(element.scrollTop);\n      scrollLeft = Math.round(element.scrollLeft);\n      if (scrollTop || scrollLeft) {\n        serializationContext.elementsScrollPositions.set(element, {\n          scrollTop: scrollTop,\n          scrollLeft: scrollLeft\n        });\n      }\n      break;\n    case 1 /* SUBSEQUENT_FULL_SNAPSHOT */:\n      if (serializationContext.elementsScrollPositions.has(element)) {\n        ;\n        _a = serializationContext.elementsScrollPositions.get(element), scrollTop = _a.scrollTop, scrollLeft = _a.scrollLeft;\n      }\n      break;\n  }\n  if (scrollLeft) {\n    safeAttrs.rr_scrollLeft = scrollLeft;\n  }\n  if (scrollTop) {\n    safeAttrs.rr_scrollTop = scrollTop;\n  }\n  return safeAttrs;\n}","map":{"version":3,"names":["assign","startsWith","isNodeShadowHost","isNodeShadowRoot","STABLE_ATTRIBUTES","NodePrivacyLevel","PRIVACY_ATTR_NAME","PRIVACY_ATTR_VALUE_HIDDEN","CENSORED_STRING_MARK","CENSORED_IMG_MARK","NodeType","getTextContent","shouldMaskNode","reducePrivacyLevel","getNodeSelfPrivacyLevel","MAX_ATTRIBUTE_VALUE_CHAR_LENGTH","getSerializedNodeId","setSerializedNodeId","getElementInputValue","switchToAbsoluteUrl","serializeStyleSheets","serializeDocument","document","configuration","serializationContext","serializeNodeWithId","parentNodePrivacyLevel","defaultPrivacyLevel","node","options","serializedNode","serializeNode","id","generateNextId","serializedNodeWithId","serializedNodeIds","add","nodeType","DOCUMENT_NODE","serializeDocumentNode","DOCUMENT_FRAGMENT_NODE","serializeDocumentFragmentNode","DOCUMENT_TYPE_NODE","serializeDocumentTypeNode","ELEMENT_NODE","serializeElementNode","TEXT_NODE","serializeTextNode","CDATA_SECTION_NODE","serializeCDataNode","type","Document","childNodes","serializeChildNodes","adoptedStyleSheets","documentType","DocumentType","name","publicId","systemId","element","length","isShadowRoot","shadowRootsController","addShadowRoot","DocumentFragment","undefined","tagName","getValidTagName","isSVG","isSVGElement","nodePrivacyLevel","HIDDEN","_b","getBoundingClientRect","width","height","Element","attributes","_a","rr_width","concat","rr_height","IGNORE","getAttributesForPrivacyLevel","childNodesSerializationOptions","ignoreWhiteSpace","shadowRoot","push","textNode","parentTagName","parentElement","textContent","Text","isStyle","CDATA","result","forEach","childNode","serializedChildNode","serializeAttribute","attributeName","attributeValue","getAttribute","MASK","includes","actionNameAttribute","slice","_nextId","TAG_NAME_REGEX","processedTagName","toLowerCase","trim","test","getCssRulesString","s","rules","cssRules","styleSheetCssText","Array","from","getCssRuleString","join","href","error","rule","isCSSImportRule","styleSheet","cssText","el","SVGElement","safeAttrs","doc","ownerDocument","i","attribute","item","value","formValue","ALLOW","optionElement","selected","stylesheet","styleSheets","find","_cssText","sheet","innerText","inputElement","checked","mediaElement","rr_mediaState","paused","scrollTop","scrollLeft","status","Math","round","elementsScrollPositions","set","has","get","rr_scrollLeft","rr_scrollTop"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/react-app/node_modules/@datadog/browser-rum/src/domain/record/serialize.ts"],"sourcesContent":["import { assign, startsWith } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { isNodeShadowHost, isNodeShadowRoot, STABLE_ATTRIBUTES } from '@datadog/browser-rum-core'\nimport {\n  NodePrivacyLevel,\n  PRIVACY_ATTR_NAME,\n  PRIVACY_ATTR_VALUE_HIDDEN,\n  CENSORED_STRING_MARK,\n  CENSORED_IMG_MARK,\n} from '../../constants'\nimport type {\n  SerializedNode,\n  SerializedNodeWithId,\n  DocumentNode,\n  DocumentTypeNode,\n  ElementNode,\n  TextNode,\n  CDataNode,\n  DocumentFragmentNode,\n} from '../../types'\nimport { NodeType } from '../../types'\nimport {\n  getTextContent,\n  shouldMaskNode,\n  reducePrivacyLevel,\n  getNodeSelfPrivacyLevel,\n  MAX_ATTRIBUTE_VALUE_CHAR_LENGTH,\n} from './privacy'\nimport {\n  getSerializedNodeId,\n  setSerializedNodeId,\n  getElementInputValue,\n  switchToAbsoluteUrl,\n  serializeStyleSheets,\n} from './serializationUtils'\nimport type { ElementsScrollPositions } from './elementsScrollPositions'\nimport type { ShadowRootsController } from './shadowRootsController'\nimport type { WithAdoptedStyleSheets } from './browser.types'\n\n// Those values are the only one that can be used when inheriting privacy levels from parent to\n// children during serialization, since HIDDEN and IGNORE shouldn't serialize their children. This\n// ensures that no children are serialized when they shouldn't.\ntype ParentNodePrivacyLevel =\n  | typeof NodePrivacyLevel.ALLOW\n  | typeof NodePrivacyLevel.MASK\n  | typeof NodePrivacyLevel.MASK_USER_INPUT\n\nexport const enum SerializationContextStatus {\n  INITIAL_FULL_SNAPSHOT,\n  SUBSEQUENT_FULL_SNAPSHOT,\n  MUTATION,\n}\n\nexport type SerializationContext =\n  | {\n      status: SerializationContextStatus.MUTATION\n      shadowRootsController: ShadowRootsController\n    }\n  | {\n      status: SerializationContextStatus.INITIAL_FULL_SNAPSHOT\n      elementsScrollPositions: ElementsScrollPositions\n      shadowRootsController: ShadowRootsController\n    }\n  | {\n      status: SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT\n      elementsScrollPositions: ElementsScrollPositions\n      shadowRootsController: ShadowRootsController\n    }\n\nexport interface SerializeOptions {\n  serializedNodeIds?: Set<number>\n  ignoreWhiteSpace?: boolean\n  parentNodePrivacyLevel: ParentNodePrivacyLevel\n  serializationContext: SerializationContext\n  configuration: RumConfiguration\n}\n\nexport function serializeDocument(\n  document: Document,\n  configuration: RumConfiguration,\n  serializationContext: SerializationContext\n): SerializedNodeWithId {\n  // We are sure that Documents are never ignored, so this function never returns null\n  return serializeNodeWithId(document, {\n    serializationContext,\n    parentNodePrivacyLevel: configuration.defaultPrivacyLevel,\n    configuration,\n  })!\n}\n\nexport function serializeNodeWithId(node: Node, options: SerializeOptions): SerializedNodeWithId | null {\n  const serializedNode = serializeNode(node, options)\n  if (!serializedNode) {\n    return null\n  }\n\n  // Try to reuse the previous id\n  const id = getSerializedNodeId(node) || generateNextId()\n  const serializedNodeWithId = serializedNode as SerializedNodeWithId\n  serializedNodeWithId.id = id\n  setSerializedNodeId(node, id)\n  if (options.serializedNodeIds) {\n    options.serializedNodeIds.add(id)\n  }\n  return serializedNodeWithId\n}\n\nfunction serializeNode(node: Node, options: SerializeOptions): SerializedNode | undefined {\n  switch (node.nodeType) {\n    case node.DOCUMENT_NODE:\n      return serializeDocumentNode(node as Document, options)\n    case node.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragmentNode(node as DocumentFragment, options)\n    case node.DOCUMENT_TYPE_NODE:\n      return serializeDocumentTypeNode(node as DocumentType)\n    case node.ELEMENT_NODE:\n      return serializeElementNode(node as Element, options)\n    case node.TEXT_NODE:\n      return serializeTextNode(node as Text, options)\n    case node.CDATA_SECTION_NODE:\n      return serializeCDataNode()\n  }\n}\n\nexport function serializeDocumentNode(document: Document, options: SerializeOptions): DocumentNode {\n  return {\n    type: NodeType.Document,\n    childNodes: serializeChildNodes(document, options),\n    adoptedStyleSheets: serializeStyleSheets((document as WithAdoptedStyleSheets).adoptedStyleSheets),\n  }\n}\n\nfunction serializeDocumentTypeNode(documentType: DocumentType): DocumentTypeNode {\n  return {\n    type: NodeType.DocumentType,\n    name: documentType.name,\n    publicId: documentType.publicId,\n    systemId: documentType.systemId,\n  }\n}\n\nfunction serializeDocumentFragmentNode(\n  element: DocumentFragment,\n  options: SerializeOptions\n): DocumentFragmentNode | undefined {\n  let childNodes: SerializedNodeWithId[] = []\n  if (element.childNodes.length) {\n    childNodes = serializeChildNodes(element, options)\n  }\n\n  const isShadowRoot = isNodeShadowRoot(element)\n  if (isShadowRoot) {\n    options.serializationContext.shadowRootsController.addShadowRoot(element)\n  }\n\n  return {\n    type: NodeType.DocumentFragment,\n    childNodes,\n    isShadowRoot,\n    adoptedStyleSheets: isShadowRoot\n      ? serializeStyleSheets((element as WithAdoptedStyleSheets).adoptedStyleSheets)\n      : undefined,\n  }\n}\n\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\nexport function serializeElementNode(element: Element, options: SerializeOptions): ElementNode | undefined {\n  const tagName = getValidTagName(element.tagName)\n  const isSVG = isSVGElement(element) || undefined\n\n  // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n  // parentNodePrivacyLevel option to avoid iterating over all parents\n  const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel)\n\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    const { width, height } = element.getBoundingClientRect()\n    return {\n      type: NodeType.Element,\n      tagName,\n      attributes: {\n        rr_width: `${width}px`,\n        rr_height: `${height}px`,\n        [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,\n      },\n      childNodes: [],\n      isSVG,\n    }\n  }\n\n  // Ignore Elements like Script and some Link, Metas\n  if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n    return\n  }\n\n  const attributes = getAttributesForPrivacyLevel(element, nodePrivacyLevel, options)\n\n  let childNodes: SerializedNodeWithId[] = []\n  if (element.childNodes.length) {\n    // OBJECT POOLING OPTIMIZATION:\n    // We should not create a new object systematically as it could impact performances. Try to reuse\n    // the same object as much as possible, and clone it only if we need to.\n    let childNodesSerializationOptions\n    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n      childNodesSerializationOptions = options\n    } else {\n      childNodesSerializationOptions = assign({}, options, {\n        parentNodePrivacyLevel: nodePrivacyLevel,\n        ignoreWhiteSpace: tagName === 'head',\n      })\n    }\n    childNodes = serializeChildNodes(element, childNodesSerializationOptions)\n  }\n\n  if (isNodeShadowHost(element)) {\n    const shadowRoot = serializeNodeWithId(element.shadowRoot, options)\n    if (shadowRoot !== null) {\n      childNodes.push(shadowRoot)\n    }\n  }\n\n  return {\n    type: NodeType.Element,\n    tagName,\n    attributes,\n    childNodes,\n    isSVG,\n  }\n}\n\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\nfunction serializeTextNode(textNode: Text, options: SerializeOptions): TextNode | undefined {\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = textNode.parentElement?.tagName\n  const textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel)\n  if (!textContent) {\n    return\n  }\n  return {\n    type: NodeType.Text,\n    textContent,\n    isStyle: parentTagName === 'STYLE' ? true : undefined,\n  }\n}\n\nfunction serializeCDataNode(): CDataNode {\n  return {\n    type: NodeType.CDATA,\n    textContent: '',\n  }\n}\n\nexport function serializeChildNodes(node: Node, options: SerializeOptions): SerializedNodeWithId[] {\n  const result: SerializedNodeWithId[] = []\n  node.childNodes.forEach((childNode) => {\n    const serializedChildNode = serializeNodeWithId(childNode, options)\n    if (serializedChildNode) {\n      result.push(serializedChildNode)\n    }\n  })\n  return result\n}\n\nexport function serializeAttribute(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  attributeName: string,\n  configuration: RumConfiguration\n): string | number | boolean | null {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // dup condition for direct access case\n    return null\n  }\n  const attributeValue = element.getAttribute(attributeName)\n  if (\n    nodePrivacyLevel === NodePrivacyLevel.MASK &&\n    attributeName !== PRIVACY_ATTR_NAME &&\n    !STABLE_ATTRIBUTES.includes(attributeName) &&\n    attributeName !== configuration.actionNameAttribute\n  ) {\n    const tagName = element.tagName\n\n    switch (attributeName) {\n      // Mask Attribute text content\n      case 'title':\n      case 'alt':\n      case 'placeholder':\n        return CENSORED_STRING_MARK\n    }\n    // mask image URLs\n    if (tagName === 'IMG' || tagName === 'SOURCE') {\n      if (attributeName === 'src' || attributeName === 'srcset') {\n        return CENSORED_IMG_MARK\n      }\n    }\n    // mask <a> URLs\n    if (tagName === 'A' && attributeName === 'href') {\n      return CENSORED_STRING_MARK\n    }\n\n    // mask data-* attributes\n    if (attributeValue && startsWith(attributeName, 'data-')) {\n      // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n      return CENSORED_STRING_MARK\n    }\n  }\n\n  if (!attributeValue || typeof attributeValue !== 'string') {\n    return attributeValue\n  }\n\n  // Minimum Fix for customer.\n  if (attributeValue.length > MAX_ATTRIBUTE_VALUE_CHAR_LENGTH && attributeValue.slice(0, 5) === 'data:') {\n    return 'data:truncated'\n  }\n\n  return attributeValue\n}\n\nlet _nextId = 1\nfunction generateNextId(): number {\n  return _nextId++\n}\n\nconst TAG_NAME_REGEX = /[^a-z1-6-_]/\nfunction getValidTagName(tagName: string): string {\n  const processedTagName = tagName.toLowerCase().trim()\n\n  if (TAG_NAME_REGEX.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div'\n  }\n\n  return processedTagName\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules\n    if (rules) {\n      const styleSheetCssText = Array.from(rules, getCssRuleString).join('')\n      return switchToAbsoluteUrl(styleSheetCssText, s.href)\n    }\n\n    return null\n  } catch (error) {\n    return null\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  return isCSSImportRule(rule) ? getCssRulesString(rule.styleSheet) || '' : rule.cssText\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement\n}\n\nfunction getAttributesForPrivacyLevel(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  options: SerializeOptions\n): Record<string, string | number | boolean> {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return {}\n  }\n  const safeAttrs: Record<string, string | number | boolean> = {}\n  const tagName = getValidTagName(element.tagName)\n  const doc = element.ownerDocument\n\n  type HtmlAttribute = { name: string; value: string }\n  for (let i = 0; i < element.attributes.length; i += 1) {\n    const attribute = element.attributes.item(i) as HtmlAttribute\n    const attributeName = attribute.name\n    const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration)\n    if (attributeValue !== null) {\n      safeAttrs[attributeName] = attributeValue\n    }\n  }\n\n  if (\n    (element as HTMLInputElement).value &&\n    (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')\n  ) {\n    const formValue = getElementInputValue(element, nodePrivacyLevel)\n    if (formValue !== undefined) {\n      safeAttrs.value = formValue\n    }\n  }\n\n  /**\n   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n   */\n  if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n    // For privacy=`MASK`, all the values would be the same, so skip.\n    const optionElement = element as HTMLOptionElement\n    if (optionElement.selected) {\n      safeAttrs.selected = optionElement.selected\n    }\n  }\n\n  // remote css\n  if (tagName === 'link') {\n    const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === (element as HTMLLinkElement).href)\n    const cssText = getCssRulesString(stylesheet as CSSStyleSheet)\n    if (cssText && stylesheet) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  // dynamic stylesheet\n  if (\n    tagName === 'style' &&\n    (element as HTMLStyleElement).sheet &&\n    // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n    !((element as HTMLStyleElement).innerText || element.textContent || '').trim().length\n  ) {\n    const cssText = getCssRulesString((element as HTMLStyleElement).sheet as CSSStyleSheet)\n    if (cssText) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  /**\n   * Forms: input[type=checkbox,radio]\n   * The `checked` property for <input> is a little bit special:\n   * 1. el.checked is a setter that returns if truthy.\n   * 2. getAttribute returns the string value\n   * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n   */\n  const inputElement = element as HTMLInputElement\n  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n    if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n      safeAttrs.checked = !!inputElement.checked\n    } else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n      safeAttrs.checked = CENSORED_STRING_MARK\n    }\n  }\n\n  /**\n   * Serialize the media playback state\n   */\n  if (tagName === 'audio' || tagName === 'video') {\n    const mediaElement = element as HTMLMediaElement\n    safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played'\n  }\n\n  /**\n   * Serialize the scroll state for each element only for full snapshot\n   */\n  let scrollTop: number | undefined\n  let scrollLeft: number | undefined\n  const serializationContext = options.serializationContext\n  switch (serializationContext.status) {\n    case SerializationContextStatus.INITIAL_FULL_SNAPSHOT:\n      scrollTop = Math.round(element.scrollTop)\n      scrollLeft = Math.round(element.scrollLeft)\n      if (scrollTop || scrollLeft) {\n        serializationContext.elementsScrollPositions.set(element, { scrollTop, scrollLeft })\n      }\n      break\n    case SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT:\n      if (serializationContext.elementsScrollPositions.has(element)) {\n        ;({ scrollTop, scrollLeft } = serializationContext.elementsScrollPositions.get(element)!)\n      }\n      break\n  }\n  if (scrollLeft) {\n    safeAttrs.rr_scrollLeft = scrollLeft\n  }\n  if (scrollTop) {\n    safeAttrs.rr_scrollTop = scrollTop\n  }\n\n  return safeAttrs\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}