{"ast":null,"code":"import { noop, round, ONE_SECOND, elapsed } from '@datadog/browser-core';\nimport { supportPerformanceTimingEvent } from '../../../browser/performanceCollection';\nimport { waitPageActivityEnd } from '../../waitPageActivityEnd';\nexport function trackViewMetrics(lifeCycle, domMutationObservable, configuration, scheduleViewUpdate, loadingType, viewStart) {\n  var viewMetrics = {};\n  var _a = trackLoadingTime(lifeCycle, domMutationObservable, configuration, loadingType, viewStart, function (newLoadingTime) {\n      viewMetrics.loadingTime = newLoadingTime;\n      scheduleViewUpdate();\n    }),\n    stopLoadingTimeTracking = _a.stop,\n    setLoadEvent = _a.setLoadEvent;\n  var stopCLSTracking;\n  if (isLayoutShiftSupported()) {\n    viewMetrics.cumulativeLayoutShift = 0;\n    stopCLSTracking = trackCumulativeLayoutShift(lifeCycle, function (cumulativeLayoutShift) {\n      viewMetrics.cumulativeLayoutShift = cumulativeLayoutShift;\n      scheduleViewUpdate();\n    }).stop;\n  } else {\n    stopCLSTracking = noop;\n  }\n  return {\n    stop: function () {\n      stopLoadingTimeTracking();\n      stopCLSTracking();\n    },\n    setLoadEvent: setLoadEvent,\n    viewMetrics: viewMetrics\n  };\n}\nfunction trackLoadingTime(lifeCycle, domMutationObservable, configuration, loadType, viewStart, callback) {\n  var isWaitingForLoadEvent = loadType === \"initial_load\" /* INITIAL_LOAD */;\n  var isWaitingForActivityLoadingTime = true;\n  var loadingTimeCandidates = [];\n  function invokeCallbackIfAllCandidatesAreReceived() {\n    if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {\n      callback(Math.max.apply(Math, loadingTimeCandidates));\n    }\n  }\n  var stop = waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, function (event) {\n    if (isWaitingForActivityLoadingTime) {\n      isWaitingForActivityLoadingTime = false;\n      if (event.hadActivity) {\n        loadingTimeCandidates.push(elapsed(viewStart.timeStamp, event.end));\n      }\n      invokeCallbackIfAllCandidatesAreReceived();\n    }\n  }).stop;\n  return {\n    stop: stop,\n    setLoadEvent: function (loadEvent) {\n      if (isWaitingForLoadEvent) {\n        isWaitingForLoadEvent = false;\n        loadingTimeCandidates.push(loadEvent);\n        invokeCallbackIfAllCandidatesAreReceived();\n      }\n    }\n  };\n}\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nfunction trackCumulativeLayoutShift(lifeCycle, callback) {\n  var maxClsValue = 0;\n  var window = slidingSessionWindow();\n  var stop = lifeCycle.subscribe(0 /* PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {\n    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n      var entry = entries_1[_i];\n      if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {\n        window.update(entry);\n        if (window.value() > maxClsValue) {\n          maxClsValue = window.value();\n          callback(round(maxClsValue, 4));\n        }\n      }\n    }\n  }).unsubscribe;\n  return {\n    stop: stop\n  };\n}\nfunction slidingSessionWindow() {\n  var value = 0;\n  var startTime;\n  var endTime;\n  return {\n    update: function (entry) {\n      var shouldCreateNewWindow = startTime === undefined || entry.startTime - endTime >= ONE_SECOND || entry.startTime - startTime >= 5 * ONE_SECOND;\n      if (shouldCreateNewWindow) {\n        startTime = endTime = entry.startTime;\n        value = entry.value;\n      } else {\n        value += entry.value;\n        endTime = entry.startTime;\n      }\n    },\n    value: function () {\n      return value;\n    }\n  };\n}\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nfunction isLayoutShiftSupported() {\n  return supportPerformanceTimingEvent('layout-shift');\n}","map":{"version":3,"names":["noop","round","ONE_SECOND","elapsed","supportPerformanceTimingEvent","waitPageActivityEnd","trackViewMetrics","lifeCycle","domMutationObservable","configuration","scheduleViewUpdate","loadingType","viewStart","viewMetrics","_a","trackLoadingTime","newLoadingTime","loadingTime","stopLoadingTimeTracking","stop","setLoadEvent","stopCLSTracking","isLayoutShiftSupported","cumulativeLayoutShift","trackCumulativeLayoutShift","loadType","callback","isWaitingForLoadEvent","isWaitingForActivityLoadingTime","loadingTimeCandidates","invokeCallbackIfAllCandidatesAreReceived","length","Math","max","apply","event","hadActivity","push","timeStamp","end","loadEvent","maxClsValue","window","slidingSessionWindow","subscribe","entries","_i","entries_1","entry","entryType","hadRecentInput","update","value","unsubscribe","startTime","endTime","shouldCreateNewWindow","undefined"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/react-app/node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/view/trackViewMetrics.ts"],"sourcesContent":["import type { Duration, RelativeTime, Observable, ClocksState } from '@datadog/browser-core'\nimport { noop, round, ONE_SECOND, elapsed } from '@datadog/browser-core'\nimport type { RumLayoutShiftTiming } from '../../../browser/performanceCollection'\nimport { supportPerformanceTimingEvent } from '../../../browser/performanceCollection'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { waitPageActivityEnd } from '../../waitPageActivityEnd'\n\nexport interface ViewMetrics {\n  loadingTime?: Duration\n  cumulativeLayoutShift?: number\n}\n\nexport function trackViewMetrics(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  scheduleViewUpdate: () => void,\n  loadingType: ViewLoadingType,\n  viewStart: ClocksState\n) {\n  const viewMetrics: ViewMetrics = {}\n\n  const { stop: stopLoadingTimeTracking, setLoadEvent } = trackLoadingTime(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    loadingType,\n    viewStart,\n    (newLoadingTime) => {\n      viewMetrics.loadingTime = newLoadingTime\n      scheduleViewUpdate()\n    }\n  )\n\n  let stopCLSTracking: () => void\n  if (isLayoutShiftSupported()) {\n    viewMetrics.cumulativeLayoutShift = 0\n    ;({ stop: stopCLSTracking } = trackCumulativeLayoutShift(lifeCycle, (cumulativeLayoutShift) => {\n      viewMetrics.cumulativeLayoutShift = cumulativeLayoutShift\n      scheduleViewUpdate()\n    }))\n  } else {\n    stopCLSTracking = noop\n  }\n  return {\n    stop: () => {\n      stopLoadingTimeTracking()\n      stopCLSTracking()\n    },\n    setLoadEvent,\n    viewMetrics,\n  }\n}\n\nfunction trackLoadingTime(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  loadType: ViewLoadingType,\n  viewStart: ClocksState,\n  callback: (loadingTime: Duration) => void\n) {\n  let isWaitingForLoadEvent = loadType === ViewLoadingType.INITIAL_LOAD\n  let isWaitingForActivityLoadingTime = true\n  const loadingTimeCandidates: Duration[] = []\n\n  function invokeCallbackIfAllCandidatesAreReceived() {\n    if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {\n      callback(Math.max(...loadingTimeCandidates) as Duration)\n    }\n  }\n\n  const { stop } = waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, (event) => {\n    if (isWaitingForActivityLoadingTime) {\n      isWaitingForActivityLoadingTime = false\n      if (event.hadActivity) {\n        loadingTimeCandidates.push(elapsed(viewStart.timeStamp, event.end))\n      }\n      invokeCallbackIfAllCandidatesAreReceived()\n    }\n  })\n\n  return {\n    stop,\n    setLoadEvent: (loadEvent: Duration) => {\n      if (isWaitingForLoadEvent) {\n        isWaitingForLoadEvent = false\n        loadingTimeCandidates.push(loadEvent)\n        invokeCallbackIfAllCandidatesAreReceived()\n      }\n    },\n  }\n}\n\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nfunction trackCumulativeLayoutShift(lifeCycle: LifeCycle, callback: (layoutShift: number) => void) {\n  let maxClsValue = 0\n  const window = slidingSessionWindow()\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {\n        window.update(entry)\n        if (window.value() > maxClsValue) {\n          maxClsValue = window.value()\n          callback(round(maxClsValue, 4))\n        }\n      }\n    }\n  })\n\n  return {\n    stop,\n  }\n}\n\nfunction slidingSessionWindow() {\n  let value = 0\n  let startTime: RelativeTime\n  let endTime: RelativeTime\n  return {\n    update: (entry: RumLayoutShiftTiming) => {\n      const shouldCreateNewWindow =\n        startTime === undefined ||\n        entry.startTime - endTime >= ONE_SECOND ||\n        entry.startTime - startTime >= 5 * ONE_SECOND\n      if (shouldCreateNewWindow) {\n        startTime = endTime = entry.startTime\n        value = entry.value\n      } else {\n        value += entry.value\n        endTime = entry.startTime\n      }\n    },\n    value: () => value,\n  }\n}\n\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nfunction isLayoutShiftSupported() {\n  return supportPerformanceTimingEvent('layout-shift')\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}