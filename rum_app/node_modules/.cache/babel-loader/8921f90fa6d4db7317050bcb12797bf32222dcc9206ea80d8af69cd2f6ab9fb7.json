{"ast":null,"code":"import { assign, addEventListeners, elapsed, ONE_MINUTE, find, findLast, relativeNow } from '@datadog/browser-core';\nimport { trackFirstHidden } from './trackFirstHidden';\n// Discard LCP and FCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport var TIMING_MAXIMUM_DELAY = 10 * ONE_MINUTE;\nexport function trackInitialViewTimings(lifeCycle, callback) {\n  var timings = {};\n  function setTimings(newTimings) {\n    assign(timings, newTimings);\n    callback(timings);\n  }\n  var stopNavigationTracking = trackNavigationTimings(lifeCycle, setTimings).stop;\n  var stopFCPTracking = trackFirstContentfulPaintTiming(lifeCycle, function (firstContentfulPaint) {\n    return setTimings({\n      firstContentfulPaint: firstContentfulPaint\n    });\n  }).stop;\n  var stopLCPTracking = trackLargestContentfulPaintTiming(lifeCycle, window, function (largestContentfulPaint) {\n    setTimings({\n      largestContentfulPaint: largestContentfulPaint\n    });\n  }).stop;\n  var stopFIDTracking = trackFirstInputTimings(lifeCycle, function (_a) {\n    var firstInputDelay = _a.firstInputDelay,\n      firstInputTime = _a.firstInputTime;\n    setTimings({\n      firstInputDelay: firstInputDelay,\n      firstInputTime: firstInputTime\n    });\n  }).stop;\n  return {\n    stop: function () {\n      stopNavigationTracking();\n      stopFCPTracking();\n      stopLCPTracking();\n      stopFIDTracking();\n    }\n  };\n}\nexport function trackNavigationTimings(lifeCycle, callback) {\n  var stop = lifeCycle.subscribe(0 /* PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {\n    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n      var entry = entries_1[_i];\n      if (entry.entryType === 'navigation') {\n        callback({\n          domComplete: entry.domComplete,\n          domContentLoaded: entry.domContentLoadedEventEnd,\n          domInteractive: entry.domInteractive,\n          loadEvent: entry.loadEventEnd,\n          // In some cases the value reported is negative or is larger\n          // than the current page time. Ignore these cases:\n          // https://github.com/GoogleChrome/web-vitals/issues/137\n          // https://github.com/GoogleChrome/web-vitals/issues/162\n          firstByte: entry.responseStart >= 0 && entry.responseStart <= relativeNow() ? entry.responseStart : undefined\n        });\n      }\n    }\n  }).unsubscribe;\n  return {\n    stop: stop\n  };\n}\nexport function trackFirstContentfulPaintTiming(lifeCycle, callback) {\n  var firstHidden = trackFirstHidden();\n  var stop = lifeCycle.subscribe(0 /* PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {\n    var fcpEntry = find(entries, function (entry) {\n      return entry.entryType === 'paint' && entry.name === 'first-contentful-paint' && entry.startTime < firstHidden.timeStamp && entry.startTime < TIMING_MAXIMUM_DELAY;\n    });\n    if (fcpEntry) {\n      callback(fcpEntry.startTime);\n    }\n  }).unsubscribe;\n  return {\n    stop: stop\n  };\n}\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts\n */\nexport function trackLargestContentfulPaintTiming(lifeCycle, eventTarget, callback) {\n  var firstHidden = trackFirstHidden();\n  // Ignore entries that come after the first user interaction.  According to the documentation, the\n  // browser should not send largest-contentful-paint entries after a user interact with the page,\n  // but the web-vitals reference implementation uses this as a safeguard.\n  var firstInteractionTimestamp = Infinity;\n  var stopEventListener = addEventListeners(eventTarget, [\"pointerdown\" /* POINTER_DOWN */, \"keydown\" /* KEY_DOWN */], function (event) {\n    firstInteractionTimestamp = event.timeStamp;\n  }, {\n    capture: true,\n    once: true\n  }).stop;\n  var unsubscribeLifeCycle = lifeCycle.subscribe(0 /* PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {\n    var lcpEntry = findLast(entries, function (entry) {\n      return entry.entryType === 'largest-contentful-paint' && entry.startTime < firstInteractionTimestamp && entry.startTime < firstHidden.timeStamp && entry.startTime < TIMING_MAXIMUM_DELAY;\n    });\n    if (lcpEntry) {\n      callback(lcpEntry.startTime);\n    }\n  }).unsubscribe;\n  return {\n    stop: function () {\n      stopEventListener();\n      unsubscribeLifeCycle();\n    }\n  };\n}\n/**\n * Track the first input occurring during the initial View to return:\n * - First Input Delay\n * - First Input Time\n * Callback is called at most one time.\n * Documentation: https://web.dev/fid/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts\n */\nexport function trackFirstInputTimings(lifeCycle, callback) {\n  var firstHidden = trackFirstHidden();\n  var stop = lifeCycle.subscribe(0 /* PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {\n    var firstInputEntry = find(entries, function (entry) {\n      return entry.entryType === 'first-input' && entry.startTime < firstHidden.timeStamp;\n    });\n    if (firstInputEntry) {\n      var firstInputDelay = elapsed(firstInputEntry.startTime, firstInputEntry.processingStart);\n      callback({\n        // Ensure firstInputDelay to be positive, see\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815\n        firstInputDelay: firstInputDelay >= 0 ? firstInputDelay : 0,\n        firstInputTime: firstInputEntry.startTime\n      });\n    }\n  }).unsubscribe;\n  return {\n    stop: stop\n  };\n}","map":{"version":3,"names":["assign","addEventListeners","elapsed","ONE_MINUTE","find","findLast","relativeNow","trackFirstHidden","TIMING_MAXIMUM_DELAY","trackInitialViewTimings","lifeCycle","callback","timings","setTimings","newTimings","stopNavigationTracking","trackNavigationTimings","stop","stopFCPTracking","trackFirstContentfulPaintTiming","firstContentfulPaint","stopLCPTracking","trackLargestContentfulPaintTiming","window","largestContentfulPaint","stopFIDTracking","trackFirstInputTimings","_a","firstInputDelay","firstInputTime","subscribe","entries","_i","entries_1","length","entry","entryType","domComplete","domContentLoaded","domContentLoadedEventEnd","domInteractive","loadEvent","loadEventEnd","firstByte","responseStart","undefined","unsubscribe","firstHidden","fcpEntry","name","startTime","timeStamp","eventTarget","firstInteractionTimestamp","Infinity","stopEventListener","event","capture","once","unsubscribeLifeCycle","lcpEntry","firstInputEntry","processingStart"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/apm-enablement-sessions/rum_and_trace_correlation/react-app/node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/view/trackInitialViewTimings.ts"],"sourcesContent":["import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport {\n  assign,\n  addEventListeners,\n  DOM_EVENT,\n  elapsed,\n  ONE_MINUTE,\n  find,\n  findLast,\n  relativeNow,\n} from '@datadog/browser-core'\n\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type {\n  RumFirstInputTiming,\n  RumLargestContentfulPaintTiming,\n  RumPerformancePaintTiming,\n} from '../../../browser/performanceCollection'\nimport { trackFirstHidden } from './trackFirstHidden'\n\n// Discard LCP and FCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport const TIMING_MAXIMUM_DELAY = 10 * ONE_MINUTE\n\nexport interface Timings {\n  firstContentfulPaint?: Duration\n  firstByte?: Duration\n  domInteractive?: Duration\n  domContentLoaded?: Duration\n  domComplete?: Duration\n  loadEvent?: Duration\n  largestContentfulPaint?: Duration\n  firstInputDelay?: Duration\n  firstInputTime?: Duration\n}\n\nexport function trackInitialViewTimings(lifeCycle: LifeCycle, callback: (timings: Timings) => void) {\n  const timings: Timings = {}\n  function setTimings(newTimings: Partial<Timings>) {\n    assign(timings, newTimings)\n    callback(timings)\n  }\n\n  const { stop: stopNavigationTracking } = trackNavigationTimings(lifeCycle, setTimings)\n  const { stop: stopFCPTracking } = trackFirstContentfulPaintTiming(lifeCycle, (firstContentfulPaint) =>\n    setTimings({ firstContentfulPaint })\n  )\n  const { stop: stopLCPTracking } = trackLargestContentfulPaintTiming(lifeCycle, window, (largestContentfulPaint) => {\n    setTimings({\n      largestContentfulPaint,\n    })\n  })\n  const { stop: stopFIDTracking } = trackFirstInputTimings(lifeCycle, ({ firstInputDelay, firstInputTime }) => {\n    setTimings({\n      firstInputDelay,\n      firstInputTime,\n    })\n  })\n\n  return {\n    stop: () => {\n      stopNavigationTracking()\n      stopFCPTracking()\n      stopLCPTracking()\n      stopFIDTracking()\n    },\n  }\n}\n\nexport function trackNavigationTimings(lifeCycle: LifeCycle, callback: (timings: Partial<Timings>) => void) {\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'navigation') {\n        callback({\n          domComplete: entry.domComplete,\n          domContentLoaded: entry.domContentLoadedEventEnd,\n          domInteractive: entry.domInteractive,\n          loadEvent: entry.loadEventEnd,\n          // In some cases the value reported is negative or is larger\n          // than the current page time. Ignore these cases:\n          // https://github.com/GoogleChrome/web-vitals/issues/137\n          // https://github.com/GoogleChrome/web-vitals/issues/162\n          firstByte: entry.responseStart >= 0 && entry.responseStart <= relativeNow() ? entry.responseStart : undefined,\n        })\n      }\n    }\n  })\n\n  return { stop }\n}\n\nexport function trackFirstContentfulPaintTiming(lifeCycle: LifeCycle, callback: (fcpTiming: RelativeTime) => void) {\n  const firstHidden = trackFirstHidden()\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    const fcpEntry = find(\n      entries,\n      (entry): entry is RumPerformancePaintTiming =>\n        entry.entryType === 'paint' &&\n        entry.name === 'first-contentful-paint' &&\n        entry.startTime < firstHidden.timeStamp &&\n        entry.startTime < TIMING_MAXIMUM_DELAY\n    )\n    if (fcpEntry) {\n      callback(fcpEntry.startTime)\n    }\n  })\n  return { stop }\n}\n\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts\n */\nexport function trackLargestContentfulPaintTiming(\n  lifeCycle: LifeCycle,\n  eventTarget: EventTarget,\n  callback: (lcpTiming: RelativeTime) => void\n) {\n  const firstHidden = trackFirstHidden()\n\n  // Ignore entries that come after the first user interaction.  According to the documentation, the\n  // browser should not send largest-contentful-paint entries after a user interact with the page,\n  // but the web-vitals reference implementation uses this as a safeguard.\n  let firstInteractionTimestamp = Infinity\n  const { stop: stopEventListener } = addEventListeners(\n    eventTarget,\n    [DOM_EVENT.POINTER_DOWN, DOM_EVENT.KEY_DOWN],\n    (event) => {\n      firstInteractionTimestamp = event.timeStamp\n    },\n    { capture: true, once: true }\n  )\n\n  const { unsubscribe: unsubscribeLifeCycle } = lifeCycle.subscribe(\n    LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED,\n    (entries) => {\n      const lcpEntry = findLast(\n        entries,\n        (entry): entry is RumLargestContentfulPaintTiming =>\n          entry.entryType === 'largest-contentful-paint' &&\n          entry.startTime < firstInteractionTimestamp &&\n          entry.startTime < firstHidden.timeStamp &&\n          entry.startTime < TIMING_MAXIMUM_DELAY\n      )\n      if (lcpEntry) {\n        callback(lcpEntry.startTime)\n      }\n    }\n  )\n\n  return {\n    stop: () => {\n      stopEventListener()\n      unsubscribeLifeCycle()\n    },\n  }\n}\n\n/**\n * Track the first input occurring during the initial View to return:\n * - First Input Delay\n * - First Input Time\n * Callback is called at most one time.\n * Documentation: https://web.dev/fid/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts\n */\nexport function trackFirstInputTimings(\n  lifeCycle: LifeCycle,\n  callback: ({ firstInputDelay, firstInputTime }: { firstInputDelay: Duration; firstInputTime: Duration }) => void\n) {\n  const firstHidden = trackFirstHidden()\n\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    const firstInputEntry = find(\n      entries,\n      (entry): entry is RumFirstInputTiming =>\n        entry.entryType === 'first-input' && entry.startTime < firstHidden.timeStamp\n    )\n    if (firstInputEntry) {\n      const firstInputDelay = elapsed(firstInputEntry.startTime, firstInputEntry.processingStart)\n      callback({\n        // Ensure firstInputDelay to be positive, see\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815\n        firstInputDelay: firstInputDelay >= 0 ? firstInputDelay : (0 as Duration),\n        firstInputTime: firstInputEntry.startTime as Duration,\n      })\n    }\n  })\n\n  return {\n    stop,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}