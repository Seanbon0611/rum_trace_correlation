{"ast":null,"code":"import { COOKIE_ACCESS_DELAY } from '../../browser/cookie';\nimport { monitor } from '../../tools/monitor';\nimport { Observable } from '../../tools/observable';\nimport { dateNow } from '../../tools/timeUtils';\nimport * as utils from '../../tools/utils';\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants';\nimport { retrieveSession, withCookieLockAccess } from './sessionCookieStore';\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore(options, productKey, computeSessionState) {\n  var renewObservable = new Observable();\n  var expireObservable = new Observable();\n  var watchSessionTimeoutId = setInterval(monitor(watchSession), COOKIE_ACCESS_DELAY);\n  var sessionCache = retrieveActiveSession();\n  function expandOrRenewSession() {\n    var isTracked;\n    withCookieLockAccess({\n      options: options,\n      process: function (cookieSession) {\n        var synchronizedSession = synchronizeSession(cookieSession);\n        isTracked = expandOrRenewCookie(synchronizedSession);\n        return synchronizedSession;\n      },\n      after: function (cookieSession) {\n        if (isTracked && !hasSessionInCache()) {\n          renewSession(cookieSession);\n        }\n        sessionCache = cookieSession;\n      }\n    });\n  }\n  function expandSession() {\n    withCookieLockAccess({\n      options: options,\n      process: function (cookieSession) {\n        return hasSessionInCache() ? synchronizeSession(cookieSession) : undefined;\n      }\n    });\n  }\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session cookie\n   * - if the session is not active, clear the session cookie and expire the session cache\n   */\n  function watchSession() {\n    withCookieLockAccess({\n      options: options,\n      process: function (cookieSession) {\n        return !isActiveSession(cookieSession) ? {} : undefined;\n      },\n      after: synchronizeSession\n    });\n  }\n  function synchronizeSession(cookieSession) {\n    if (!isActiveSession(cookieSession)) {\n      cookieSession = {};\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(cookieSession)) {\n        expireSession();\n      } else {\n        sessionCache = cookieSession;\n      }\n    }\n    return cookieSession;\n  }\n  function expandOrRenewCookie(cookieSession) {\n    var _a = computeSessionState(cookieSession[productKey]),\n      trackingType = _a.trackingType,\n      isTracked = _a.isTracked;\n    cookieSession[productKey] = trackingType;\n    if (isTracked && !cookieSession.id) {\n      cookieSession.id = utils.generateUUID();\n      cookieSession.created = String(dateNow());\n    }\n    return isTracked;\n  }\n  function hasSessionInCache() {\n    return sessionCache[productKey] !== undefined;\n  }\n  function isSessionInCacheOutdated(cookieSession) {\n    return sessionCache.id !== cookieSession.id || sessionCache[productKey] !== cookieSession[productKey];\n  }\n  function expireSession() {\n    sessionCache = {};\n    expireObservable.notify();\n  }\n  function renewSession(cookieSession) {\n    sessionCache = cookieSession;\n    renewObservable.notify();\n  }\n  function retrieveActiveSession() {\n    var session = retrieveSession();\n    if (isActiveSession(session)) {\n      return session;\n    }\n    return {};\n  }\n  function isActiveSession(session) {\n    // created and expire can be undefined for versions which was not storing them\n    // these checks could be removed when older versions will not be available/live anymore\n    return (session.created === undefined || dateNow() - Number(session.created) < SESSION_TIME_OUT_DELAY) && (session.expire === undefined || dateNow() < Number(session.expire));\n  }\n  return {\n    expandOrRenewSession: utils.throttle(monitor(expandOrRenewSession), COOKIE_ACCESS_DELAY).throttled,\n    expandSession: expandSession,\n    getSession: function () {\n      return sessionCache;\n    },\n    renewObservable: renewObservable,\n    expireObservable: expireObservable,\n    stop: function () {\n      clearInterval(watchSessionTimeoutId);\n    }\n  };\n}","map":{"version":3,"names":["COOKIE_ACCESS_DELAY","monitor","Observable","dateNow","utils","SESSION_TIME_OUT_DELAY","retrieveSession","withCookieLockAccess","startSessionStore","options","productKey","computeSessionState","renewObservable","expireObservable","watchSessionTimeoutId","setInterval","watchSession","sessionCache","retrieveActiveSession","expandOrRenewSession","isTracked","process","cookieSession","synchronizedSession","synchronizeSession","expandOrRenewCookie","after","hasSessionInCache","renewSession","expandSession","undefined","isActiveSession","isSessionInCacheOutdated","expireSession","_a","trackingType","id","generateUUID","created","String","notify","session","Number","expire","throttle","throttled","getSession","stop","clearInterval"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/apm-enablement-sessions/rum_and_trace_correlation/react-app/node_modules/@datadog/browser-core/src/domain/session/sessionStore.ts"],"sourcesContent":["import type { CookieOptions } from '../../browser/cookie'\nimport { COOKIE_ACCESS_DELAY } from '../../browser/cookie'\nimport { monitor } from '../../tools/monitor'\nimport { Observable } from '../../tools/observable'\nimport { dateNow } from '../../tools/timeUtils'\nimport * as utils from '../../tools/utils'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { retrieveSession, withCookieLockAccess } from './sessionCookieStore'\n\nexport interface SessionStore {\n  expandOrRenewSession: () => void\n  expandSession: () => void\n  getSession: () => SessionState\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  stop: () => void\n}\n\nexport interface SessionState {\n  id?: string\n  created?: string\n  expire?: string\n  lock?: string\n\n  [key: string]: string | undefined\n}\n\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore<TrackingType extends string>(\n  options: CookieOptions,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionStore {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n\n  const watchSessionTimeoutId = setInterval(monitor(watchSession), COOKIE_ACCESS_DELAY)\n  let sessionCache: SessionState = retrieveActiveSession()\n\n  function expandOrRenewSession() {\n    let isTracked: boolean\n    withCookieLockAccess({\n      options,\n      process: (cookieSession) => {\n        const synchronizedSession = synchronizeSession(cookieSession)\n        isTracked = expandOrRenewCookie(synchronizedSession)\n        return synchronizedSession\n      },\n      after: (cookieSession) => {\n        if (isTracked && !hasSessionInCache()) {\n          renewSession(cookieSession)\n        }\n        sessionCache = cookieSession\n      },\n    })\n  }\n\n  function expandSession() {\n    withCookieLockAccess({\n      options,\n      process: (cookieSession) => (hasSessionInCache() ? synchronizeSession(cookieSession) : undefined),\n    })\n  }\n\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session cookie\n   * - if the session is not active, clear the session cookie and expire the session cache\n   */\n  function watchSession() {\n    withCookieLockAccess({\n      options,\n      process: (cookieSession) => (!isActiveSession(cookieSession) ? {} : undefined),\n      after: synchronizeSession,\n    })\n  }\n\n  function synchronizeSession(cookieSession: SessionState) {\n    if (!isActiveSession(cookieSession)) {\n      cookieSession = {}\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(cookieSession)) {\n        expireSession()\n      } else {\n        sessionCache = cookieSession\n      }\n    }\n    return cookieSession\n  }\n\n  function expandOrRenewCookie(cookieSession: SessionState) {\n    const { trackingType, isTracked } = computeSessionState(cookieSession[productKey])\n    cookieSession[productKey] = trackingType\n    if (isTracked && !cookieSession.id) {\n      cookieSession.id = utils.generateUUID()\n      cookieSession.created = String(dateNow())\n    }\n    return isTracked\n  }\n\n  function hasSessionInCache() {\n    return sessionCache[productKey] !== undefined\n  }\n\n  function isSessionInCacheOutdated(cookieSession: SessionState) {\n    return sessionCache.id !== cookieSession.id || sessionCache[productKey] !== cookieSession[productKey]\n  }\n\n  function expireSession() {\n    sessionCache = {}\n    expireObservable.notify()\n  }\n\n  function renewSession(cookieSession: SessionState) {\n    sessionCache = cookieSession\n    renewObservable.notify()\n  }\n\n  function retrieveActiveSession(): SessionState {\n    const session = retrieveSession()\n    if (isActiveSession(session)) {\n      return session\n    }\n    return {}\n  }\n\n  function isActiveSession(session: SessionState) {\n    // created and expire can be undefined for versions which was not storing them\n    // these checks could be removed when older versions will not be available/live anymore\n    return (\n      (session.created === undefined || dateNow() - Number(session.created) < SESSION_TIME_OUT_DELAY) &&\n      (session.expire === undefined || dateNow() < Number(session.expire))\n    )\n  }\n\n  return {\n    expandOrRenewSession: utils.throttle(monitor(expandOrRenewSession), COOKIE_ACCESS_DELAY).throttled,\n    expandSession,\n    getSession: () => sessionCache,\n    renewObservable,\n    expireObservable,\n    stop: () => {\n      clearInterval(watchSessionTimeoutId)\n    },\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}