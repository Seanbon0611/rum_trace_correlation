{"ast":null,"code":"/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n// Scrollbar widths vary across properties on different devices and browsers\nvar TOLERANCE = 25;\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn() {\n  var visual = window.visualViewport;\n  return Math.abs(visual.pageTop - visual.offsetTop - window.scrollY) > TOLERANCE || Math.abs(visual.pageLeft - visual.offsetLeft - window.scrollX) > TOLERANCE;\n}\nexport var convertMouseEventToLayoutCoordinates = function (clientX, clientY) {\n  var visual = window.visualViewport;\n  var normalised = {\n    layoutViewportX: clientX,\n    layoutViewportY: clientY,\n    visualViewportX: clientX,\n    visualViewportY: clientY\n  };\n  if (!visual) {\n    // On old browsers, we cannot normalise, so fallback to clientX/Y\n    return normalised;\n  } else if (isVisualViewportFactoredIn()) {\n    // Typically Mobile Devices\n    normalised.layoutViewportX = Math.round(clientX + visual.offsetLeft);\n    normalised.layoutViewportY = Math.round(clientY + visual.offsetTop);\n  } else {\n    // Typically Desktop Devices\n    normalised.visualViewportX = Math.round(clientX - visual.offsetLeft);\n    normalised.visualViewportY = Math.round(clientY - visual.offsetTop);\n  }\n  return normalised;\n};\nexport var getVisualViewport = function () {\n  var visual = window.visualViewport;\n  return {\n    scale: visual.scale,\n    offsetLeft: visual.offsetLeft,\n    offsetTop: visual.offsetTop,\n    pageLeft: visual.pageLeft,\n    pageTop: visual.pageTop,\n    height: visual.height,\n    width: visual.width\n  };\n};\nexport function getScrollX() {\n  var scrollX;\n  var visual = window.visualViewport;\n  if (visual) {\n    scrollX = visual.pageLeft - visual.offsetLeft;\n  } else if (window.scrollX !== undefined) {\n    scrollX = window.scrollX;\n  } else {\n    scrollX = window.pageXOffset || 0;\n  }\n  return Math.round(scrollX);\n}\nexport function getScrollY() {\n  var scrollY;\n  var visual = window.visualViewport;\n  if (visual) {\n    scrollY = visual.pageTop - visual.offsetTop;\n  } else if (window.scrollY !== undefined) {\n    scrollY = window.scrollY;\n  } else {\n    scrollY = window.pageYOffset || 0;\n  }\n  return Math.round(scrollY);\n}","map":{"version":3,"names":["TOLERANCE","isVisualViewportFactoredIn","visual","window","visualViewport","Math","abs","pageTop","offsetTop","scrollY","pageLeft","offsetLeft","scrollX","convertMouseEventToLayoutCoordinates","clientX","clientY","normalised","layoutViewportX","layoutViewportY","visualViewportX","visualViewportY","round","getVisualViewport","scale","height","width","getScrollX","undefined","pageXOffset","getScrollY","pageYOffset"],"sources":["/Users/sean.dever/Desktop/PersonalRepos/rum_and_trace_correlation/rum_app/node_modules/@datadog/browser-rum/src/domain/record/viewports.ts"],"sourcesContent":["/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n\nimport type { VisualViewportRecord } from '../../types'\n\n// Scrollbar widths vary across properties on different devices and browsers\nconst TOLERANCE = 25\n\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn() {\n  const visual = window.visualViewport\n  return (\n    Math.abs(visual.pageTop - visual.offsetTop - window.scrollY) > TOLERANCE ||\n    Math.abs(visual.pageLeft - visual.offsetLeft - window.scrollX) > TOLERANCE\n  )\n}\n\ninterface LayoutCoordinates {\n  layoutViewportX: number\n  layoutViewportY: number\n  visualViewportX: number\n  visualViewportY: number\n}\n\nexport const convertMouseEventToLayoutCoordinates = (clientX: number, clientY: number): LayoutCoordinates => {\n  const visual = window.visualViewport\n  const normalised: LayoutCoordinates = {\n    layoutViewportX: clientX,\n    layoutViewportY: clientY,\n    visualViewportX: clientX,\n    visualViewportY: clientY,\n  }\n\n  if (!visual) {\n    // On old browsers, we cannot normalise, so fallback to clientX/Y\n    return normalised\n  } else if (isVisualViewportFactoredIn()) {\n    // Typically Mobile Devices\n    normalised.layoutViewportX = Math.round(clientX + visual.offsetLeft)\n    normalised.layoutViewportY = Math.round(clientY + visual.offsetTop)\n  } else {\n    // Typically Desktop Devices\n    normalised.visualViewportX = Math.round(clientX - visual.offsetLeft)\n    normalised.visualViewportY = Math.round(clientY - visual.offsetTop)\n  }\n  return normalised\n}\n\nexport const getVisualViewport = (): VisualViewportRecord['data'] => {\n  const visual = window.visualViewport\n  return {\n    scale: visual.scale,\n    offsetLeft: visual.offsetLeft,\n    offsetTop: visual.offsetTop,\n    pageLeft: visual.pageLeft,\n    pageTop: visual.pageTop,\n    height: visual.height,\n    width: visual.width,\n  }\n}\n\nexport function getScrollX() {\n  let scrollX\n  const visual = window.visualViewport\n  if (visual) {\n    scrollX = visual.pageLeft - visual.offsetLeft\n  } else if (window.scrollX !== undefined) {\n    scrollX = window.scrollX\n  } else {\n    scrollX = window.pageXOffset || 0\n  }\n  return Math.round(scrollX)\n}\n\nexport function getScrollY() {\n  let scrollY\n  const visual = window.visualViewport\n  if (visual) {\n    scrollY = visual.pageTop - visual.offsetTop\n  } else if (window.scrollY !== undefined) {\n    scrollY = window.scrollY\n  } else {\n    scrollY = window.pageYOffset || 0\n  }\n  return Math.round(scrollY)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}